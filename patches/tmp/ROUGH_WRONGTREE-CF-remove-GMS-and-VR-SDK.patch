From 620c3fc8947803b0c78dc61eec741ebea73b8911 Mon Sep 17 00:00:00 2001
From: thermatk <thermatk@thermatk.com>
Date: Sat, 9 Jun 2018 11:46:46 +0200
Subject: [PATCH] [CF] remove GMS and VR SDK

---
 app/build.gradle                              |   9 +-
 app/libs/gcm.jar                              | Bin 28394 -> 0 bytes
 app/src/main/AndroidManifest.xml              | 210 +----
 .../contrib/MultiplexingGcmListener.java      |  66 +-
 .../channel/AndroidGcmController.java         |  43 +-
 .../AndroidInstanceIDListenerService.java     |  16 +-
 .../AndroidMessageReceiverService.java        |  11 -
 .../channel/AndroidMessageSenderService.java  |  10 +-
 .../channel/GcmRegistrationTaskService.java   |  91 +-
 .../vr/cardboard/DisplaySynchronizer.java     |  16 +
 .../google/vr/cardboard/EglReadyListener.java |   4 +
 .../internal/controller/NativeCallbacks.java  |  31 +
 .../java/com/google/vr/ndk/base/GvrApi.java   | 280 ++++++
 .../browser/BackgroundSyncLauncher.java       |  84 --
 .../browser/ChromeBackgroundService.java      |  64 +-
 .../chrome/browser/ChromeVersionInfo.java     |  12 +-
 .../externalauth/ExternalAuthUtils.java       |  43 +-
 .../UserRecoverableErrorHandler.java          |  25 -
 .../gcore/ChromeGoogleApiClientImpl.java      |  34 +-
 .../browser/gcore/GoogleApiClientHelper.java  |  77 +-
 .../remote/AbstractMediaRouteController.java  | 653 -------------
 .../remote/DefaultMediaRouteController.java   | 870 ------------------
 .../remote/ExpandedControllerActivity.java    |   3 -
 .../media/remote/MediaUrlResolver.java        | 268 ------
 .../media/remote/PositionExtrapolator.java    | 122 ---
 .../remote/RemoteMediaPlayerController.java   |  11 -
 .../remote/RemoteMediaPlayerWrapper.java      | 159 ----
 .../media/router/ChromeMediaRouter.java       |  30 -
 .../ChromeMediaRouterDialogController.java    |  40 +-
 .../router/cast/BaseMediaRouteProvider.java   | 231 -----
 .../router/cast/CastMediaRouteProvider.java   | 431 ---------
 .../media/router/cast/CastMediaSource.java    | 261 ------
 .../media/router/cast/CastMessageHandler.java | 624 -------------
 .../router/cast/CastRequestIdGenerator.java   |  37 -
 .../media/router/cast/CastSession.java        | 137 ---
 .../media/router/cast/CastSessionImpl.java    | 491 ----------
 .../media/router/cast/CastSessionInfo.java    | 324 -------
 .../media/router/cast/CastSessionUtil.java    |  50 -
 .../router/cast/ChromeCastSessionManager.java | 230 -----
 .../media/router/cast/ClientRecord.java       |  70 --
 .../media/router/cast/CreateRouteRequest.java | 270 ------
 .../media/router/cast/DiscoveryCallback.java  |  90 --
 .../browser/media/router/cast/MediaSink.java  |  13 +-
 .../media/router/cast/MediaSource.java        |  30 -
 .../cast/remoting/RemotingCastSession.java    | 192 ----
 .../remoting/RemotingMediaRouteProvider.java  | 127 ---
 .../cast/remoting/RemotingMediaSource.java    | 110 ---
 .../ntp/snippets/SnippetsLauncher.java        |  50 +-
 .../browser/omaha/UpdateMenuItemHelper.java   |  10 +-
 .../NearbyBackgroundSubscription.java         |  19 -
 .../NearbyForegroundSubscription.java         |  33 -
 .../NearbyMessageIntentService.java           |   6 -
 .../physicalweb/NearbySubscription.java       |  59 +-
 .../physicalweb/PhysicalWebBleClient.java     |  57 +-
 .../gcm/ChromeGcmListenerService.java         |  23 +-
 .../gcm/InvalidationGcmUpstreamSender.java    |   7 -
 .../chrome/browser/signin/SigninHelper.java   |  21 -
 .../vr_shell/VrClassesWrapperImpl.java        |   3 -
 .../vr_shell/VrCoreVersionCheckerImpl.java    |  33 +-
 .../browser/vr_shell/VrDaydreamApiImpl.java   |  65 +-
 .../chrome/browser/vr_shell/VrShellImpl.java  | 125 +--
 .../BackgroundTaskGcmTaskService.java         |  53 +-
 ...kgroundTaskSchedulerGcmNetworkManager.java | 159 +---
 .../instance_id/InstanceIDWithSubtype.java    |  27 +-
 .../components/signin/AccountIdProvider.java  |  19 +-
 .../signin/GmsAvailabilityException.java      |   4 +-
 .../signin/SystemAccountManagerDelegate.java  |  57 +-
 .../geolocation/LocationProviderGmsCore.java  |  87 +-
 .../device/vr/NonPresentingGvrContext.java    |  20 +-
 .../shape_detection/BarcodeDetectionImpl.java |  56 +-
 .../chromium/shape_detection/BitmapUtils.java |  12 -
 .../FaceDetectionImplGmsCore.java             | 116 +--
 .../FaceDetectionProviderImpl.java            |   8 +-
 .../shape_detection/TextDetectionImpl.java    |  52 +-
 74 files changed, 429 insertions(+), 7752 deletions(-)
 delete mode 100644 app/libs/gcm.jar
 create mode 100644 app/src/main/java/com/google/vr/cardboard/DisplaySynchronizer.java
 create mode 100644 app/src/main/java/com/google/vr/cardboard/EglReadyListener.java
 create mode 100644 app/src/main/java/com/google/vr/internal/controller/NativeCallbacks.java
 create mode 100644 app/src/main/java/com/google/vr/ndk/base/GvrApi.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/remote/AbstractMediaRouteController.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/remote/DefaultMediaRouteController.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/remote/MediaUrlResolver.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/remote/PositionExtrapolator.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/remote/RemoteMediaPlayerWrapper.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/BaseMediaRouteProvider.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMediaRouteProvider.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMediaSource.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMessageHandler.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastRequestIdGenerator.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSession.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionImpl.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionInfo.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionUtil.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/ChromeCastSessionManager.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/ClientRecord.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/CreateRouteRequest.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/DiscoveryCallback.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/MediaSource.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingCastSession.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingMediaRouteProvider.java
 delete mode 100644 app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingMediaSource.java

diff --git a/app/build.gradle b/app/build.gradle
index 3ebf192..dcf97f5 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -66,14 +66,7 @@ dependencies {
     implementation "com.android.support:gridlayout-v7:$rootProject.ext.supportLibraryVersion"
     implementation "com.android.support:mediarouter-v7:$rootProject.ext.supportLibraryVersion"
     implementation "com.android.support:support-v13:$rootProject.ext.supportLibraryVersion"
-    implementation "com.google.android.gms:play-services-auth:$rootProject.ext.playServicesVersion"
-    implementation "com.google.android.gms:play-services-cast:$rootProject.ext.playServicesVersion"
-    implementation "com.google.android.gms:play-services-gcm:$rootProject.ext.playServicesVersion"
-    implementation "com.google.android.gms:play-services-identity:$rootProject.ext.playServicesVersion"
-    implementation "com.google.android.gms:play-services-nearby:$rootProject.ext.playServicesVersion"
-    implementation "com.google.android.gms:play-services-vision:$rootProject.ext.playServicesVersion"
-    implementation "com.google.android.gms:play-services-location:$rootProject.ext.playServicesVersion"
-    implementation "com.google.vr:sdk-base:$rootProject.ext.googleVRVersion"
+    implementation 'com.google.protobuf.nano:protobuf-javanano:3.1.0'
     implementation 'com.android.support:multidex:1.0.3'
     implementation 'com.google.code.findbugs:jsr305:3.0.2'
     implementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'
diff --git a/app/libs/gcm.jar b/app/libs/gcm.jar
deleted file mode 100644
index e61cf122653007a7d3ea0afaa4f9055bf2092745..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 28394
zcmcJ22Vk4k)%H2EWy!KKEXNMYR6>U1nS_uKXWEV&lz3q~aRMzyvE@WWmW(7Pgp!tB
zD4mqD3zQb}(?THw$003gp{(xqYfB4%2efoU2VeVl^FQa__my4^o6zrTAoe@%J@?$R
z@4e@|>D*dSIF0n5c~vj8zInGFH}Y4Ww)uM+YXj{q^=*yqffj#vPhDF}TQC|P3?-7a
z+e7h0I2LX2Evs8P$<-VW1(TtH+NJ~Y;GDXpealuX^Hp}lgZ+_^uQ?VUj>UsXv|lpG
zHObYPF>Kvy-*4LCAd<gJFl>KpsD5`WwmTB44@L*#vG73s?*5_r&CPAiv1lS0j3yIx
z{gGfI@#TL#{sh`DqaLO+PotNEm}%<8!F|E{NHDs)zGK(Lq5h<U3YbbWpi2{`8G-g5
ze|t|~Pe&i#_I3F;2fBN@8hZjA?M$B5G@R~aJRIG<hG{X7sMDy|8K~FwFCQ4H3rCZo
zXtGX&@OL@M$uuhy{I>SY0hYW4EVI2pD`8q_Kx^shXv;yjueq_cwW+arD^vAbfVCpw
zq{&RPvjMjTnz|ahc7h%~T{|`5v*!$UrKgNmPAX-Zo(-tY-`(A~+0V4-Epcl02e$j2
zG>ysa-vJ)<b^F^l`Ma2k5~1ioDDI@`Og{apv9q%^(5%?h*NJ9<_RW2IXr_YT@UW9+
zfPK1cnuz{QfISk8hjxb($xu8r;H241CAyivtE&Tp*+cPo3}gA2%JmB?wfX`8F+~H=
zvfdX4lrvL}yF2~OfyUOp)V$q8p+q9MJJgpvFdTByBBqM%jjh}KeVhEP{vQ7(vt>7=
zb|4f9LBaZrE(s?sVJg#D^mOz9tkH>SQZkkdM*55%PO1UiPJdThpt~EQtAs<-18~Qc
z*x^uoD4Y-tuM=83sh(-xCVxxgw$>hloM1xN_CT}0uer6cySuNwu?@T|t%I%vl(=_?
z;`_q=nAmcrnTmv|9_<}HeT~~21Felst>{#4LdtmVq_c%~Li@hP=H`xV&_y+g_RS!4
z))Ob4lNzOQThF;rTvG^IFpjXdJnwTSL2=K}qXgPP|G=ic&c-fGrpMm}3VCuLI%z%A
zw9GE1Ku$KB>jzG1WSXO!cAneO?$0nIed+~<AMcfufOpZ_a5S96kOh@Xw!5i?HoK^h
z&IR+*CTLqUF)|Dr3lZr6>y)YWU)moU7Mts!EiT$BJqnY1!U-6QR%qN?*;tTel4)?a
z2O}dPbZ?Fg;FqU0)*p;)55~j6U6D|a`~X8*!_iRt$k47(+<4;Zj*Z0oLoMM*2sYXV
zoQcZGOGN}jOdYthQ8DgamU}nuCt2>N;C`y*-h=xx%e}y>u-u=4d#~kwChlfg?&sis
zuH}9n?&n+X7vO%O<$f{lD=qg`xUaU{*W$j;a=#S!%PjY2;eLhXekJZ#S?*WkzQJ<8
z7WeBc_Zx7((Q@B}`)13%AC$C-NZ@xTDB6HK#&37kaSEKItvioX>nTO)^W>?1M{U%O
zyDt27p*_*v;LSaF*Ntl%*)!eqoI4k9e&B2(`8%<D?o!4x9*k$YXPa+A_nhkW7VbIK
zu1>q>Rc3I|A5-S0et4+9GuXcu1{FaHe#RHH2ZuuKv1ChZBsyTxh9a1<x9sc?A6=do
z0#jvn_wGGG_>9hYXb`?5+8;_R@DGHOvA9EgbIxEntsOK8dak>`9GK8!iTb9IaAaV?
zc9<gAZU;?;E69H9AP<wnXaa|AT4~sNv8(>BzE+9eIvd;j+F;OliydsH1@3FW@q(U4
z7}LDLj2nhLMRO<3WO7Le(b3YPz_@mS*0I6Cz9IOcIdGMmyIWv5o3|>LUXjP8?@kOl
zX&zd3cKKWUUH<lFKhVkBvVX`)3xJn773;tpC?F~sgT?9W>VRMCkx&FK9+uJ`5A6=X
z=T^Zyr(Pl+=t~jDg#f^aT%A;l5mL=k)M9eRqT;(GtXRr4KetJre@ACPM}mDl0dad3
zW*7gZ!(nZHd%{ETeP_Wd<pE%F1ne|>wj!?X9u7vGw32CZqAQe)ALt78hr&RFsdfUB
z-4u@n2l|7Fq}d#%dwM2-W{H<Ym_h#jJ)!=+n?mB75rtN^n(}1o5sZE^bZK(UlI;+y
z?oC_8-Me9x78g^gc)rtjI~##V+DGXySqXFqiqVwg**1~i1?$$rv{a+#8yZO@eY--w
zVA2-}VS>KK&Va8qv@aC#o#U$vV>J*84)|h&KBsuMA}|->Ac$3&8=Wu7d1PR+#!Xvj
zs|?&K<OodMuw5E<K#P_*={$%^GNz{miL1=*3E17#BVD$^nB>C>4t*2#x~P$MfLP<O
z!a?UFvf3R=X4*G6a*UbXC&vr|iFeRDU339m2*FB22}B2DOlRl83N#oWs&oU$izw)V
z``*QLmcgunSSaC(#*)50!F?g$ur|fM@eBdj#E`$$6O1&W8HbEJl*C?|Wb)=fF@+ed
zpg$7FV(tb`23&ZhoNl?qLlmSG#$5PjkWe(rO;KU-1q5PFud~F>&C62}ypt|57?=vH
zHTBOqed=fQ1OpP36b6jIgk<ZOgZ4AcO+O7pBB9;ENOuxzbc-K609|ez9*%_jRlMj+
zF>oL>h+xi_o(uHrT`syzWOPAuY$P(E_zY3<#SIIU@D0Y|DW*H=-3WUpmLUgS!Bm{;
z4?}xFK6W(rC&T-~$pePiT}4+H)0K3MgRX|7Y>%Z7$Qu8>7DqXf3`go)W4j%61Dsem
zfy>=GXsyUg{`1{*BfZ~6@1qZ3jHrrf#mJ;^Rbx5nLx{Z^K$?$0l=p#_d4S~@oi$4W
zZu%(QEYLp&nNUnp2%Z~E?CB0+JK|Os-6lrx^w(y0fZKV9Z6%$9?!w&D9Cah;n^8<3
zr+Z*GLzj#MBUl$?SSY<avStaW@d>)mMVHbiu>y!HiN9a>eE`alo`6FB|HvYHV8BhE
zru$0hLHZ07Fr4rY4JRROSik_<!}M8s^9WOmm4CrVB(^^^;7g`>n$LEq?UeL1jK%5U
zx4W@%)KqKJWiqWB-xF#sDlTD?Yw|D^X8bW4m1z3-+t|-I0S96V6~e@~6o1e^7>_T&
zuSh70U$!uQlo(b`d-us{+UN(9%mEVG;`s87V)zxMW1={k6((&U8E0maU~Mi5*25rA
z$!vuu71?5`w+0;atc#u#bK***yc$zY9u3NMMH&Pw;Fswu0_Cf)yO)fF;s<i#ARu0y
z%T=Sl>FBj}z^)G<ex1G{Huak@@@ctl#XARmyM+ErWY%hPw9yN~LdBx61K))zskH{K
zUjUO5;mhFRAoNiAAJB^e;3beG%Z{YF{}9p;#@<s9>jpG4!wH37z<3TEe@s6SNG~IJ
zP2*_3chFCvaC?G@c0_P)dR0{IXY_MXTs+7QQVbP$(=X{)((c#!jdoWk5sT~#iF7#V
zx7a5WlueuLrq}6n#q=8e4(N+R4k9db(;u|@{}CqM6eCdOzY$^i!a7O-<9++X$vv5F
z=Fiy2%O{~093WQHEP`fE9gmANEuk30L%0j8bs<=m1JDowrsWnu!soR)O%V}T#}+Z4
zn$-!9pvHRRkf}ab;>=*=0^Knpo6p9ku>{%fcnHL3((5TV+h{Ee2^U}>nL#`njOcY(
zDDGxEv%D+<UG>&yU;t8HmIpGr!$G%1g2`^RN2(ewuFTUiU);(rE|G!U0Ar4hO>Q4T
zY@d^{FYFeNs8LAZ2^OZ~`YX+c^zJufy{dL%d79`iT%Ff6698Y|33M@(=8=Q3v+Kr0
zQp$~uj`1lR$l;&CYD-9)GsYS>dwGV7&)}Kh<nTz+e`zuvWNOZ1j#BWkHt!5#dn+Q5
z#G3J~6wl^4m?h7JKpLCXj79MJe6W>1XGlkCI2Gzfll8`Q+yHx~fQ18a<4hzDCac|6
zMAW&|F*@ZU*&G`hjzw`aA-)1+Sj3AF$#NyU<DgY=99)d}ERCKKP&USQj|`!AI;P|r
z-~+Fol1(Sqxww{g$QlUdepY33uC!SeV!Rv;`78ufVc4-<viTvaUvG}$n0??u(!2IB
ziD5%ywxzc6-Mm^WR0DJ-7Ttuyt9a~yo6e!t#SrjyFtzE%BI2gQbn*rOOhY&A7#w^q
ziBsZfw!-q+&5hh7^lS#4%rUeY`I+9vF%M&>#tTECb_R0BgAqvc$HI^;Zfpu7(z9_Z
z*3~9?eCjBp0dvJJLu$r8b*!dhd$G<3LP;mLyJ=8`tK6xBta0{@a}aWHmy5eayQicP
zQ~MAO#%kDs^@5I27Uod}tB|NZ5YArS;o|L#GpCYhXn#N*1@?#Bd;$GRp1%WIU+J|;
zzdDfg$reEn`*CWIfU*8{*7>$2gv(C82uQ%N2oi4Ig*6<2^h2I}17V0jGIF5KDJ#@j
zrftepL2PToHamFtX&!-b*u{H91xgSeH)A2TI~G6S<_H%5yocegrdiEwS_We<z@~FC
zWsB*`(~-b&jEBZNPZXPK58HMwW*rH|Co*i8a9o5N?x)<Mo+;6TSF}T(F1sw{u9am|
z++15FezermO*2_S2!k{*mxGGLh)Gh2<zoQ=rL@8%kb<VAtEM}YObWx3dqTb_c&%4*
zdBh$I4<{dlkpR}_W|?fdXujx8y}*FlUCI^-)4^NC)^PB8-H*Lg%jU2$|Kr2Rev`9Z
z3}v{AuNL=w4L19od>xPmqUKIizD)%Ssm;hE_mP{g=Nn3J>ifQeE3icj762-oheV^f
ztpkW_`2+kx>F^<V476=b?XHTc&tY4NOz8L#zDXwVQE(5ve8wh?uYV7MBdh`k<FO&I
z154yWSrIz<R&1oMfu(|BQtZ?^p}FG2K`Y-53y5TcU_6swZoZSRl##IhwGU&19`c&I
z?~_YnECH-T2;*I`$iQ}UGsy)Tl)7<;vE6E(98Wy;^WA)fM(BRf7wfp)$vtj9L@#26
z%~(B`Dhn^L(h|2}d{XAJC65fc`P2Lvp}|AItvk3+dpT^C`><{iS7cJ($)5$mLpZvS
z#aM2<kV7Wpm;(a&C?6I<I08{b1Z9dMLbbH<Hv}*D$=e#}7(Z4*ZXN~oFp!c?&?jdU
zOTcGZjR~+H;}Zh(aR9}J<xn{3=FiF6$<3b!OThO`p+YkulC0CJa-@9RVPGgz%#{>_
z4&#^sj%$1dpD!x}7iQWNi$S`vjhSz@=f5oyeu<x!sXYUgO4+wi+(btXA`&==m{^Xt
zxcNDLUWDq)@K6@=AHb&kkb}Ppy7iC5aT=DClaRJ>BqB%8SPi4+*ZCVR{u*PQz0fqz
zTG^~*@xgT`M-slEtS`PT*kG2HfmGIw83$q$pT8rqBNpKf-$)c&e&~f&xLzbDE{W6&
z8UQ&o?BE|j$}6|XY5FF9$;B`7|IIoyFgL#@9PdXm-j6XJxYHVoA`-~Qnk{dOH81lk
z!WyjN3lV_>B%cqb7)h~Yawy|~3BJ{8dQ28VV!+sx#N@Ny=VL35f6c!UrTs08a3BHW
zYML;y3kh`uhW$-`-TtQWM@LM0uK9p&5$67p-w>c!>zB$Dd<tWjbV(L-G8XtVEm~k=
zoEEwXbO9Vg{A3s_$whGU-{e^8O8z_2wbG)|CHx<<Y<2TLAwCiuCQ}>N=J|w#1cKL_
zF8-Ga&x{v(x2z)VaE$X#z4vRw>YNAMHoFRqZABnBCS@$)C)DQvq|WBF6+?4uE`v{c
z<qzT-V}Pq*UydDN%IDcn$Iz{D+a}wlAX>9cmE4gQId4K>ej4c@rrnDp%=(|DgE+gB
zm}gsX7|}##0tvF8jFge$?(ps?ls=BQ`@HdOqSi`tKQ`}XWRBvh<4j9R3f8HCXfza8
zp<*bJ%21hv42yE)l(4M=A&`xx(+oVBk-DFS>)Dq3xw!UO?&stBOw0X3TrZ-<ss5F?
zUt)P*jq4iAeI2grE%(cCz1(uY0@r6-?pGm)14~)p>XL;XetWTlxrWwa#Ob(u75tXW
zo0cQAVeQPR&im-hlhnBLBsC*9WV0tQN^LVosngSii&5HsoOYh78l}Fr8qfTKQR?qK
zM3dX4gC``f4kIY6M+S@JtQ6SJ0Ng4-UxTp+X*c0u9=RxcD2(5Q)I=A{ywQF-?WG9h
z-HYdofF03JygwhkE<pba(c&V&901fHVC_NzYRD!tSptYvWOHDZfx8AOkShlO;D-aP
zQul;sL*|qV4gz=y!q;UokyiW|ZZoD^gGqYgdZz8wwWU*Ol=fkYzJ|h+bXkfhm!n0k
zNsoi4s%z|^L_?vpvs>G}2W<qTqT9h!-oj&aZG+uwe};;^_9yP3Io8J4XEyfCvX9XR
zZ>PncStc(&Y_#y)gbM%wTL5{CZs|Qqw}D%?Hxzm84Gyp4iIvWRmBr=7<=|$O*HK=)
zyuszU)9X4$_m0x1Zl|f<BDpzqf*!I_?={7I=*{nXi%!s^Ot;e{LCSOFI2}Ay<t_3Y
z8>2D#{WyLfhP=-K&#FM(&B)N|!tX-G<!g|YRYNlsmkX)KxU$o4A#o?^bKvCnXeE7~
zu11fSpi55xij#hX+^AEy0>^ooAs2S8QPKd@$BXF;=#MeEjJ}Ag0*v_zJxNc2f%^a#
zhkazHZ&M$AiJqY%+e}D-<S^+cPveP5)Wu5buSCnMfXCIC!F3q(M$F=R;CusS@*%*z
z8MFBaFu#dn^f5rcg|4Jq=`Om1?x#EHc^rp*8#z$FrF-eGbRQStT+B`Pa|J!XK6;QV
zageo?9u}$OIS?*LJ!BE0=%7pSzZS^NSq~+}Do?W**{yvYK!otODC?mE(;y(2|M~Od
zJpU27a^X1WHb7%25hhkL{(A?`0}1n<7=&-)_uv7J!l3Q2KDP6~Nf)N^lBi<4sG?}v
zb31E})AOP!-ojD(T5qk_KGio$--3KYO1~pgnxQ)1%da}sY1R3@Xbk!yjuT_{qjU#R
zA9?c%lc>%K`h|dRldIn_<nOfxr`LImeh+nND6aMvpP)Bv5Q-&M)%}w|FUAkg|C1kg
z;)kK~hu(bTFs7%KWDrw*0K$*cQHcCqFl8s{FHnQ)Aa<u9R>*IMa%l4?S0dD6*j}Q)
zDK)S|iT(~lSpWh1rc#YUxT0t1AM{TM_hLE*0e{m_g9@mPhVe9D=y(4z6k<J1!Mnrg
za|Do%0>&}8tjEymIItU|R^YV_N_!Av+y%vZ04jGFO7{XiOE1!M%Jklb-mT<Nvhtu3
zaxLo5IdJww=sNDJ>&Th6mjee(gfX;mWy8c<2fZe$M8IJJ2)0>hVYAJavwTRjc5*GC
zhS0-RHO7Ti)nn`suGp06(v)(g=<Z@C!-FW(F<H5+A3#W71jk;Y>*ajKfcY#ERmE}k
z1Kgyxl&F>Q6tG_;8NbT76h93YpbhnNJIlBX(%oL`nXhEKjLWMEMCOlkMZp-)8f9N^
zZ5hw68Rdn&RkfqMq&JPMcvB3SLbhKc3uau%RZ2)!!KR5o6sQTzhj<a}tR2UKHS{vP
z=qt3Ieu}K4SCRDdbNJF<U{W~CF(&mq;ER{uQ1uKstKgz0pX6F#Tz{OGo)SM)Rj~Xx
zFKaDaH>>K2`>3LND$ra}HETJh*?Wx*j^x+X5dB91Lc4z-z|A8spAG2}4s1{e6OwFw
zypmTLbe^MR|JR`LZ%|qC8s5H+_P;}F?CWsre^3%v2h_x~b2Y$BGcV@B$#b;>3oSgA
z2q1M+%;%UMADRZPp+T|Y{}``HQ&i`?7Hf)HnEnq8_fJsoUr3~1n*ub5NeG~sM|k}+
zG~F|+j5i8jt8hQcoA@ZN7tng{8uUyH=n61`*hxi@uqo`K3J`t<Pg3&(3&22zZUBIj
zaVTN%<f9NYA>CGsjJ2d?EENKXWStAiYOU6iRh>_=s;V;uN=yG%L!c@Vnu_pf>7Rjt
ziKn8_p_D4wgB1TVtcT07lCHpgz(kNghFOVNJ_;f{OAj64wr9yJr0E#r^LkHmH$=M!
zlsQD*csIu9w*rZGeu2Byvkg|=>BGFx20zO<sD5^j@_@P+#7~)P21wDf)|0#kQ@{8)
z?`^9A<fsuZK@iiyoS-voa;l~l+e1mH6%MWFEaX#eH7xXc%y<=~WspZe@+A~N-VU5M
z?ML;%0pSiTY%O2L@50+VA%w`0QR?!j!DBN3(LMJYbZkLhB=Ib8eKwZvbE%wtG@lnh
zuofc!vj*cYqE!fX_CU1bT!-YWdb$b$(R=wUx|3JXr=UHL@G2!GOF-%Qrj)GI7to2V
z6gM9}VqQ4;a_Ti?=sch)ay!=|L+=KCKtDxP5#giUmaP_Z`8}8+rPYGhL0;D*AlpF2
zvQKG%{{z5F*6<+o>srVkMDM*P_{IWitM=5D@%vBkhYM&uUf#U2a5nDmp>?y%3-6&-
z7Iba_Dzo97%lI~2mBaDl@(v4rWBl=6z-_BZTbC7jR6~006y&>E64gtQPkApex52Lk
z_!F=t1(57!z7JQ0YBp+_!CS}<(v@;MWV{2VIGsr7Jr8S$Zn}tjXn?mXnwJ6MfDx2U
zh6|EF3Df^1f6AEtHZ+iDQ!&E_M)|?J$x(QS3JV^>Gpi|>YB2>x(t|Hl1C#^N$tK&T
z7)-^sj%-aELo7!V8Nyiw5{&V~LIdr;w3Tt@fZl`t*w!`rzW@qAo9P1K5EgGK4z+8p
zSQzn$Nq)n!)SQ4>BZ<a5)zv5Xcmeg|vaY=F1fNvbC-@1b-r6)uqDC0XV2fOdZ^HgM
zZC4Dkfk9jNlv1AQ$ZxF`w!nJN<1g?R$!=j#91Kc;K}i&Fji69yA2slP@<S=lgF^1)
z%fN>x`6*+PKgPJ?@A~y572fc(%VwV7XMri6eq~kR7=NpxFu1D7GUNZkjAxGW_sUq}
z#FPBu&WfVr{KHZHi9v!|&x(qo6a2G6OjFM`ttoo4R+s!L|6EP>LSwRS>QxgfK&i=Q
z{slG<3TXj6;V*Hemnd2qu|(mkU?HxCU$~ZL@pZ^?e=l|N4Uow9A(Qq-O!ikPq5CN&
zYt^}B1t<8m0$OL8*Y7YJ#1jaQ)hcn;?bJ~1Suu@&e}eyn^*1On@8-K{k)?;kuQLC6
z8PhL#XjWR3B?MVb)e3tF6$W#(Zwlu7NzlNupyyjLx7*<JZim&o12*(7TFrN(_~{<Z
z>t1NuCzT>V_MvIAY<FOX5WtIN6WQRd><NgQDHHC($gG-1)73;8eGlWY)&_|;&?JS^
z<dj9QDavb{R9wfO1x}AZxDI2Ozwlp;VGdvrq3b*urXB1S;V<+SdREQV65xg4i@>Kv
zKu2ZsQu01e4JGnEOATLu)$ueX0^0cKFyL_ve-ecqpQAJQ^W@_vu;Rt3mx0E|fQESe
zdYI@wadWcU(pr6t|M3tU-oMPfh%y@%G;Q#DBC5x2P%0r?DR~f4r6aIOP%0ZDcpQO2
z24yQoTGeZWmAZL^wEQ&Cc^2g&&runFS#bnr39wkA68w;&7o;B<DE5NZ0%u`bfNU_^
zX7DRgXLIycm6nW+*-FyX(gtgxWpK@o@4*Pa0FnPbIc@F~9Re6c=um2KeJ;Q$cOnvL
zjo?dDJa=oJt9fA?74v!-q<#fpv9D_2z7JqUnC1xBHf`cyD(1peh*8VYa?Rp7DHhMM
zO@h%97JE}#?$KJV#?>tT9mf4VH2M$F=s#k5Z-B)(nKf`&ZqUzJ<ylxTYAa0}(D7{g
zpD`O$K^Xll#auRz?7<zkm8oJbwXV@H+_q`9a>IjbTKts?u`6z~%@O)RF6QF5L@}~&
zCdrL%xS}aVQp-_>2&Xu+*z2M04IfAC4awhS=!nCx)6MtDEc&9z+sqb`#avFIRBlp<
z6l;5Nnx6B<s0y2)plMpZZmJa9J!B>h;4})Z9!D-&MVD@x<bpiGW*K|tZ?_%?nMcML
zOe-eX+0H)u$N45s(A4Jj_@y*RqbnEON>YR1L_<oV|Luwx?05^znb@n(kC6k?PLg!c
zsIp&iVqxa1sw@xVsMjs)Ko@r8<{{cKOJ&>$)$p)fD!fv~Y&r{9a`YF00sF9}k>^Y|
z&!#?7Yb$Aq3%Xi`eJd(KqLUOnTMi`6D*rm50DRScKkQ@%y6PcvYnRe87tH4JJUL6W
zLLYvqbRk+PGdLSjy>%o#X$L&tTc^}xgI@OQ*Xit`ada$o_~Jk`F=3WVM&`ajd^z51
zBqX41l-2Y2wMBlMje#)G4lQg(CZVE<&Y?j)RkjqQQaN&Y;>M2axnhd~T2*}+V0Dg}
z$fxl&f^p{F6iguFScKoe$3bmyRq>Iiei~4R=c<OSWqkB<@YbF4BtHqYI;hiy(pc1W
zA-NWLKM5QdB1Nw<kUPl~U{#|jxl)qwr>nheQtjm!I$(&}>6Iy+PPVc&Gsy>*Z3+zr
zfno-kQfzb6J2e}S^=7I1((-$e$ZreQQ+W&a`=Kgp`y)o#`TyFnpXKz8=0QHhKilA&
zbV2x_x)UD-HO93a-WO&UKX>D<9=|0Pv7@kgii$Phs?CaKJ8HyBaVO_aYTbqKTS6pR
z*hy#E>yg3sdWug{IZje4JZFs3EbQB1i*D8^EgYlj-Xm0d2hA-!O0|f_&Kjk25H8s8
zYn0aCL5|un+JwCo+R~ne(TdKsX#mwVXw+3@V@6~oC>AIbWer;g1bZc76C?~|<!T4*
zRI}Pk=OX|U-@h2!cG6C!Qm5!pjfk!mdjfShI;+Rer7#=Iu*tUqt<MIJS7E#G92|nI
z#$SmHkz6JbHcri29I(7{5(j-WD6ty9CEBuAk5QkBM-+~Fm&hce&|YJfCg=t_L*&T-
za~^;Q7_UK2P;3_n;lWOhkh8Tq8?;veB%B1=)C5^gPz5Z&ZaM|9t_!7@JsZQwAA13~
zA(Yh3HESg*+lyy8h3X%D>D51-v4}|iE<=L}VwY^&k{P@3eG|tn*}WYSyJV!WXJ{nY
zX~Znq9gUd9XBt<@DMt-d+$?<T4ekx$sC=&jTT5vJp4Cbfsyof5$gml|q+3Nm*+@90
z_T1guxYgg<(Y&>9s~-ur4mbl;jW;=^;Ji4I20q_v_wwS3Jb^+11Y2#fnnpeilWWLQ
zjgY@=!I?m&hNN*r<KaRai7wD5h74H)pb8cAGYmGlt#L<Rlcg}--qW$w-;Q9&{5Xob
zvnOMFL#VBun-$u@fp0p19FTB-3NQ7|7Be$gC3~kcOH9{lnOZ8;SxAdSpcmuw0C{4U
ze03La81p1}u}Q`H=>(S9yu<t}@>X;pPv*2sJ@CPcdck3-a(nVQ9aSnaUPv*I&XQ1g
zg&VsY(<R(m3EV+Jq-=~Ip{|yh&X<S>D9gu|GBl*tDS^<x9jtDkjRLt5@&ZWBZkQ^s
zASQv$#P!@8<Xb8YQahfCPREU8Rgrju6p5E><W+_g0uYr|ECCIKE>Aq$`F7*kF6wsC
zdGb*!r&&gEx=~^;FhE?;Vy)e9!^eQXJEVp@v#JAXkH#svXQ~@NkXn*Qeov>yxR1#w
z20@Z;s<Hs-Wk||QB;zCfNTPH~DfvYbV2>Z94!{toJkGZ&_r^l2O@CJD-(F~yN|lKE
z+>!wad5aTdr6HpW`vmHvOR!OD2^K?+n$!jP<%3ZZ(lytRECHV!syst-jvcY+zXb#+
zxdjz7qYs8M7ERZnga8^3be6vsXXNGOvR}Va%TG%^x&F*gODsMVwAB94KBxu+3hCTt
zNx88~5YV|<kmeG?jYHo9Vt_82V6}O<b+zfHcgq(W4$^zHqt5>RSnfC1^v61!$P~=C
zV7vM>7HrqjbuPLFXEy0|Sk4}V*qfAtRMLuyEpwW(Jh*}0Cz^O8<OF%{STvX`JgFdc
z(+4Olbok)gC?WnZ_-uR=%=nDhO*-7yZb?<Lxsm(=*K|+{&hvao>{i%?tWSm^mtI$<
zN2F9ygaDt@ap15D<#EBdT9|>?dAyvIx_+GQb|J6e9{53H%VWT2e2mOzpsFfB!-K|$
z2gG)M!j15Cugw0FOv~UPq%>(H9!1`0IJz$w5#y06#LtE%0PcsG#kUx61}Vl9iS+YR
zgO5b_Mq~St(K;OJ4+kSA64L9_ZrSmZVIMlpIv)D08;4GA@h^{}v@|t{iKU7&1oRO%
zw%5v~-7&YUMdWG}jPHVJ391sL{Rr<O2=AOU21Spn=a|Cd;wT+-GDB3&U5wA;5Lv=8
z=?4-SpBqv&wIh*;lTKySf%WW($M%aMa?lqcDArWriDeaK`cKi9L{^^$%3+DdP==be
zA8vY9i}G`_%)C$tC~4qkL(}fO{c2b@eU-i@<9=NV;?sdwUXz1ZqA1ZLU%NxNXNXo0
zvPmVDFt(*mXIcH9+*E*P7?zOUN#6&3#NDd=_*AtfN(s}G%oAN2fwLP4DlfUPL_&g-
zRKKMo@>ThEC(_0?Yq7Av?1;^-AJLCxKlmqLaAW@^BVqZ7r7ta$NSJa2)pN+?&$LXw
z3L(PINNSIP$v?iq%QrD|rDGaL!@szZrt(X%P`{D^{<q3mk!<o?q1kIjL3sKrF<DfB
z99g$kro@%o)b%&&BaVLr8<k5|CG1(>iTpFF7;>$-)K*%nczo+%6aIn)P>rs=RQG>_
zovlH&f^I6s59;whV9W3cjelud_9keOSs~6!_t=KsYM;tFjw(XPCbQ{-^06dG{M=l~
zcBmj1xsi2n33MAdJ$Y-Z-fk_NTUV9uV7Gj}MnRs8cw1WwO>VO=RaKOa^Ib^xxRLD}
z6~v~2pirt*;{8Pa7e!|kJY6Psh8w$1GhvW<hG}Fii%JL2g6PZl5+I#e+h7TSu5);<
z3q{vH><4z^gFpi#*dCKw;WX{VW5o~D_{>59Fr4Q@^n8_0DbvOmqgZ)i#JQFt^Z#)n
z_!6#y=5Te^7DQGReJzAY2xWdM>_1XPU(ZWjT*u3xEx|}IKID{2?$p=pP-s@)D36Wp
z4F{iX3HYFr+B7zcYjZHR)~BGjemD_A?Nu-$^&DpP&}wdQ@i`2wEr9rAfl(RQk_x+I
zl#IE{zAUff^)BS2ZE#~VP1c6o2*E*TLvY;OEWyVPWO&hRd@)e7QW!iK#OEtfyMoWE
zsE;H$xy4PxT6VE)%vTyV$q)cl_JpMa?DeI|#w4nuhJkE}k`itAV0qPD2EGWECzuT6
zDTu9*85vEiR0UP+3MeEFD~X&U#u>UY8Wv$Nyn94X$}kUk%Ti%^B!o>j&QlU>nimVR
z!A@10mHKoc%D2;BljEJ>0`Cw6bI$y726RYi_kvh_cYQy?nW6B=P`&yvfF9u7SZr^i
zQGX}eAr;=m_}oxbVje7U)CY%9=pA%%AMbLb?tDA;E*NhnID<<&&wk^}lIHvbz@UKI
zt=8tro;@LvO0f`-u`pjO!1v+`!h}}flR6<wK+qru3-YXiWU`I&-p~mYQpR{#z+5un
z7m0Fl%nK<YXh7)X;LAXE@i<s?;Uh2dxz@x2)ewm6<NbojrA!;gck=lW$p`E*!R1}r
z45i+K|8Ip4FgeKY7EG|(YxuV@QDCkV9IgUA%+n2+blH)bt(>6p0pPh&wx|jQx8c*f
z4k@s9bo-k-+BbD$(?fgF@mgabR8bf6d-;8mW`aMHr((op%q)SF%0raNeULxoLL)5T
zoMIrPs18{XV%la)RkZ#9ky?MrD~FUqPfo^~!qH&-fDRO835M#zJP!O;zRktANJ;d6
z;_wDMw3bd4&O`Js$15(B9-(*<yWw}@PEy`xAQL@(Uy2rTC?oj@SQ_ECNA?g^Px)}K
zJcnOazhS1;Z!ERc?>QDYKJ+al>?dNRyYO~3&P(LLprp#PU<{e7$EjKl4Qz~R2I(fR
zkR4r%bA-EbEsGVYKyu;G<r;vgGr%+fjJ$Cnft;3AXFxHN$Q2X?V>u9K3%rXEN(a#&
z8@dKOIV6z-pOPxTI=iaoF<O;IOXo2eXh|cS;h3ljXqy79^V5-=h$vP{tX$ZuU1Wg2
z+(38ZNov56)>_Z{QEI|LOp|95ejK5e!i#nuB_t9{iC3#<ve~QyZ*h>-gr{S)tydq_
zC{pQ3Zlvvs<_p0Ig_8x7Fvh<a=SzDPCODH*^lt)*HQ~nSf>sc(QXT(TV7gGkCVaNz
zzjr83rWt{97&z2ISw<T02923jR2`#L&q~44MLRvaj#K|Bc_6S0EU+syYw@%~XFgf*
zy&UW4gE$j=5Ax8UhrqK`4#x0*2<Kvjvi8UGLfLvS#@-;%@fS&BrUYqLp&(u)NM5B9
ztQf@_UV~NoaOx%iLuhIM+laOT%vPw9nH16*nk@y*mV#zOWs*As+9!Y_Vhx2VB60N_
zaWf#6Qj$jWD0a#Hg_7`LF#lah6{9O~a(UG#U5`SrnlXBRRSo3tLx*@#t>+`^>8;hC
zkB-tUlJxcrU5U&$B;=y;`PCkz<KChR*tU4>V|4GzqO{!H2bn1^(&8k7Q&l5(pE^Wy
z8!W9JKr64^6t4$STem0;;xqCR8Dv`a<Yh6C8>NR2(G9g8<fQ_OE2=#{h1?N3EN!p9
zgSyfXj%GnPLXYiius?Z(jz2@wJd-^q1T)-?(&r9Q2_Af5j2=Wf>r=Qx`H%f6ujABV
z5apTMu@D=h=MN#L7stR~X|UJGgufy1+TIFW4WPLioHb8*ou>}b+J<6<h3l=ld0h&N
z68!d-obnc<n9_w$agSj8b3gqJiw<OJ;WJSS)b9Xa%tN>zLLh+O`11x5V~H#AF(LVV
z1r90i$M5@*11!Jy^8tBoXogsd9+)B#&mw%ca|ZUszKN@IQPcA+2#XyDq&J}8%?+=*
z4$nn9?fClL2=aCC3|VdKl~~%4&$b!`KW-6YsDz;cxcUx#7vd*c{3K4KiN1*bPh!-k
zVBfz4Xit+5l}k(Td9P*kWm-vJp^eztITvHJ0h1nJ5e3{4)B{}#SeF6X&G<&%t*F5{
zhEkTt>1FhO1+9OIr$47RP)GGQ(1_^osIK@2m(rW;W#&qJvaTL=Tr080Uq`PaivJ4-
z(5?gRdeQD8wA+JrNvxIk<J}c_cOBk+5btiqyL<5NQG96)*1_h&v5`;e^<W(i!az9S
z90=GIS)bscJZF4i6$s~hMVN#=s|(;9%l8l&qPZ<UpN#`%n>)}G;0Jh{)!jkzd~V+7
z!1+mDoc9&PDi0>0YA$*paTbX{<kXWV6w!E3&Xb|6CkmNl)<a0KVVw^Og`WhAP^>8I
z00HF>p6MChGv15)^S@Bg9?t)c_|a@U$cak47qodrSDjhEMYOzKlpNJBRh}P=(ht8t
z#bQJYJ*WbE`6wN)eM$_2z4j@u{S<7^PgBO|=hb3me%&h>B(Ec}*an?jK#MV@#rWq0
z<hS-{RnWcZhy{K}zsD8P7Nv!_z?ITCb@d16qmB=%pmD^Lksg3J3vx0Y6+H8~g6eoW
zj%ClFwUCi!o`FoPnaTsM!CdCcY$4r{amX^{1><KvVbB>-QRYKvh@4Moq7*=mfCTa8
z8qXWB*6lSO)JVdk)JTOSTu9nt{}mP+Nit2IzniAp^G~@leS}mNz;>g^uAsUWg?pe8
zYT}9yOBHpwdW!P9hN7x!Z_y}EIh+ElO7GI%1Yl5iryR!Z^blGXj&k|RqVl5K=_Ww&
zu5^?;?2#ipv)nPt^DbKHv;aC2_>?>0*~)mKTsqX{Vq8j$1jr}p;7-pY$GNhh*jw!J
z!846=O>cF9w-^O|sJ%w9#R?GzUfEFMEh!q~wdKxhgI?DtZ!C8l;imhjq#DET8Dsw;
za(gD1@n!)FVbO>NB-qdrAcfXa*|7!WEy721uj8$-;SM^1s-ad~IUyMvxefNRnC-~Y
zZ-=dOf%9|mdA9Q)Irq@VxeN6zDA3@|DSN%y3^MRc<j6)2-iQhqvFlU#9QtouLGn=I
z{AXO*m0iCM{zHnL9k3@;*oU|CP#v}qhvkcK2)>xQU^I5{5)^6FqByZ0dHzdL;j|o|
z!9I(Ic@+-1R?{uqfODWVsBl_KpN54#fx4nsxsiSkGxB$Aw%ECaOZi;(;p23b+{R0}
z16xL&ycToVz&&`oUCHejD6rEoT`AFp^ooTZ&i@?PxRvq9Xb*cYlFxMxST_Qujy!Gf
zV(oY@HjFb`OaA9j7wkD`rNKYJqO+#v9^nh7mfi<CKRU+!cOVF=KF*;>)z2~BBLOa}
zX-k0<Rx5%czY|Xppr@``_8SbqOAWvt1KiBx964MybBv=RSQ?frE?_p$A6^vCu+3of
zuEiU9HdXa@RvqW~qsW>cN#h}<i};Jasw*}I#_f7Qx?VnRSFGg6?RtfDy?UIkPQE6!
z-rFY82>u{H?<hTn9I=*@JR3EL*B)imZQeMI-#^M9x&A0OLET6B<}tqGC>_?6kbp&{
z?qd;S$0sR^k!)W^o8kDu9KIKCkygf^z;74ktW)N>b1U1X6^#Gyq@lI?^C_WX-hVYM
z8$$L!d8Ydl^h9E~@e|ju5rxx{)IWfh4L19qYDt5wKtBKYV9gD9;~#Fx2Af?JkOo_@
tej>1`&1U0}bR6*6d3$N_r&=ZipPdb*v-mo<+F|_kTJy8u$RZU!|9_fs90dRX

diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 85b4127..32c406d 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -52,10 +52,6 @@ by a child template that "extends" this file.
     <uses-permission android:name="android.permission.WAKE_LOCK"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS"/>
-    <!-- Indicates use of Android's VR-mode, available only on Android N+. -->
-    <uses-feature android:name="android.software.vr.mode" android:required="false"/>
-    <!-- Indicates use of VR features that are available only on Daydream-ready devices. -->
-    <uses-feature android:name="android.hardware.vr.high_performance" android:required="false"/>
     <!--
       Indicates that we don't need Chrome to be available on devices that only support landscape
       orientation. This is needed because we have VR specific activities that declare the
@@ -66,22 +62,16 @@ by a child template that "extends" this file.
     <permission android:name="org.chromium.chrome.permission.CHILD_SERVICE" android:protectionLevel="signature" />
     <permission android:name="org.chromium.chrome.permission.READ_WRITE_BOOKMARK_FOLDERS" android:protectionLevel="signatureOrSystem" />
     <permission android:name="org.chromium.chrome.TOS_ACKED" android:protectionLevel="signatureOrSystem" />
-    <!-- Only chrome can receive the messages and registration result -->
-    <permission android:name="org.chromium.chrome.permission.C2D_MESSAGE"
-        android:protectionLevel="signature" />
     <permission android:name="org.chromium.chrome.permission.DEBUG"
                 android:label="Debug web pages"
                 android:permissionGroup="android.permission-group.DEVELOPMENT_TOOLS"
                 android:protectionLevel="signature" />
-
-    <uses-permission android:name="org.chromium.chrome.permission.C2D_MESSAGE" />
     <uses-permission android:name="org.chromium.chrome.permission.READ_WRITE_BOOKMARK_FOLDERS" />
     <uses-permission android:name="org.chromium.chrome.TOS_ACKED" />
 
     <uses-permission android:name="com.chrome.permission.DEVICE_EXTRAS" />
     <uses-permission android:name="com.android.browser.permission.READ_HISTORY_BOOKMARKS"/>
     <uses-permission android:name="com.android.browser.permission.WRITE_HISTORY_BOOKMARKS"/>
-    <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
     <uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT"/>
 
     <uses-permission android:name="com.google.android.apps.now.CURRENT_ACCOUNT_ACCESS" />
@@ -110,7 +100,6 @@ by a child template that "extends" this file.
         android:roundIcon="@drawable/ic_launcher_round"
         android:label="@string/app_name"
         android:largeHeap="false"
-        android:manageSpaceActivity="@string/manage_space_activity"
         android:supportsRtl="true"
         android:allowBackup="false"
         android:networkSecurityConfig="@xml/network_security_config"
@@ -564,70 +553,6 @@ by a child template that "extends" this file.
                 <category android:name="com.google.intent.category.CARDBOARD" />
             </intent-filter>
 
-        </activity>
-        <activity android:name="org.chromium.chrome.browser.vr.VrMainActivity"
-            android:theme="@style/VrSupportThemeLauncher"
-            android:exported="true"
-            android:enableVrMode="@string/gvr_vr_mode_component"
-            android:taskAffinity=""
-            android:relinquishTaskIdentity="true"
-            android:excludeFromRecents="true"
-            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|mcc|mnc|screenLayout|smallestScreenSize|uiMode|density">
-            <!-- TODO(mthiesse, b/72214458): This is a duplication of the icon metadata below.
-                 Daydream will actually ignore the metadata here, and use the metadata on the
-                 activity-alias. However, play store apk validation fails to find the icons on the
-                 alias, so we need to include them here to pass validation. -->
-            <meta-data android:name="com.google.android.vr.icon"
-                android:resource="@drawable/daydream_icon_foreground" />
-            <meta-data android:name="com.google.android.vr.icon_background"
-                android:resource="@drawable/daydream_icon_background" />
-                        <intent-filter>
-                <action android:name="org.chromium.chrome.browser.dummy.action" />
-                <category android:name="com.google.intent.category.DAYDREAM" />
-                <category android:name="com.google.intent.category.CARDBOARD" />
-            </intent-filter>
-
-        </activity>
-        <!-- This alias allows us to dynamically toggle whether the Chrome icon shows up in Daydream
-             home. It starts off disabled and is enabled dynamically via a feature flag when Chrome
-             is started. -->
-        <activity-alias android:name="com.google.android.apps.chrome.VrIntentDispatcher"
-            android:targetActivity="org.chromium.chrome.browser.vr.VrMainActivity"
-            android:enabled="false"
-            android:exported="true">
-            <!-- These icons are placeholders, and only show up behind a flag that's disabled by
-                 default. -->
-            <meta-data android:name="com.google.android.vr.icon"
-                android:resource="@drawable/daydream_icon_foreground" />
-            <meta-data android:name="com.google.android.vr.icon_background"
-                android:resource="@drawable/daydream_icon_background" />
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <!-- Show icon in Daydream app launcher. -->
-                <category android:name="com.google.intent.category.DAYDREAM" />
-            </intent-filter>
-        </activity-alias>
-        <activity android:name="org.chromium.chrome.browser.vr.CustomTabVrActivity"
-            android:theme="@style/VrSupportTheme"
-            android:screenOrientation="landscape"
-            android:enableVrMode="@string/gvr_vr_mode_component"
-            android:taskAffinity=""
-            android:persistableMode="persistNever"
-            android:autoRemoveFromRecents="false"
-                        android:windowSoftInputMode="adjustResize"
-            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|mcc|mnc|screenLayout|smallestScreenSize|uiMode|density"
-            android:hardwareAccelerated="false"
-
-                        android:supportsPictureInPicture="true"
-            android:resizeableActivity="true"
-
-        >
-                        <intent-filter>
-                <action android:name="org.chromium.chrome.browser.dummy.action" />
-                <category android:name="com.google.intent.category.DAYDREAM" />
-                <category android:name="com.google.intent.category.CARDBOARD" />
-            </intent-filter>
-
         </activity>
 
         <!-- ChromeTabbedActivity related -->
@@ -746,20 +671,6 @@ by a child template that "extends" this file.
             android:windowSoftInputMode="stateHidden|adjustPan"
             android:configChanges="orientation|keyboardHidden|keyboard|screenSize|mcc|mnc|screenLayout|smallestScreenSize"
 >
-        </activity>
-        <activity android:name="org.chromium.chrome.browser.vr_shell.VrFirstRunActivity"
-            android:exported="false"
-            android:launchMode="singleInstance"
-            android:theme="@style/VrActivityTheme"
-            android:excludeFromRecents="true"
-            android:enableVrMode="@string/gvr_vr_mode_component"
-            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|mcc|mnc|screenLayout|smallestScreenSize|uiMode">
-                        <intent-filter>
-                <action android:name="org.chromium.chrome.browser.dummy.action" />
-                <category android:name="com.google.intent.category.DAYDREAM" />
-                <category android:name="com.google.intent.category.CARDBOARD" />
-            </intent-filter>
-
         </activity>
         <activity android:name="org.chromium.chrome.browser.signin.AccountSigninActivity"
             android:theme="@style/DialogWhenLarge"
@@ -1391,16 +1302,6 @@ by a child template that "extends" this file.
 
         </activity>
 
-        <activity android:name="org.chromium.chrome.browser.media.remote.ExpandedControllerActivity"
-            android:theme="@style/MainTheme"
-            android:label="Chrome.ExpandedControllerActivity"
-            android:hardwareAccelerated="true"
-            android:launchMode="singleTask"
-            android:noHistory="true"
-            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|mcc|mnc|screenLayout|smallestScreenSize"
-            android:excludeFromRecents="true">
-        </activity>
-
         <!-- This activity is used to restart the main Chrome process.  Should never be exported. -->
         <activity android:name="org.chromium.chrome.browser.BrowserRestartActivity"
             android:launchMode="singleInstance"
@@ -1437,22 +1338,6 @@ by a child template that "extends" this file.
             android:excludeFromRecents="true">
         </activity>
 
-        <activity
-            android:name="org.chromium.chrome.browser.vr_shell.VrCancelAnimationActivity"
-            android:exported="false"
-            android:theme="@android:style/Theme.NoDisplay"
-            android:noHistory="true"
-            android:excludeFromRecents="true"
-            android:enableVrMode="@string/gvr_vr_mode_component"
-            >
-                        <intent-filter>
-                <action android:name="org.chromium.chrome.browser.dummy.action" />
-                <category android:name="com.google.intent.category.DAYDREAM" />
-                <category android:name="com.google.intent.category.CARDBOARD" />
-            </intent-filter>
-
-        </activity>
-
         <!-- Service for handling Nearby Messages -->
         <service android:name="org.chromium.chrome.browser.physicalweb.NearbyMessageIntentService"
             android:exported="false" />
@@ -1625,43 +1510,6 @@ by a child template that "extends" this file.
             android:configChanges="orientation|keyboardHidden|keyboard|screenSize|mcc|mnc|screenLayout|smallestScreenSize"
             android:hardwareAccelerated="false" />
 
-        <!-- Receiver for GCM messages. -->
-        <receiver android:name="com.google.android.gms.gcm.GcmReceiver"
-            android:exported="true"
-            android:permission="com.google.android.c2dm.permission.SEND">
-            <intent-filter>
-                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
-                <action android:name="com.google.android.c2dm.intent.REGISTRATION" />
-               <category android:name="org.chromium.chrome"/>
-            </intent-filter>
-        </receiver>
-        <!-- GcmTaskService for registration for Invalidations. -->
-        <service android:name="com.google.ipc.invalidation.ticl.android2.channel.GcmRegistrationTaskService"
-            android:exported="true"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE" >
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY"/>
-            </intent-filter>
-        </service>
-        <!-- InstanceIDListenerService for token refresh events from GCM. -->
-        <service android:name="com.google.ipc.invalidation.ticl.android2.channel.AndroidInstanceIDListenerService"
-            android:exported="false">
-            <intent-filter>
-                <action android:name="com.google.android.gms.iid.InstanceID"/>
-            </intent-filter>
-        </service>
-        <!-- GcmListenerService for messages from GCM. -->
-        <service android:name="org.chromium.chrome.browser.services.gcm.ChromeGcmListenerService"
-            android:exported="false" >
-            <intent-filter>
-              <action android:name="com.google.android.c2dm.intent.RECEIVE" />
-            </intent-filter>
-        </service>
-        <meta-data android:name="ipc.invalidation.ticl.gcm_upstream_service_class"
-            android:value="org.chromium.chrome.browser.services.gcm.InvalidationGcmUpstreamSender" />
-        <service android:name="org.chromium.chrome.browser.services.gcm.InvalidationGcmUpstreamSender"
-            android:exported="false"/>
-
         <!-- Notification service for sync. -->
         <meta-data android:name="ipc.invalidation.ticl.listener_service_class"
             android:value="org.chromium.chrome.browser.invalidation.ChromeInvalidationClientService"/>
@@ -1701,24 +1549,6 @@ by a child template that "extends" this file.
             android:exported="false"
             android:permission="android.permission.BIND_JOB_SERVICE"/>
 
-        <!-- Background Task Scheduler GCM task service -->
-        <service android:name="org.chromium.components.background_task_scheduler.BackgroundTaskGcmTaskService"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE"
-            android:exported="true">
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" />
-            </intent-filter>
-        </service>
-
-        <!-- GcmTaskService implementation to wake Chrome on scheduled events -->
-        <service android:name="org.chromium.chrome.browser.ChromeBackgroundService"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE"
-            android:exported="true">
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" />
-            </intent-filter>
-        </service>
-
         <service android:name="org.chromium.chrome.browser.prerender.ChromePrerenderService"
             android:exported="true"
             tools:ignore="ExportedService" />
@@ -1762,7 +1592,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process0"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1772,7 +1602,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process1"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1782,7 +1612,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process2"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1792,7 +1622,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process3"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1802,7 +1632,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process4"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1812,7 +1642,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process5"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1822,7 +1652,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process6"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1832,7 +1662,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process7"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1842,7 +1672,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process8"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1852,7 +1682,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process9"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1862,7 +1692,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process10"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1872,7 +1702,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process11"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1882,7 +1712,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process12"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1892,7 +1722,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process13"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1902,7 +1732,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process14"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1912,7 +1742,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process15"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1922,7 +1752,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process16"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1932,7 +1762,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process17"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1942,7 +1772,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process18"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
         <!-- When use_order_profiling is set, the renderer processes need to be
              able to write profiling information and thus cannot be
@@ -1952,7 +1782,7 @@ by a child template that "extends" this file.
             android:process=":sandboxed_process19"
             android:permission="org.chromium.chrome.permission.CHILD_SERVICE"
             android:isolatedProcess="true"
-            android:exported="False"
+            android:exported="false"
  />
 
         <meta-data android:name="org.chromium.content.browser.NUM_PRIVILEGED_SERVICES"
diff --git a/app/src/main/java/com/google/ipc/invalidation/external/client/contrib/MultiplexingGcmListener.java b/app/src/main/java/com/google/ipc/invalidation/external/client/contrib/MultiplexingGcmListener.java
index 321ae83..d762544 100644
--- a/app/src/main/java/com/google/ipc/invalidation/external/client/contrib/MultiplexingGcmListener.java
+++ b/app/src/main/java/com/google/ipc/invalidation/external/client/contrib/MultiplexingGcmListener.java
@@ -16,9 +16,6 @@
 
 package com.google.ipc.invalidation.external.client.contrib;
 
-import com.google.android.gcm.GCMBaseIntentService;
-import com.google.android.gcm.GCMBroadcastReceiver;
-import com.google.android.gcm.GCMRegistrar;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
 import com.google.ipc.invalidation.ticl.android2.WakeLockManager;
@@ -34,42 +31,7 @@ import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.pm.ServiceInfo;
 
-/**
- * A Google Cloud Messaging listener class that rebroadcasts events as package-scoped
- * broadcasts. This allows multiple components to share a single GCM connection.
- * <p>
- * This listener uses an API of broadcasted Intents that is modeled after that provided by
- * {@link GCMBaseIntentService}. For each upcall (e.g., onMessage, on Registered, etc) specified
- * by {@code GCMBaseIntentService}, there is an {@code EXTRA_OP_...} constant defined in
- * {@link Intents}.
- * <p>
- * Note that this class does <b>NOT</b> handle registering with GCM; applications are still required
- * to do that in the usual way (e.g., using the GCMRegistrar class from the GCM library).
- * <p>
- * In order to raise a {@code GCMBaseIntentService} event to listeners, this service will broadcast
- * an Intent with the following properties:
- * 1. The action of the Intent is {@link Intents#ACTION}
- * 2. There is a boolean-valued extra in the Intent whose key is the {@code EXTRA_OP_...} key
- *    for that call and whose value is {@code true}. For any intent, exactly one {@code EXTRA_OP}
- *    extra will be set.
- * 3. The Intent contains additional call-specific extras required to interpret it. (See note for
- *    onMessage, below).
- * <p>
- * Clients of this service <b>MUST NOT</b> assume that there is a one-to-one mapping between
- * issued broadcasts and actual GCM intents. I.e., this service may issue broadcast intents
- * spontaneously, and it may not issue an intent for every GCM event.
- * <p>
- * For the onMessage() call, the broadcast intent will contain key/value extras containing the
- * message payload. These extras are guaranteed to be identical to those that would have been in
- * the Intent provided to the onMessage call. However, clients <b>MUST NOT</b> assume that the
- * Intent broadcast to communicate a GCM message is literally the same Intent generated by the GCM
- * client library.
- * <p>
- * This class does not expose the {@code onError} call, since according to the GCM documentation
- * there is nothing to do except log an error (which this class does).
- *
- */
-public class MultiplexingGcmListener extends GCMBaseIntentService {
+public class MultiplexingGcmListener {
   /* This class is public so that it can be instantiated by the Android runtime. */
 
   /** Constants used in broadcast Intents. */
@@ -105,13 +67,7 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
     public static final String EXTRA_DATA_NUM_DELETED_MSGS = PREFIX + "NUM_DELETED_MSGS";
   }
 
-  /**
-   * {@link GCMBroadcastReceiver} that forwards GCM intents to the {@code MultiplexingGcmListener}
-   * class.
-   */
-  public static class GCMReceiver extends GCMBroadcastReceiver {
-    /* This class is public so that it can be instantiated by the Android runtime. */
-    @Override
+  public static class GCMReceiver {
     protected String getGCMIntentServiceClassName(Context context) {
       return MultiplexingGcmListener.class.getName();
     }
@@ -262,7 +218,6 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
 
   // All onYYY methods work by constructing an appropriate Intent and broadcasting it.
 
-  @Override
   protected void onMessage(Context context, Intent intent) {
     Intent newIntent = new Intent();
     newIntent.putExtra(Intents.EXTRA_OP_MESSAGE, true);
@@ -270,7 +225,6 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
     rebroadcast(newIntent);
   }
 
-  @Override
   protected void onRegistered(Context context, String registrationId) {
     Intent intent = new Intent();
     intent.putExtra(Intents.EXTRA_OP_REGISTERED, true);
@@ -278,7 +232,6 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
     rebroadcast(intent);
   }
 
-  @Override
   protected void onUnregistered(Context context, String registrationId) {
     Intent intent = new Intent();
     intent.putExtra(Intents.EXTRA_OP_UNREGISTERED, true);
@@ -286,7 +239,6 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
     rebroadcast(intent);
   }
 
-  @Override
   protected void onDeletedMessages(Context context, int total) {
     Intent intent = new Intent();
     intent.putExtra(Intents.EXTRA_OP_DELETED_MESSAGES, true);
@@ -294,15 +246,13 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
     rebroadcast(intent);
   }
 
-  @Override
   protected void onError(Context context, String errorId) {
     // This is called for unrecoverable errors, so just log a warning.
     logger.warning("GCM error: %s", errorId);
   }
 
-  @Override
   protected String[] getSenderIds(Context context) {
-    return readSenderIdsFromManifestOrDie(this);
+    return null;
   }
 
   /**
@@ -311,8 +261,6 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
    */
   private void rebroadcast(Intent intent) {
     intent.setAction(Intents.ACTION);
-    intent.setPackage(getPackageName());
-    sendBroadcast(intent);
   }
 
   /**
@@ -325,13 +273,7 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
    */
   public static String initializeGcm(Context context) {
     AndroidChannelPreferences.setGcmChannelType(context, GcmChannelType.DEFAULT);
-    GCMRegistrar.checkDevice(context);
-    GCMRegistrar.checkManifest(context);
-    final String regId = GCMRegistrar.getRegistrationId(context);
-    if (regId.isEmpty()) {
-      GCMRegistrar.register(context, readSenderIdsFromManifestOrDie(context));
-    }
-    return regId;
+    return null;
   }
 
   /**
diff --git a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java
index 3149de9..7e004cf 100644
--- a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java
+++ b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java
@@ -15,8 +15,6 @@
  */
 package com.google.ipc.invalidation.ticl.android2.channel;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.OneoffTask;
 import com.google.ipc.invalidation.common.GcmSharedConstants;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
@@ -50,8 +48,6 @@ public class AndroidGcmController {
 
   private static AndroidGcmController androidGcmController;
 
-  private GcmNetworkManager gcmNetworkManager;
-
   private Context context;
 
   /**
@@ -65,29 +61,21 @@ public class AndroidGcmController {
     synchronized (lock) {
       if (androidGcmController == null) {
         androidGcmController =
-            new AndroidGcmController(context, GcmNetworkManager.getInstance(context));
+            new AndroidGcmController(context);
       }
     }
     return androidGcmController;
   }
 
-  /**
-   * Override AndroidGcmController with a custom GcmNetworkManager in tests. This overrides the
-   * existing instance of AndroidGcmController if any.
-   *
-   * @param context the application context.
-   * @param gcmNetworkManager the custom GcmNetworkManager to use.
-   */
   public static void overrideAndroidGcmControllerForTests(
-      Context context, GcmNetworkManager gcmNetworkManager) {
+      Context context) {
     synchronized (lock) {
-      androidGcmController = new AndroidGcmController(context, gcmNetworkManager);
+      androidGcmController = new AndroidGcmController(context);
     }
   }
 
-  private AndroidGcmController(Context context, GcmNetworkManager gcmNetworkManager) {
+  private AndroidGcmController(Context context) {
     this.context = context;
-    this.gcmNetworkManager = gcmNetworkManager;
   }
 
   /**
@@ -122,13 +110,6 @@ public class AndroidGcmController {
     }
   }
 
-  /**
-   * Clears the current registration token and schedules a {@link OneoffTask} to start the
-   * GcmRegistrationTaskService if Google Play Services is available.
-   *
-   * <p>Declared public to be used by the client to update the token if they define an
-   * implementation of InstanceIDListenerService.
-   */
   public void fetchToken() {
     // Clear the current token. If the call to InstanceID#getToken fails a new token will be fetched
     // on the next call to {@code initializeGcm}.
@@ -141,22 +122,6 @@ public class AndroidGcmController {
       logger.warning("Google Play Services unavailable. Initialization failed.");
       return;
     }
-
-    OneoffTask registrationTask =
-        new OneoffTask.Builder()
-            .setExecutionWindow(0, 1)
-            .setTag(AndroidChannelConstants.GCM_REGISTRATION_TASK_SERVICE_TAG)
-            .setService(GcmRegistrationTaskService.class)
-            .build();
-
-    try {
-      gcmNetworkManager.schedule(registrationTask);
-    } catch (IllegalArgumentException exception) {
-      // Scheduling the service can throw an exception due to a framework error on Android when
-      // the the look up for the GCMTaskService being scheduled to be run fails.
-      // See crbug/548314.
-      logger.warning("Failed to schedule GCM registration task. Exception: %s", exception);
-    }
   }
 
   /**
diff --git a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java
index f96b8a2..e5630f3 100644
--- a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java
+++ b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java
@@ -15,24 +15,12 @@
  */
 package com.google.ipc.invalidation.ticl.android2.channel;
 
-import com.google.android.gms.iid.InstanceIDListenerService;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
 
-/**
- * Implementation of {@link InstanceIDListenerService} to receive notifications from GCM to
- * update the registration token.
- */
-public class AndroidInstanceIDListenerService extends InstanceIDListenerService {
+public class AndroidInstanceIDListenerService {
   private static final Logger logger = AndroidLogger.forTag("InstanceIDListener");
-  
-  /**
-   * Called when the token needs to updated. {@link AndroidGcmController#fetchToken} clears the
-   * current token and schedules a task to fetch a new token.
-   */
-  @Override
+
   public void onTokenRefresh() {
-    logger.info("Received token refresh request");
-    AndroidGcmController.get(this).fetchToken();
   }
 }
diff --git a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageReceiverService.java b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageReceiverService.java
index aa3938c..7fa2989 100644
--- a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageReceiverService.java
+++ b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageReceiverService.java
@@ -15,7 +15,6 @@
  */
 package com.google.ipc.invalidation.ticl.android2.channel;
 
-import com.google.android.gcm.GCMRegistrar;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
 import com.google.ipc.invalidation.external.client.contrib.MultiplexingGcmListener;
@@ -131,15 +130,5 @@ public class AndroidMessageReceiverService extends MultiplexingGcmListener.Abstr
    * this.
    */
   public static void initializeGcmForTest(Context context, Logger logger, String senderId) {
-    // Initialize GCM.
-    GCMRegistrar.checkDevice(context);
-    GCMRegistrar.checkManifest(context);
-    String regId = GCMRegistrar.getRegistrationId(context);
-    if (regId.isEmpty()) {
-      logger.info("Not registered with GCM; registering");
-      GCMRegistrar.register(context, senderId);
-    } else {
-      logger.fine("Already registered with GCM: %s", regId);
-    }
   }
 }
diff --git a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageSenderService.java b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageSenderService.java
index 22a168c..457fe63 100644
--- a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageSenderService.java
+++ b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageSenderService.java
@@ -15,7 +15,6 @@
  */
 package com.google.ipc.invalidation.ticl.android2.channel;
 
-import com.google.android.gcm.GCMRegistrar;
 import com.google.ipc.invalidation.common.GcmSharedConstants;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
@@ -395,14 +394,7 @@ public class AndroidMessageSenderService extends IntentService {
     } else {
       // No client key when using old style registration id.
       clientKey = "";
-      try {
-        registrationId = GCMRegistrar.getRegistrationId(context);
-      } catch (RuntimeException exception) {
-        // GCMRegistrar#getRegistrationId occasionally throws a runtime exception. Catching the
-        // exception rather than crashing.
-        logger.warning("Unable to get GCM registration id: %s", exception);
-        registrationId = null;
-      }
+      registrationId = null;
     }
     if ((registrationId == null) || registrationId.isEmpty()) {
       // No registration with GCM; we cannot compute a network id. The GCM documentation says the
diff --git a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java
index 06c9d2f..fbcd608 100644
--- a/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java
+++ b/app/src/main/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java
@@ -15,11 +15,6 @@
  */
 package com.google.ipc.invalidation.ticl.android2.channel;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.GcmTaskService;
-import com.google.android.gms.gcm.GoogleCloudMessaging;
-import com.google.android.gms.gcm.TaskParams;
-import com.google.android.gms.iid.InstanceID;
 import com.google.ipc.invalidation.common.GcmSharedConstants;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
@@ -32,98 +27,14 @@ import android.content.Intent;
 
 import java.io.IOException;
 
-/**
- * Implementation of {@link GcmTaskService} to fetch the registration token from GCM. The service is
- * started by the {@link GcmNetworkManager} when a Task scheduled using the GcmNetworkManager is
- * ready to be executed. The task to start this service is scheduled in
- * {@link AndroidGcmController#fetchToken}.
- *
- * <p>The service fetches a token from GCM, stores it and sends an update to the server. In case of
- * failure to fetch the token, the task is rescheduled using the GcmNetworkManager which uses
- * exponential back-offs to control when the task is executed.
- */
-public class GcmRegistrationTaskService extends GcmTaskService {
+public class GcmRegistrationTaskService {
   private static final Logger logger = AndroidLogger.forTag("RegistrationTaskService");
 
-  public InstanceID getInstanceID(Context context) {
-    return InstanceID.getInstance(context);
-  }
-
-  /**
-   * Called when the task is ready to be executed. Registers with GCM using
-   * {@link InstanceID#getToken} and stores the registration token.
-   *
-   * <p>Returns {@link GcmNetworkManager#RESULT_SUCCESS} when the token is successfully retrieved.
-   * On failure {@link GcmNetworkManager#RESULT_RESCHEDULE} is used which reschedules the service
-   * to be executed again using exponential back-off.
-   */
-  @Override
-  public int onRunTask(TaskParams params) {
-    if (!AndroidChannelConstants.GCM_REGISTRATION_TASK_SERVICE_TAG.equals(params.getTag())) {
-     logger.warning("Unknown task received with tag: %s", params.getTag());
-     return GcmNetworkManager.RESULT_FAILURE;
-    }
-
-    String senderId = GcmSharedConstants.GCM_UPDATED_SENDER_ID;
-    try {
-      String token = getInstanceID(this).getToken(
-          senderId, GoogleCloudMessaging.INSTANCE_ID_SCOPE, null);
-      storeToken(token);
-      return GcmNetworkManager.RESULT_SUCCESS;
-    } catch (IOException exception) {
-      logger.warning("Failed to get token for sender: %s. Exception : %s", senderId, exception);
-      return GcmNetworkManager.RESULT_RESCHEDULE;
-    } catch (SecurityException exception) {
-      // InstanceID#getToken occasionally throws a security exception when trying send the
-      // registration intent to GMSCore. Catching the exception here to prevent crashes.
-      logger.warning("Security exception when fetching token: %s", exception);
-      return GcmNetworkManager.RESULT_RESCHEDULE;
-    }
-  }
-
   /** Stores the registration token and the current application version in Shared Preferences. */
   private void storeToken(String token) {
-    AndroidChannelPreferences.setRegistrationToken(this, token);
-    AndroidChannelPreferences.setAppVersion(
-        this, CommonUtils.getPackageVersion(this, getPackageName()));
-    // Send the updated token to the server.
-    updateServer();
   }
 
   /** Sends a message to the server to update the GCM registration token. */
   private void updateServer() {
-    // Inform the sender service that the registration token has changed. If the sender service
-    // had buffered a message because no registration token was previously available, this intent
-    // will cause it to send that message.
-    Intent sendBuffered = new Intent();
-    final String ignoredData = "";
-    sendBuffered.putExtra(AndroidChannelConstants.MESSAGE_SENDER_SVC_GCM_REGID_CHANGE, ignoredData);
-
-    // Select the sender service to use for upstream message.
-    if (AndroidChannelPreferences.getGcmChannelType(this) == GcmChannelType.GCM_UPSTREAM) {
-      String upstreamServiceClass = new AndroidTiclManifest(this).getGcmUpstreamServiceClass();
-      if (upstreamServiceClass == null) {
-        logger.warning("GcmUpstreamSenderService class not found.");
-        return;
-      }
-      sendBuffered.setClassName(this, upstreamServiceClass);
-    } else {
-      sendBuffered.setClass(this, AndroidMessageSenderService.class);
-    }
-    try {
-      startService(sendBuffered);
-    } catch (IllegalStateException exception) {
-      logger.warning("Unable to send buffered message(s): %s", exception);
-    }
-
-    // Inform the Ticl service that the registration id has changed. This will cause it to send
-    // a message to the data center and update the GCM registration id stored at the data center.
-    Intent updateServer = ProtocolIntents.InternalDowncalls.newNetworkAddrChangeIntent();
-    updateServer.setClassName(this, new AndroidTiclManifest(this).getTiclServiceClass());
-    try {
-      startService(updateServer);
-    } catch (IllegalStateException exception) {
-      logger.warning("Unable to inform server about new registration id: %s", exception);
-    }
   }
 }
diff --git a/app/src/main/java/com/google/vr/cardboard/DisplaySynchronizer.java b/app/src/main/java/com/google/vr/cardboard/DisplaySynchronizer.java
new file mode 100644
index 0000000..4edc2c9
--- /dev/null
+++ b/app/src/main/java/com/google/vr/cardboard/DisplaySynchronizer.java
@@ -0,0 +1,16 @@
+package com.google.vr.cardboard;
+
+import android.content.Context;
+
+public class DisplaySynchronizer {
+
+    protected native long nativeCreate(ClassLoader classLoader, Context context);
+
+    protected native void nativeDestroy(long j);
+
+    protected native void nativeOnMetricsChanged(long j);
+
+    protected native void nativeReset(long j, long j2, long j3);
+
+    protected native void nativeUpdate(long j, long j2, int i);
+}
diff --git a/app/src/main/java/com/google/vr/cardboard/EglReadyListener.java b/app/src/main/java/com/google/vr/cardboard/EglReadyListener.java
new file mode 100644
index 0000000..3bb73e7
--- /dev/null
+++ b/app/src/main/java/com/google/vr/cardboard/EglReadyListener.java
@@ -0,0 +1,4 @@
+package com.google.vr.cardboard;
+
+public class EglReadyListener {
+}
diff --git a/app/src/main/java/com/google/vr/internal/controller/NativeCallbacks.java b/app/src/main/java/com/google/vr/internal/controller/NativeCallbacks.java
new file mode 100644
index 0000000..0248b48
--- /dev/null
+++ b/app/src/main/java/com/google/vr/internal/controller/NativeCallbacks.java
@@ -0,0 +1,31 @@
+package com.google.vr.internal.controller;
+
+public class NativeCallbacks {
+    private final native void handleAccelEvent(long j, int i, long j2, float f, float f2, float f3);
+
+    private final native void handleBatteryEvent(long j, int i, long j2, boolean z, int i2);
+
+    private final native void handleButtonEvent(long j, int i, long j2, int i2, boolean z);
+
+    private final native void handleControllerRecentered(long j, int i, long j2, float f, float f2, float f3, float f4);
+
+    private final native void handleGyroEvent(long j, int i, long j2, float f, float f2, float f3);
+
+    private final native void handleOrientationEvent(long j, int i, long j2, float f, float f2, float f3, float f4);
+
+    private final native void handlePositionEvent(long j, int i, long j2, float f, float f2, float f3);
+
+    private final native void handleServiceConnected(long j, int i);
+
+    private final native void handleServiceDisconnected(long j);
+
+    private final native void handleServiceFailed(long j);
+
+    private final native void handleServiceInitFailed(long j, int i);
+
+    private final native void handleServiceUnavailable(long j);
+
+    private final native void handleStateChanged(long j, int i, int i2);
+
+    private final native void handleTouchEvent(long j, int i, long j2, int i2, float f, float f2);
+}
diff --git a/app/src/main/java/com/google/vr/ndk/base/GvrApi.java b/app/src/main/java/com/google/vr/ndk/base/GvrApi.java
new file mode 100644
index 0000000..8688595
--- /dev/null
+++ b/app/src/main/java/com/google/vr/ndk/base/GvrApi.java
@@ -0,0 +1,280 @@
+package com.google.vr.ndk.base;
+
+import android.content.Context;
+import android.os.Handler;
+import android.view.Surface;
+
+import android.graphics.Point;
+import android.graphics.PointF;
+import android.graphics.RectF;
+
+import com.google.vr.cardboard.EglReadyListener;
+
+public class GvrApi {
+
+    interface IdleListener {
+        void onIdleChanged(boolean z);
+    }
+
+    public interface PoseTracker {
+        void getHeadPoseInStartSpace(float[] fArr, long j);
+    }
+
+    static native byte[] nativeAnalyticsCreateSample(long j, byte[] bArr);
+
+    static native long nativeBufferSpecCreate(long j);
+
+    static native void nativeBufferSpecDestroy(long j);
+
+    static native int nativeBufferSpecGetSamples(long j);
+
+    static native void nativeBufferSpecGetSize(long j, Point point);
+
+    static native void nativeBufferSpecSetColorFormat(long j, int i);
+
+    static native void nativeBufferSpecSetDepthStencilFormat(long j, int i);
+
+    static native void nativeBufferSpecSetMultiviewLayers(long j, int i);
+
+    static native void nativeBufferSpecSetSamples(long j, int i);
+
+    static native void nativeBufferSpecSetSize(long j, int i, int i2);
+
+    static native long nativeBufferViewportCreate(long j);
+
+    static native void nativeBufferViewportDestroy(long j);
+
+    static native boolean nativeBufferViewportEqual(long j, long j2);
+
+    static native int nativeBufferViewportGetExternalSurfaceId(long j);
+
+    static native float nativeBufferViewportGetOpacity(long j);
+
+    static native int nativeBufferViewportGetReprojection(long j);
+
+    static native int nativeBufferViewportGetSourceBufferIndex(long j);
+
+    static native void nativeBufferViewportGetSourceFov(long j, RectF rectF);
+
+    static native void nativeBufferViewportGetSourceUv(long j, RectF rectF);
+
+    static native int nativeBufferViewportGetTargetEye(long j);
+
+    static native void nativeBufferViewportGetTransform(long j, float[] fArr);
+
+    static native void nativeBufferViewportGetVignetteFraction(long j, PointF pointF);
+
+    private native long nativeBufferViewportListCreate(long j);
+
+    static native void nativeBufferViewportListDestroy(long j);
+
+    static native void nativeBufferViewportListGetItem(long j, int i, long j2);
+
+    static native int nativeBufferViewportListGetSize(long j);
+
+    static native void nativeBufferViewportListSetItem(long j, int i, long j2);
+
+    static native void nativeBufferViewportSetExternalSurface(long j, long j2);
+
+    static native void nativeBufferViewportSetExternalSurfaceId(long j, int i);
+
+    static native void nativeBufferViewportSetEyeFromWorldMatrix(long j, float[] fArr);
+
+    static native void nativeBufferViewportSetOpacity(long j, float f);
+
+    static native void nativeBufferViewportSetReprojection(long j, int i);
+
+    static native void nativeBufferViewportSetSourceBufferIndex(long j, int i);
+
+    static native void nativeBufferViewportSetSourceFov(long j, float f, float f2, float f3, float f4);
+
+    static native void nativeBufferViewportSetSourceLayer(long j, int i);
+
+    static native void nativeBufferViewportSetSourceUv(long j, float f, float f2, float f3, float f4);
+
+    static native void nativeBufferViewportSetTargetEye(long j, int i);
+
+    static native void nativeBufferViewportSetTransform(long j, float[] fArr);
+
+    static native void nativeBufferViewportSetVignetteFraction(long j, float f, float f2);
+
+    static native void nativeBufferViewportUnsetEyeFromWorldMatrix(long j);
+
+    private native int nativeClearError(long j);
+
+    private native float[] nativeComputeDistortedPoint(long j, int i, float[] fArr);
+
+    private native long nativeCreate(ClassLoader classLoader, Context context, long j, int i, int i2, float f, float f2, PoseTracker poseTracker);
+
+    static native long nativeCreateEvent();
+
+    static native long nativeCreateValue();
+
+    static native void nativeDestroyEvent(long j);
+
+    static native void nativeDestroyValue(long j);
+
+    private native void nativeDistortToScreen(long j, int i, long j2, float[] fArr, long j3);
+
+    private native void nativeDumpDebugData(long j);
+
+    static native long nativeExternalSurfaceCreate(long j);
+
+    static native long nativeExternalSurfaceCreateWithListeners(long j, Runnable runnable, Runnable runnable2, Handler handler);
+
+    static native void nativeExternalSurfaceDestroy(long j);
+
+    static native int nativeExternalSurfaceGetId(long j);
+
+    static native Surface nativeExternalSurfaceGetSurface(long j);
+
+    static native void nativeFrameBindBuffer(long j, int i);
+
+    static native void nativeFrameGetBufferSize(long j, int i, Point point);
+
+    static native int nativeFrameGetFramebufferObject(long j, int i);
+
+    static native void nativeFrameSubmit(long j, long j2, float[] fArr);
+
+    static native void nativeFrameUnbind(long j);
+
+    private native boolean nativeGetAsyncReprojectionEnabled(long j);
+
+    private native float nativeGetBorderSizeMeters(long j);
+
+    private native long nativeGetCurrentProperties(long j);
+
+    private native int nativeGetError(long j);
+
+    private static native String nativeGetErrorString(int i);
+
+    static native long nativeGetEventFlags(long j);
+
+    static native long nativeGetEventTimestamp(long j);
+
+    static native int nativeGetEventType(long j);
+
+    private native void nativeGetEyeFromHeadMatrix(long j, int i, float[] fArr);
+
+    private native void nativeGetHeadSpaceFromStartSpaceRotation(long j, float[] fArr, long j2);
+
+    private native void nativeGetHeadSpaceFromStartSpaceTransform(long j, float[] fArr, long j2);
+
+    private native void nativeGetMaximumEffectiveRenderTargetSize(long j, Point point);
+
+    static native boolean nativeGetProperty(long j, int i, long j2);
+
+    static native long nativeGetRecenterEventFlags(long j);
+
+    static native void nativeGetRecenterEventStartSpaceFromTrackingSpaceTransform(long j, float[] fArr);
+
+    static native int nativeGetRecenterEventType(long j);
+
+    private native void nativeGetRecommendedBufferViewports(long j, long j2);
+
+    private native void nativeGetScreenBufferViewports(long j, long j2);
+
+    private native void nativeGetScreenTargetSize(long j, Point point);
+
+    private native long nativeGetUserPrefs(long j);
+
+    private native String nativeGetViewerModel(long j);
+
+    private native int nativeGetViewerType(long j);
+
+    private native String nativeGetViewerVendor(long j);
+
+    private native int[] nativeGetWindowBounds(long j);
+
+    private native void nativeInitializeGl(long j);
+
+    private native boolean nativeIsFeatureSupported(long j, int i);
+
+    private native void nativeOnPauseReprojectionThread(long j);
+
+    private native void nativeOnSurfaceChangedReprojectionThread(long j);
+
+    private native void nativeOnSurfaceCreatedReprojectionThread(long j);
+
+    private native void nativePause(long j);
+
+    private native void nativePauseTracking(long j);
+
+    private native byte[] nativePauseTrackingGetState(long j);
+
+    private native boolean nativePollEvent(long j, long j2);
+
+    private native void nativeRecenterTracking(long j);
+
+    private native void nativeReconnectSensors(long j);
+
+    private native void nativeReleaseGvrContext(long j);
+
+    private native Point nativeRenderReprojectionThread(long j);
+
+    private native void nativeRequestContextSharing(long j, EglReadyListener eglReadyListener);
+
+    private native void nativeResetTracking(long j);
+
+    private native void nativeResume(long j);
+
+    private native void nativeResumeTracking(long j);
+
+    private native void nativeResumeTrackingSetState(long j, byte[] bArr);
+
+    private static native void nativeSetApplicationState(ClassLoader classLoader, Context context);
+
+    private native boolean nativeSetAsyncReprojectionEnabled(long j, boolean z);
+
+    private native void nativeSetDefaultFramebufferActive(long j);
+
+    private native boolean nativeSetDefaultViewerProfile(long j, String str);
+
+    private native void nativeSetDisplayMetrics(long j, int i, int i2, float f, float f2);
+
+    private static native void nativeSetDynamicLibraryLoadingEnabled(boolean z);
+
+    private native void nativeSetIdleListener(long j, IdleListener idleListener);
+
+    private native void nativeSetIgnoreManualPauseResumeTracker(long j, boolean z);
+
+    private native void nativeSetLensOffset(long j, float f, float f2, float f3);
+
+    private native void nativeSetSurfaceSize(long j, int i, int i2);
+
+    private native boolean nativeSetViewerParams(long j, byte[] bArr);
+
+    static native long nativeSwapChainAcquireFrame(long j);
+
+    static native long nativeSwapChainCreate(long j, long[] jArr);
+
+    static native void nativeSwapChainDestroy(long j);
+
+    static native int nativeSwapChainGetBufferCount(long j);
+
+    static native void nativeSwapChainGetBufferSize(long j, int i, Point point);
+
+    static native void nativeSwapChainResizeBuffer(long j, int i, int i2, int i3);
+
+    static native int nativeUserPrefsGetControllerHandedness(long j);
+
+    static native boolean nativeUserPrefsGetPerformanceHudEnabled(long j);
+
+    static native boolean nativeUserPrefsGetPerformanceMonitoringEnabled(long j);
+
+    private static native boolean nativeUsingDynamicLibrary();
+
+    private static native boolean nativeUsingShimLibrary();
+
+    private native boolean nativeUsingVrDisplayService(long j);
+
+    static native long nativeValueAsFlags(long j);
+
+    static native float nativeValueAsFloat(long j);
+
+    static native int nativeValueAsInt(long j);
+
+    static native void nativeValueAsMat4f(long j, float[] fArr);
+
+    static native long nativeValueGetFlags(long j);
+}
diff --git a/app/src/main/java/org/chromium/chrome/browser/BackgroundSyncLauncher.java b/app/src/main/java/org/chromium/chrome/browser/BackgroundSyncLauncher.java
index 9184219..ef8a240 100644
--- a/app/src/main/java/org/chromium/chrome/browser/BackgroundSyncLauncher.java
+++ b/app/src/main/java/org/chromium/chrome/browser/BackgroundSyncLauncher.java
@@ -9,10 +9,6 @@ import android.content.SharedPreferences;
 import android.os.AsyncTask;
 import android.os.StrictMode;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.OneoffTask;
-import com.google.android.gms.gcm.Task;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.VisibleForTesting;
@@ -37,8 +33,6 @@ public class BackgroundSyncLauncher {
     // BackgroundSyncLauncherAndroid, if any. If it is non-null then the browser is running.
     private static BackgroundSyncLauncher sInstance;
 
-    private GcmNetworkManager mScheduler;
-
     /**
      * Disables the automatic use of the GCMNetworkManager. When disabled, the methods which
      * interact with GCM can still be used, but will not be called automatically on creation, or by
@@ -134,17 +128,6 @@ public class BackgroundSyncLauncher {
             }
             @Override
             protected void onPostExecute(Void params) {
-                if (sGCMEnabled) {
-                    if (shouldLaunch) {
-                        RecordHistogram.recordBooleanHistogram(
-                                "BackgroundSync.LaunchTask.ScheduleSuccess",
-                                scheduleLaunchTask(mScheduler, minDelayMs));
-                    } else {
-                        RecordHistogram.recordBooleanHistogram(
-                                "BackgroundSync.LaunchTask.CancelSuccess",
-                                removeScheduledTasks(mScheduler));
-                    }
-                }
             }
         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
@@ -158,7 +141,6 @@ public class BackgroundSyncLauncher {
     }
 
     protected BackgroundSyncLauncher() {
-        mScheduler = GcmNetworkManager.getInstance(ContextUtils.getApplicationContext());
         launchBrowserIfStopped(false, 0);
     }
 
@@ -187,72 +169,6 @@ public class BackgroundSyncLauncher {
         return !sGCMEnabled;
     }
 
-    private static boolean scheduleLaunchTask(GcmNetworkManager scheduler, long minDelayMs) {
-        // Google Play Services may not be up to date, if the application was not installed through
-        // the Play Store. In this case, scheduling the task will fail silently.
-        final long minDelaySecs = minDelayMs / 1000;
-        OneoffTask oneoff = new OneoffTask.Builder()
-                                    .setService(ChromeBackgroundService.class)
-                                    .setTag(TASK_TAG)
-                                    // We have to set a non-zero execution window here
-                                    .setExecutionWindow(minDelaySecs, minDelaySecs + 1)
-                                    .setRequiredNetwork(Task.NETWORK_STATE_CONNECTED)
-                                    .setPersisted(true)
-                                    .setUpdateCurrent(true)
-                                    .build();
-        try {
-            scheduler.schedule(oneoff);
-        } catch (IllegalArgumentException e) {
-            // Disable GCM for the remainder of this session.
-            setGCMEnabled(false);
-            // Return false so that the failure will be logged.
-            return false;
-        }
-        return true;
-    }
-
-    private static boolean removeScheduledTasks(GcmNetworkManager scheduler) {
-        // Third-party code causes broadcast to touch disk. http://crbug.com/614679
-        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
-        try {
-            scheduler.cancelTask(TASK_TAG, ChromeBackgroundService.class);
-        } catch (IllegalArgumentException e) {
-            // This occurs when BackgroundSyncLauncherService is not found in the application
-            // manifest. This should not happen in code that reaches here, but has been seen in
-            // the past. See https://crbug.com/548314
-            // Disable GCM for the remainder of this session.
-            setGCMEnabled(false);
-            // Return false so that the failure will be logged.
-            return false;
-        } finally {
-            StrictMode.setThreadPolicy(oldPolicy);
-        }
-        return true;
-    }
-
-    /**
-     * Reschedule any required background sync tasks, if they have been removed due to an
-     * application upgrade.
-     *
-     * This method checks the saved preferences, and reschedules the sync tasks as appropriate
-     * to match the preferences.
-     * This method is static so that it can be run without actually instantiating a
-     * BackgroundSyncLauncher.
-     */
-    protected static void rescheduleTasksOnUpgrade(final Context context) {
-        final GcmNetworkManager scheduler = GcmNetworkManager.getInstance(context);
-        BackgroundSyncLauncher.ShouldLaunchCallback callback = shouldLaunch -> {
-            if (shouldLaunch) {
-                // It's unclear what time the sync event was supposed to fire, so fire
-                // without delay and let the browser reschedule if necessary.
-                // TODO(iclelland): If this fails, report the failure via UMA (not now,
-                // since the browser is not running, but on next startup.)
-                scheduleLaunchTask(scheduler, 0);
-            }
-        };
-        BackgroundSyncLauncher.shouldLaunchBrowserIfStopped(callback);
-    }
-
     @VisibleForTesting
     static void setGCMEnabled(boolean enabled) {
         sGCMEnabled = enabled;
diff --git a/app/src/main/java/org/chromium/chrome/browser/ChromeBackgroundService.java b/app/src/main/java/org/chromium/chrome/browser/ChromeBackgroundService.java
index 87a425f..8005b9d 100644
--- a/app/src/main/java/org/chromium/chrome/browser/ChromeBackgroundService.java
+++ b/app/src/main/java/org/chromium/chrome/browser/ChromeBackgroundService.java
@@ -6,10 +6,6 @@ package org.chromium.chrome.browser;
 
 import android.content.Context;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.GcmTaskService;
-import com.google.android.gms.gcm.TaskParams;
-
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
 import org.chromium.base.VisibleForTesting;
@@ -20,50 +16,9 @@ import org.chromium.chrome.browser.ntp.snippets.SnippetsLauncher;
 import org.chromium.chrome.browser.offlinepages.BackgroundScheduler;
 import org.chromium.chrome.browser.offlinepages.OfflinePageUtils;
 
-/**
- * {@link ChromeBackgroundService} is scheduled through the {@link GcmNetworkManager} when the
- * browser needs to be launched for scheduled tasks, or in response to changing network or power
- * conditions.
- */
-public class ChromeBackgroundService extends GcmTaskService {
+public class ChromeBackgroundService {
     private static final String TAG = "BackgroundService";
 
-    @Override
-    @VisibleForTesting
-    public int onRunTask(final TaskParams params) {
-        final String taskTag = params.getTag();
-        Log.i(TAG, "[" + taskTag + "] Woken up at " + new java.util.Date().toString());
-        final Context context = this;
-        ThreadUtils.runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                switch (taskTag) {
-                    case BackgroundSyncLauncher.TASK_TAG:
-                        handleBackgroundSyncEvent(context, taskTag);
-                        break;
-
-                    case OfflinePageUtils.TASK_TAG:
-                        // Offline pages are migrating to BackgroundTaskScheduler, therefore getting
-                        // a task through ChromeBackgroundSerivce should cause a rescheduling using
-                        // the new component.
-                        rescheduleOfflinePages();
-                        break;
-
-                    case SnippetsLauncher.TASK_TAG_WIFI:
-                    case SnippetsLauncher.TASK_TAG_FALLBACK:
-                        handleSnippetsOnPersistentSchedulerWakeUp(context, taskTag);
-                        break;
-
-                    default:
-                        Log.i(TAG, "Unknown task tag " + taskTag);
-                        break;
-                }
-            }
-        });
-
-        return GcmNetworkManager.RESULT_SUCCESS;
-    }
-
     private void handleBackgroundSyncEvent(Context context, String tag) {
         if (!BackgroundSyncLauncher.hasInstance()) {
             // Start the browser. The browser's BackgroundSyncManager (for the active profile) will
@@ -95,29 +50,13 @@ public class ChromeBackgroundService extends GcmTaskService {
 
     @VisibleForTesting
     protected void launchBrowser(Context context, String tag) {
-        Log.i(TAG, "Launching browser");
-        try {
-            ChromeBrowserInitializer.getInstance(this).handleSynchronousStartup();
-        } catch (ProcessInitException e) {
-            Log.e(TAG, "ProcessInitException while starting the browser process");
-            // Since the library failed to initialize nothing in the application
-            // can work, so kill the whole application not just the activity.
-            System.exit(-1);
-        }
     }
 
     @VisibleForTesting
     protected void rescheduleBackgroundSyncTasksOnUpgrade() {
-        BackgroundSyncLauncher.rescheduleTasksOnUpgrade(this);
     }
 
     private void handleSnippetsOnBrowserUpgraded() {
-        if (SnippetsLauncher.shouldNotifyOnBrowserUpgraded()) {
-            if (!SnippetsLauncher.hasInstance()) {
-                launchBrowser(this, /*tag=*/""); // The |tag| doesn't matter here.
-            }
-            snippetsOnBrowserUpgraded();
-        }
     }
 
     /** Reschedules offline pages (using appropriate version of Background Task Scheduler). */
@@ -125,7 +64,6 @@ public class ChromeBackgroundService extends GcmTaskService {
         BackgroundScheduler.getInstance().reschedule();
     }
 
-    @Override
     public void onInitializeTasks() {
         rescheduleBackgroundSyncTasksOnUpgrade();
         handleSnippetsOnBrowserUpgraded();
diff --git a/app/src/main/java/org/chromium/chrome/browser/ChromeVersionInfo.java b/app/src/main/java/org/chromium/chrome/browser/ChromeVersionInfo.java
index 493d2cc..278a7bd 100644
--- a/app/src/main/java/org/chromium/chrome/browser/ChromeVersionInfo.java
+++ b/app/src/main/java/org/chromium/chrome/browser/ChromeVersionInfo.java
@@ -7,8 +7,6 @@ package org.chromium.chrome.browser;
 import android.content.Context;
 import android.content.pm.PackageManager;
 
-import com.google.android.gms.common.GoogleApiAvailability;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.chrome.browser.externalauth.ExternalAuthUtils;
@@ -88,7 +86,7 @@ public class ChromeVersionInfo {
     public static String getGmsInfo() {
         Context context = ContextUtils.getApplicationContext();
 
-        final long sdkVersion = GoogleApiAvailability.GOOGLE_PLAY_SERVICES_VERSION_CODE;
+        final long sdkVersion = 0;
         final long installedGmsVersion = getPlayServicesApkVersionNumber(context);
 
         final String accessType;
@@ -105,12 +103,6 @@ public class ChromeVersionInfo {
     }
 
     private static long getPlayServicesApkVersionNumber(Context context) {
-        try {
-            return context.getPackageManager()
-                    .getPackageInfo(GoogleApiAvailability.GOOGLE_PLAY_SERVICES_PACKAGE, 0)
-                    .versionCode;
-        } catch (PackageManager.NameNotFoundException e) {
-            return 0;
-        }
+        return 0;
     }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/externalauth/ExternalAuthUtils.java b/app/src/main/java/org/chromium/chrome/browser/externalauth/ExternalAuthUtils.java
index 7ebb139..2e08a3e 100644
--- a/app/src/main/java/org/chromium/chrome/browser/externalauth/ExternalAuthUtils.java
+++ b/app/src/main/java/org/chromium/chrome/browser/externalauth/ExternalAuthUtils.java
@@ -16,9 +16,6 @@ import android.os.SystemClock;
 import android.support.annotation.WorkerThread;
 import android.text.TextUtils;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-
 import org.chromium.base.Callback;
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
@@ -166,12 +163,7 @@ public class ExternalAuthUtils {
      *         when it is updating.
      */
     public boolean isGooglePlayServicesMissing(final Context context) {
-        final int resultCode = checkGooglePlayServicesAvailable(context);
-        if (resultCode == ConnectionResult.SERVICE_MISSING
-                || resultCode == ConnectionResult.SERVICE_INVALID) {
-            return true;
-        }
-        return false;
+        return true;
     }
 
     /**
@@ -186,23 +178,6 @@ public class ExternalAuthUtils {
      * @return true if and only if Google Play Services can be used
      */
     public boolean canUseGooglePlayServices(final UserRecoverableErrorHandler errorHandler) {
-        Context context = ContextUtils.getApplicationContext();
-        final int resultCode = checkGooglePlayServicesAvailable(context);
-        recordConnectionResult(resultCode);
-        if (resultCode == ConnectionResult.SUCCESS) {
-            return true;
-        }
-        // resultCode is some kind of error.
-        Log.v(TAG, "Unable to use Google Play Services: %s", describeError(resultCode));
-        if (isUserRecoverableError(resultCode)) {
-            Runnable errorHandlerTask = new Runnable() {
-                @Override
-                public void run() {
-                    errorHandler.handleError(context, resultCode);
-                }
-            };
-            ThreadUtils.runOnUiThread(errorHandlerTask);
-        }
         return false;
     }
 
@@ -289,17 +264,7 @@ public class ExternalAuthUtils {
      * @return The code produced by calling the external code
      */
     protected int checkGooglePlayServicesAvailable(final Context context) {
-        // Temporarily allowing disk access. TODO: Fix. See http://crbug.com/577190
-        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
-        try {
-            long time = SystemClock.elapsedRealtime();
-            int isAvailable =
-                    GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context);
-            mRegistrationTimeHistogramSample.record(SystemClock.elapsedRealtime() - time);
-            return isAvailable;
-        } finally {
-            StrictMode.setThreadPolicy(oldPolicy);
-        }
+        return 0;
     }
 
     /**
@@ -310,7 +275,7 @@ public class ExternalAuthUtils {
      * @return true If the code represents a user-recoverable error
      */
     protected boolean isUserRecoverableError(final int errorCode) {
-        return GoogleApiAvailability.getInstance().isUserResolvableError(errorCode);
+        return false;
     }
 
     /**
@@ -320,6 +285,6 @@ public class ExternalAuthUtils {
      * @return a textual description of the error code
      */
     protected String describeError(final int errorCode) {
-        return GoogleApiAvailability.getInstance().getErrorString(errorCode);
+        return null;
     }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/externalauth/UserRecoverableErrorHandler.java b/app/src/main/java/org/chromium/chrome/browser/externalauth/UserRecoverableErrorHandler.java
index 3956339..121e2ea 100644
--- a/app/src/main/java/org/chromium/chrome/browser/externalauth/UserRecoverableErrorHandler.java
+++ b/app/src/main/java/org/chromium/chrome/browser/externalauth/UserRecoverableErrorHandler.java
@@ -9,8 +9,6 @@ import android.app.Dialog;
 import android.content.Context;
 import android.content.DialogInterface;
 
-import com.google.android.gms.common.GoogleApiAvailability;
-
 import org.chromium.base.ThreadUtils;
 import org.chromium.base.metrics.CachedMetrics.ActionEvent;
 import org.chromium.base.metrics.CachedMetrics.EnumeratedHistogramSample;
@@ -91,13 +89,6 @@ public abstract class UserRecoverableErrorHandler {
         }
     }
 
-    /**
-     * A handler that displays a System Notification. To avoid repeatedly
-     * nagging the user, this is done at most one time per application
-     * lifecycle. The system notification is shown by calling
-     * {@link GoogleApiAvailability#showErrorNotification(int, Context)}.
-     * @see GoogleApiAvailability#showErrorNotification(Context, int)
-     */
     public static final class SystemNotification extends UserRecoverableErrorHandler {
         /**
          * Tracks whether the notification has yet been shown, used to ensure
@@ -113,18 +104,10 @@ public abstract class UserRecoverableErrorHandler {
                         .record(ERROR_HANDLER_ACTION_IGNORED_AS_REDUNDANT);
                 return;
             }
-            GoogleApiAvailability.getInstance().showErrorNotification(context, errorCode);
             sErrorHandlerActionHistogramSample.record(ERROR_HANDLER_ACTION_SYSTEM_NOTIFICATION);
         }
     }
 
-    /**
-     * A handler that displays a modal dialog. Unlike
-     * {@link SystemNotification}, this handler will take action every time it
-     * is invoked.
-     * @see GoogleApiAvailability#getErrorDialog(Activity, int, int,
-     * android.content.DialogInterface.OnCancelListener)
-     */
     public static class ModalDialog extends UserRecoverableErrorHandler {
         private static final int NO_RESPONSE_REQUIRED = -1;
 
@@ -193,12 +176,6 @@ public abstract class UserRecoverableErrorHandler {
             mCancelable = cancelable;
         }
 
-        /**
-         * Displays the dialog in a modal manner using
-         * {@link GoogleApiAvailability#getErrorDialog(Activity, int, int)}.
-         * @param context the context in which the error was encountered
-         * @param errorCode the error code from Google Play Services
-         */
         @Override
         protected final void handle(final Context context, final int errorCode) {
             // Assume old dialogs generated by the same error handler are obsolete when an error
@@ -207,8 +184,6 @@ public abstract class UserRecoverableErrorHandler {
                 cancelDialog();
             }
             if (mDialog == null) {
-                mDialog = GoogleApiAvailability.getInstance().getErrorDialog(
-                        mActivity, errorCode, NO_RESPONSE_REQUIRED);
                 mErrorCode = errorCode;
 
                 DialogUserActionRecorder.createAndAttachToDialog(mDialog);
diff --git a/app/src/main/java/org/chromium/chrome/browser/gcore/ChromeGoogleApiClientImpl.java b/app/src/main/java/org/chromium/chrome/browser/gcore/ChromeGoogleApiClientImpl.java
index 20ef175..055b853 100644
--- a/app/src/main/java/org/chromium/chrome/browser/gcore/ChromeGoogleApiClientImpl.java
+++ b/app/src/main/java/org/chromium/chrome/browser/gcore/ChromeGoogleApiClientImpl.java
@@ -6,9 +6,6 @@ package org.chromium.chrome.browser.gcore;
 
 import android.content.Context;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.api.GoogleApiClient;
-
 import org.chromium.base.Log;
 import org.chromium.base.TraceEvent;
 import org.chromium.chrome.browser.externalauth.ExternalAuthUtils;
@@ -22,19 +19,9 @@ public class ChromeGoogleApiClientImpl implements ChromeGoogleApiClient {
     private static final String TAG = "Icing";
 
     private final Context mApplicationContext;
-    private final GoogleApiClient mClient;
 
-    /**
-     * @param context its application context will be exposed through
-     *            {@link #getApplicationContext()}.
-     * @param client will be exposed through {@link #getApiClient()}.
-     * @param requireFirstPartyBuild true if the given client can only be used in a first-party
-     *            build.
-     */
-    public ChromeGoogleApiClientImpl(Context context, GoogleApiClient client,
-            boolean requireFirstPartyBuild) {
+    public ChromeGoogleApiClientImpl(Context context, boolean requireFirstPartyBuild) {
         mApplicationContext = context.getApplicationContext();
-        mClient = client;
         if (requireFirstPartyBuild && !ExternalAuthUtils.getInstance().isChromeGoogleSigned()) {
             throw new IllegalStateException("GoogleApiClient requires first-party build");
         }
@@ -42,7 +29,7 @@ public class ChromeGoogleApiClientImpl implements ChromeGoogleApiClient {
 
     @Override
     public void disconnect() {
-        mClient.disconnect();
+
     }
 
     @Override
@@ -57,25 +44,10 @@ public class ChromeGoogleApiClientImpl implements ChromeGoogleApiClient {
 
     @Override
     public boolean connectWithTimeout(long timeout) {
-        TraceEvent.begin("ChromeGoogleApiClientImpl:connectWithTimeout");
-        try {
-            ConnectionResult result = mClient.blockingConnect(timeout, TimeUnit.MILLISECONDS);
-            if (!result.isSuccess()) {
-                Log.e(TAG, "Connection to GmsCore unsuccessful. Error %d", result.getErrorCode());
-            } else {
-                Log.d(TAG, "Connection to GmsCore successful.");
-            }
-            return result.isSuccess();
-        } finally {
-            TraceEvent.end("ChromeGoogleApiClientImpl:connectWithTimeout");
-        }
+        return false;
     }
 
     public Context getApplicationContext() {
         return mApplicationContext;
     }
-
-    public GoogleApiClient getApiClient() {
-        return mClient;
-    }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/gcore/GoogleApiClientHelper.java b/app/src/main/java/org/chromium/chrome/browser/gcore/GoogleApiClientHelper.java
index 520184e..444a4f2 100644
--- a/app/src/main/java/org/chromium/chrome/browser/gcore/GoogleApiClientHelper.java
+++ b/app/src/main/java/org/chromium/chrome/browser/gcore/GoogleApiClientHelper.java
@@ -7,18 +7,12 @@ package org.chromium.chrome.browser.gcore;
 import android.os.Bundle;
 import android.os.Handler;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.common.api.GoogleApiClient.ConnectionCallbacks;
-import com.google.android.gms.common.api.GoogleApiClient.OnConnectionFailedListener;
-
 import org.chromium.base.ApplicationStatus;
 import org.chromium.base.ApplicationStatus.ApplicationStateListener;
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
 
 /**
- * Helps managing connections when using {@link GoogleApiClient}.
  *
  * It features:
  *
@@ -34,11 +28,6 @@ import org.chromium.base.ThreadUtils;
  * </ul>
  *
  * <p>
- * It should be used when we want to keep a Client around for extended durations and use it quite
- * often, independently of the current Activity. For intermittent usage, see {@link ConnectedTask}
- * or directly create {@link GoogleApiClient}s. They are already cheap and resilient by design, and
- * can be tied to a specific activity's lifecycle using
- * {@link GoogleApiClient.Builder#enableAutoManage}.
  * </p>
  *
  * Usage:
@@ -67,27 +56,16 @@ import org.chromium.base.ThreadUtils;
  * }
  * </pre>
  */
-public class GoogleApiClientHelper
-        implements OnConnectionFailedListener, ConnectionCallbacks {
+public class GoogleApiClientHelper {
     private static final String TAG = "GCore";
 
     private int mResolutionAttempts;
     private boolean mWasConnectedBefore;
     private final Handler mHandler = new Handler(ThreadUtils.getUiThreadLooper());
-    private final GoogleApiClient mClient;
     private long mDisconnectionDelayMs;
     private Runnable mPendingDisconnect;
 
-    /**
-     * Creates a helper and enrolls it in the various connection management features.
-     * See the class documentation for {@link GoogleApiClientHelper} for more information.
-     *
-     * @param client The client to wrap.
-     */
-    public GoogleApiClientHelper(GoogleApiClient client) {
-        mClient = client;
-        enableConnectionRetrying(true);
-        enableLifecycleManagement(true);
+    public GoogleApiClientHelper() {
     }
 
     /**
@@ -116,13 +94,6 @@ public class GoogleApiClientHelper
      * Enabling or disabling it while it is already enabled or disabled has no effect.
      */
     public void enableConnectionRetrying(boolean enabled) {
-        if (enabled) {
-            mClient.registerConnectionCallbacks(this);
-            mClient.registerConnectionFailedListener(this);
-        } else {
-            mClient.unregisterConnectionCallbacks(this);
-            mClient.unregisterConnectionFailedListener(this);
-        }
     }
 
     /**
@@ -155,21 +126,11 @@ public class GoogleApiClientHelper
         // Cancel and reschedule the disconnection if we are in the background. We do it early to
         // avoid race conditions between a disconnect on the UI thread and the connect below.
         if (!ApplicationStatus.hasVisibleActivities()) scheduleDisconnection();
-
-        // The client might be disconnected if we were idle in the background for too long.
-        if (!mClient.isConnected() && !mClient.isConnecting()) {
-            Log.d(TAG, "Reconnecting the client.");
-            mClient.connect();
-        }
     }
 
     void restoreConnectedState() {
         // If we go back to the foreground before a delayed disconnect happens, cancel it.
         cancelPendingDisconnection();
-
-        if (mWasConnectedBefore) {
-            mClient.connect();
-        }
     }
 
     /**
@@ -192,12 +153,6 @@ public class GoogleApiClientHelper
     }
 
     private void disconnect() {
-        if (mClient.isConnected() || mClient.isConnecting()) {
-            mWasConnectedBefore = true;
-        }
-
-        // We always call disconnect to abort possibly pending connection requests.
-        mClient.disconnect();
     }
 
     private void cancelPendingDisconnection() {
@@ -207,34 +162,10 @@ public class GoogleApiClientHelper
         mPendingDisconnect = null;
     }
 
-    @Override
-    public void onConnectionFailed(ConnectionResult result) {
-        if (!isErrorRecoverableByRetrying(result.getErrorCode())) {
-            Log.d(TAG, "Not retrying managed client connection. Unrecoverable error: %d",
-                    result.getErrorCode());
-            return;
-        }
-
-        if (mResolutionAttempts < ConnectedTask.RETRY_NUMBER_LIMIT) {
-            Log.d(TAG, "Retrying managed client connection. attempt %d/%d - errorCode: %d",
-                    mResolutionAttempts, ConnectedTask.RETRY_NUMBER_LIMIT, result.getErrorCode());
-            mResolutionAttempts += 1;
-
-            mHandler.postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    mClient.connect();
-                }
-            }, ConnectedTask.CONNECTION_RETRY_TIME_MS);
-        }
-    }
-
-    @Override
     public void onConnected(Bundle connectionHint) {
         mResolutionAttempts = 0;
     }
 
-    @Override
     public void onConnectionSuspended(int cause) {
         // GoogleApiClient handles retrying on suspension itself. Logging in case it didn't succeed
         // for some reason.
@@ -242,8 +173,6 @@ public class GoogleApiClientHelper
     }
 
     private static boolean isErrorRecoverableByRetrying(int errorCode) {
-        return errorCode == ConnectionResult.INTERNAL_ERROR
-                || errorCode == ConnectionResult.NETWORK_ERROR
-                || errorCode == ConnectionResult.SERVICE_UPDATING;
+        return false;
     }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/remote/AbstractMediaRouteController.java b/app/src/main/java/org/chromium/chrome/browser/media/remote/AbstractMediaRouteController.java
deleted file mode 100644
index c895e03..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/remote/AbstractMediaRouteController.java
+++ /dev/null
@@ -1,653 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.remote;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.net.Uri;
-import android.os.Handler;
-import android.os.SystemClock;
-import android.support.v7.media.MediaControlIntent;
-import android.support.v7.media.MediaItemStatus;
-import android.support.v7.media.MediaRouteSelector;
-import android.support.v7.media.MediaRouter;
-import android.support.v7.media.MediaRouter.RouteInfo;
-
-import com.google.android.gms.cast.CastMediaControlIntent;
-
-import org.chromium.base.ContextUtils;
-import org.chromium.base.Log;
-import org.chromium.base.VisibleForTesting;
-import org.chromium.base.annotations.RemovableInRelease;
-import org.chromium.chrome.R;
-import org.chromium.chrome.browser.media.remote.RemoteVideoInfo.PlayerState;
-import org.chromium.ui.widget.Toast;
-
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.CopyOnWriteArraySet;
-
-import javax.annotation.Nullable;
-
-/**
- * Class containing the common, connection type independent, code for all MediaRouteControllers.
- */
-public abstract class AbstractMediaRouteController implements MediaRouteController {
-
-    /**
-     * Callback class for monitoring whether any routes exist, and hence deciding whether to show
-     * the cast UI to users.
-     */
-    private class DeviceDiscoveryCallback extends MediaRouter.Callback {
-        @Override
-        public void onProviderAdded(MediaRouter router, MediaRouter.ProviderInfo provider) {
-            updateRouteAvailability();
-        }
-
-        @Override
-        public void onProviderChanged(
-                MediaRouter router, MediaRouter.ProviderInfo provider) {
-            updateRouteAvailability();
-        }
-
-        @Override
-        public void onProviderRemoved(
-                MediaRouter router, MediaRouter.ProviderInfo provider) {
-            updateRouteAvailability();
-        }
-
-        @Override
-        public void onRouteAdded(MediaRouter router, RouteInfo route) {
-            logRoute("Added route", route);
-            updateRouteAvailability();
-        }
-
-        @Override
-        public void onRouteRemoved(MediaRouter router, RouteInfo route) {
-            logRoute("Removed route", route);
-            updateRouteAvailability();
-        }
-
-        @Override
-        public void onRouteChanged(MediaRouter router, RouteInfo route) {
-            logRoute("Changed route", route);
-            updateRouteAvailability();
-        }
-
-        private void updateRouteAvailability() {
-            if (mediaRouterInitializationFailed()) return;
-
-            boolean routesAvailable = getMediaRouter().isRouteAvailable(mMediaRouteSelector,
-                    MediaRouter.AVAILABILITY_FLAG_IGNORE_DEFAULT_ROUTE);
-            if (routesAvailable != mRoutesAvailable) {
-                mRoutesAvailable = routesAvailable;
-                Log.d(TAG, "Remote media route availability changed, updating listeners");
-                for (MediaStateListener listener : mAvailableRouteListeners) {
-                    listener.onRouteAvailabilityChanged(routesAvailable);
-                }
-            }
-        }
-    }
-
-    /**
-     * Callback class for monitoring whether a route has been selected, and the state of the
-     * selected route.
-     */
-    private class DeviceSelectionCallback extends MediaRouter.Callback {
-        // Note that this doesn't use onRouteSelected, but instead casting is started directly
-        // by the selection dialog. It has to be done that way, since selecting the current route
-        // on a new video doesn't call onRouteSelected.
-
-        private Runnable mConnectionFailureNotifier = new Runnable() {
-                @Override
-            public void run() {
-                release();
-                mConnectionFailureNotifierQueued = false;
-            }
-        };
-
-        /** True if we are waiting for the MediaRouter route to connect or reconnect */
-        private boolean mConnectionFailureNotifierQueued;
-
-        private void clearConnectionFailureCallback() {
-            getHandler().removeCallbacks(mConnectionFailureNotifier);
-            mConnectionFailureNotifierQueued = false;
-        }
-
-        @Override
-        public void onRouteChanged(MediaRouter router, RouteInfo route) {
-            // We only care about changes to the current route.
-            if (!route.equals(getCurrentRoute())) return;
-            // When there is no wifi connection, this condition becomes true.
-            if (route.isConnecting()) {
-                // We don't want to post the same Runnable twice.
-                if (!mConnectionFailureNotifierQueued) {
-                    mConnectionFailureNotifierQueued = true;
-                    getHandler().postDelayed(mConnectionFailureNotifier,
-                            CONNECTION_FAILURE_NOTIFICATION_DELAY_MS);
-                }
-            } else {
-                // Only cancel the disconnect if we already posted the message. We can get into this
-                // situation if we swap the current route provider (for example, switching to a YT
-                // video while casting a non-YT video).
-                if (mConnectionFailureNotifierQueued) {
-                    // We have reconnected, cancel the delayed disconnect.
-                    getHandler().removeCallbacks(mConnectionFailureNotifier);
-                    mConnectionFailureNotifierQueued = false;
-                }
-            }
-        }
-
-        @Override
-        public void onRouteUnselected(MediaRouter router, RouteInfo route) {
-            onRouteUnselectedEvent(router, route);
-            if (getCurrentRoute() != null && !getCurrentRoute().isDefault()
-                    && route.getId().equals(getCurrentRoute().getId())) {
-                RecordCastAction.castEndedTimeRemaining(getDuration(),
-                        getDuration() - getPosition());
-                release();
-            }
-        }
-    }
-
-    /** Number of ms to wait for reconnection, after which we call the failure callbacks. */
-    protected static final long CONNECTION_FAILURE_NOTIFICATION_DELAY_MS = 10000L;
-    private static final long END_OF_VIDEO_THRESHOLD_MS = 500L;
-    private static final String TAG = "MediaFling";
-    private final Set<MediaStateListener> mAvailableRouteListeners;
-    private final Context mContext;
-    private RouteInfo mCurrentRoute;
-    private final DeviceDiscoveryCallback mDeviceDiscoveryCallback;;
-    private final DeviceSelectionCallback mDeviceSelectionCallback;
-
-    private final Handler mHandler;
-    private boolean mIsPrepared;
-
-    private final MediaRouter mMediaRouter;
-
-    private final MediaRouteSelector mMediaRouteSelector;
-    /**
-     * The media state listener connects to the web page that requested casting. It will be null if
-     * that page is no longer in a tab, but closing the page or tab should not stop cast. Cast can
-     * still be controlled through the notification even if the page is closed.
-     */
-    private MediaStateListener mMediaStateListener;
-
-    // There are times when the player state shown to user (e.g. just after pressing the pause
-    // button) should update before we receive an update from the Chromecast, so we have to track
-    // two player states.
-    private PlayerState mRemotePlayerState = PlayerState.FINISHED;
-    private PlayerState mDisplayedPlayerState = PlayerState.FINISHED;
-    private boolean mRoutesAvailable;
-    private final Set<UiListener> mUiListeners;
-    private boolean mWatchingRouteSelection;
-
-    private long mMediaElementAttachedTimestampMs;
-    private long mMediaElementDetachedTimestampMs;
-
-    protected AbstractMediaRouteController() {
-        mContext = ContextUtils.getApplicationContext();
-        assert (getContext() != null);
-
-        mHandler = new Handler();
-
-        mMediaRouteSelector = buildMediaRouteSelector();
-
-        MediaRouter mediaRouter;
-
-        try {
-            // Pre-MR1 versions of JB do not have the complete MediaRouter APIs,
-            // so getting the MediaRouter instance will throw an exception.
-            mediaRouter = MediaRouter.getInstance(getContext());
-        } catch (NoSuchMethodError e) {
-            Log.e(TAG, "Can't get an instance of MediaRouter, casting is not supported."
-                    + " Are you still on JB (JVP15S)?");
-            mediaRouter = null;
-        }
-        mMediaRouter = mediaRouter;
-
-        mAvailableRouteListeners = new HashSet<MediaStateListener>();
-        // TODO(aberent): I am unclear why this is accessed from multiple threads, but
-        // if I make it a HashSet then it gets ConcurrentModificationExceptions on some
-        // types of disconnect. Investigate and fix.
-        mUiListeners = new CopyOnWriteArraySet<UiListener>();
-
-        mDeviceDiscoveryCallback = new DeviceDiscoveryCallback();
-        mDeviceSelectionCallback = new DeviceSelectionCallback();
-    }
-
-    @Override
-    public void addMediaStateListener(MediaStateListener listener) {
-        if (mediaRouterInitializationFailed()) return;
-
-        if (mAvailableRouteListeners.isEmpty()) {
-            getMediaRouter().addCallback(mMediaRouteSelector, mDeviceDiscoveryCallback,
-                    MediaRouter.CALLBACK_FLAG_REQUEST_DISCOVERY);
-            Log.d(TAG, "Started device discovery");
-
-            // Get the initial state
-            mRoutesAvailable = getMediaRouter().isRouteAvailable(
-                    mMediaRouteSelector, MediaRouter.AVAILABILITY_FLAG_IGNORE_DEFAULT_ROUTE);
-        }
-        mAvailableRouteListeners.add(listener);
-        // Send the current state to the listener.
-        listener.onRouteAvailabilityChanged(mRoutesAvailable);
-    }
-
-    @Override
-    public void addUiListener(UiListener listener) {
-        mUiListeners.add(listener);
-    }
-
-    protected void clearConnectionFailureCallback() {
-        mDeviceSelectionCallback.clearConnectionFailureCallback();
-    }
-
-    /**
-     * Clear the current playing item (if any) but not the associated session.
-     */
-    protected void clearItemState() {
-        mRemotePlayerState = PlayerState.FINISHED;
-        mDisplayedPlayerState = PlayerState.FINISHED;
-        updateTitle(null);
-    }
-
-    /**
-     * Reset the media route to the default
-     */
-    protected void clearMediaRoute() {
-        if (getMediaRouter() != null) {
-            getMediaRouter().getDefaultRoute().select();
-            registerRoute(getMediaRouter().getDefaultRoute());
-        }
-    }
-
-    @Override
-    public boolean currentRouteSupportsRemotePlayback() {
-        return mCurrentRoute != null && mCurrentRoute.supportsControlCategory(
-                MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-    }
-
-    protected final Context getContext() {
-        return mContext;
-    }
-
-    protected final RouteInfo getCurrentRoute() {
-        return mCurrentRoute;
-    }
-
-    protected final Handler getHandler() {
-        return mHandler;
-    }
-
-    protected final MediaRouter getMediaRouter() {
-        return mMediaRouter;
-    }
-
-    @Override
-    public final MediaStateListener getMediaStateListener() {
-        return mMediaStateListener;
-    }
-
-    public final PlayerState getRemotePlayerState() {
-        return mRemotePlayerState;
-    }
-
-    @Override
-    public final PlayerState getDisplayedPlayerState() {
-        return mDisplayedPlayerState;
-    }
-
-    @Override
-    public final String getRouteName() {
-        return mCurrentRoute == null ? null : mCurrentRoute.getName();
-    }
-
-    protected final Set<UiListener> getUiListeners() {
-        return mUiListeners;
-    }
-
-    private final boolean isAtEndOfVideo(long positionMs, long videoLengthMs) {
-        return videoLengthMs - positionMs < END_OF_VIDEO_THRESHOLD_MS && videoLengthMs > 0;
-    }
-
-    @Override
-    public final boolean isBeingCast() {
-        return (mIsPrepared && mRemotePlayerState != PlayerState.INVALIDATED
-                && mRemotePlayerState != PlayerState.ERROR
-                && mRemotePlayerState != PlayerState.FINISHED);
-    }
-
-    @Override
-    public final boolean isPlaying() {
-        return mRemotePlayerState == PlayerState.PLAYING
-                || mRemotePlayerState == PlayerState.LOADING;
-    }
-
-    @Override
-    public final boolean isRemotePlaybackAvailable() {
-        if (mediaRouterInitializationFailed()) return false;
-
-        return getMediaRouter().getSelectedRoute().getPlaybackType()
-                == MediaRouter.RouteInfo.PLAYBACK_TYPE_REMOTE || getMediaRouter().isRouteAvailable(
-                mMediaRouteSelector, MediaRouter.AVAILABILITY_FLAG_IGNORE_DEFAULT_ROUTE);
-    }
-
-    protected final boolean mediaRouterInitializationFailed() {
-        return getMediaRouter() == null;
-    }
-
-    protected final void notifyRouteSelected(RouteInfo route) {
-        for (UiListener listener : mUiListeners) {
-            listener.onRouteSelected(route.getName(), this);
-        }
-        if (!canCastMedia()) return;
-        if (mMediaStateListener == null) return;
-        mMediaStateListener.pauseLocal();
-        mMediaStateListener.onCastStarting(route.getName());
-        startCastingVideo();
-    }
-
-    // This exists for compatibility with old downstream code
-    // TODO(aberent) convert to abstract
-    protected void startCastingVideo() {
-        String url = mMediaStateListener.getSourceUrl();
-        Uri uri = url == null ? null : Uri.parse(url);
-        setDataSource(uri, mMediaStateListener.getCookies());
-        prepareAsync(
-                mMediaStateListener.getFrameUrl(), mMediaStateListener.getStartPositionMillis());
-    }
-
-    private boolean canCastMedia() {
-        return isRemotePlaybackAvailable() && !routeIsDefaultRoute()
-                && currentRouteSupportsRemotePlayback();
-    }
-
-    protected void onRouteAddedEvent(MediaRouter router, RouteInfo route) {
-    };
-
-    // TODO(aberent): Merge with onRouteSelected(). Needs two sided patch for downstream
-    // implementations
-    protected void onRouteSelectedEvent(MediaRouter router, RouteInfo route) {
-    }
-
-    @Override
-    public void onRouteSelected(MediaStateListener player, MediaRouter router, RouteInfo route) {
-        if (mMediaStateListener != null) mMediaStateListener.onCastStopping();
-        setMediaStateListener(player);
-        onRouteSelectedEvent(router, route);
-    }
-
-    protected abstract void onRouteUnselectedEvent(MediaRouter router, RouteInfo route);
-
-    @Override
-    public void prepareMediaRoute() {
-        startWatchingRouteSelection();
-    }
-
-    @Override
-    public void release() {
-        recordEndOfSessionUMA();
-    }
-
-    private void recordEndOfSessionUMA() {
-        long remotePlaybackStoppedTimestampMs = SystemClock.elapsedRealtime();
-
-        // There was no media element ever...
-        if (mMediaElementAttachedTimestampMs == 0) return;
-
-        long remotePlaybackIntervalMs =
-                remotePlaybackStoppedTimestampMs - mMediaElementAttachedTimestampMs;
-
-        if (mMediaElementDetachedTimestampMs == 0) {
-            mMediaElementDetachedTimestampMs = remotePlaybackStoppedTimestampMs;
-        }
-
-        int noElementRemotePlaybackTimePercentage =
-                (int) ((remotePlaybackStoppedTimestampMs - mMediaElementDetachedTimestampMs) * 100
-                        / remotePlaybackIntervalMs);
-        RecordCastAction.recordRemoteSessionTimeWithoutMediaElementPercentage(
-                noElementRemotePlaybackTimePercentage);
-        mMediaElementAttachedTimestampMs = 0;
-        mMediaElementDetachedTimestampMs = 0;
-    }
-
-    protected final void registerRoute(RouteInfo route) {
-        mCurrentRoute = route;
-        logRoute("Selected route", route);
-    }
-
-    @RemovableInRelease
-    private void logRoute(String message, RouteInfo route) {
-        if (route != null) {
-            Log.d(TAG, message + " " + route.getName() + " " + route.getId());
-        }
-    }
-
-    protected void removeAllListeners() {
-        mUiListeners.clear();
-    }
-
-    @Override
-    public void removeMediaStateListener(MediaStateListener listener) {
-        if (mediaRouterInitializationFailed()) return;
-
-        mAvailableRouteListeners.remove(listener);
-        if (mAvailableRouteListeners.isEmpty()) {
-            getMediaRouter().removeCallback(mDeviceDiscoveryCallback);
-            Log.d(TAG, "Stopped device discovery");
-        }
-    }
-
-    @Override
-    public void removeUiListener(UiListener listener) {
-        mUiListeners.remove(listener);
-    }
-
-    @Override
-    public boolean routeIsDefaultRoute() {
-        return mCurrentRoute != null && mCurrentRoute.isDefault();
-    }
-
-    protected void sendErrorToListeners(int error) {
-        String errorMessage =
-                getContext().getString(R.string.cast_error_playing_video, mCurrentRoute.getName());
-
-        for (UiListener listener : mUiListeners) {
-            listener.onError(error, errorMessage);
-        }
-
-        if (mMediaStateListener != null) mMediaStateListener.onError();
-    }
-
-    @Override
-    public void setMediaStateListener(MediaStateListener mediaStateListener) {
-        if (mMediaStateListener != null && mediaStateListener == null
-                    && mMediaElementAttachedTimestampMs != 0) {
-            mMediaElementDetachedTimestampMs = SystemClock.elapsedRealtime();
-        } else if (mMediaStateListener == null && mediaStateListener != null) {
-            // We're switching the videos so let's record the UMA for the previous one.
-            if (mMediaElementDetachedTimestampMs != 0) recordEndOfSessionUMA();
-
-            mMediaElementAttachedTimestampMs = SystemClock.elapsedRealtime();
-            mMediaElementDetachedTimestampMs = 0;
-        }
-
-        mMediaStateListener = mediaStateListener;
-    }
-
-    private void onCasting() {
-        if (!mIsPrepared) {
-            for (UiListener listener : mUiListeners) {
-                listener.onPrepared(this);
-            }
-            if (mMediaStateListener != null) {
-                if (mMediaStateListener.isPauseRequested()) pause();
-                if (mMediaStateListener.isSeekRequested()) {
-                    seekTo(mMediaStateListener.getSeekLocation());
-                } else {
-                    seekTo(mMediaStateListener.getLocalPosition());
-                }
-                mMediaStateListener.onCastStarted();
-            }
-            RecordCastAction.castDefaultPlayerResult(true);
-            mIsPrepared = true;
-        }
-    }
-
-    protected void setUnprepared() {
-        mIsPrepared = false;
-    }
-
-    protected void showCastError(String routeName) {
-        Toast toast = Toast.makeText(
-                getContext(),
-                getContext().getString(R.string.cast_error_playing_video, routeName),
-                Toast.LENGTH_SHORT);
-        toast.show();
-    }
-
-    private void startWatchingRouteSelection() {
-        if (mWatchingRouteSelection || mediaRouterInitializationFailed()) return;
-
-        mWatchingRouteSelection = true;
-        // Start listening
-        getMediaRouter().addCallback(mMediaRouteSelector, mDeviceSelectionCallback,
-                MediaRouter.CALLBACK_FLAG_REQUEST_DISCOVERY);
-        Log.d(TAG, "Started route selection discovery");
-    }
-
-    protected void stopWatchingRouteSelection() {
-        mWatchingRouteSelection = false;
-        if (getMediaRouter() != null) {
-            getMediaRouter().removeCallback(mDeviceSelectionCallback);
-            Log.d(TAG, "Stopped route selection discovery");
-        }
-    }
-
-    @VisibleForTesting
-    void setPlayerStateForMediaItemState(int state) {
-        PlayerState playerState = PlayerState.STOPPED;
-        switch (state) {
-            case MediaItemStatus.PLAYBACK_STATE_BUFFERING:
-                playerState = PlayerState.LOADING;
-                break;
-            case MediaItemStatus.PLAYBACK_STATE_CANCELED:
-                playerState = PlayerState.FINISHED;
-                break;
-            case MediaItemStatus.PLAYBACK_STATE_ERROR:
-                playerState = PlayerState.ERROR;
-                break;
-            case MediaItemStatus.PLAYBACK_STATE_FINISHED:
-                playerState = PlayerState.FINISHED;
-                break;
-            case MediaItemStatus.PLAYBACK_STATE_INVALIDATED:
-                playerState = PlayerState.INVALIDATED;
-                break;
-            case MediaItemStatus.PLAYBACK_STATE_PAUSED:
-                if (isAtEndOfVideo(getPosition(), getDuration())) {
-                    playerState = PlayerState.FINISHED;
-                } else {
-                    playerState = PlayerState.PAUSED;
-                }
-                break;
-            case MediaItemStatus.PLAYBACK_STATE_PENDING:
-                playerState = PlayerState.PAUSED;
-                break;
-            case MediaItemStatus.PLAYBACK_STATE_PLAYING:
-                playerState = PlayerState.PLAYING;
-                break;
-            default:
-                break;
-        }
-
-        mRemotePlayerState = playerState;
-    }
-
-    protected void updateState(int state) {
-        Log.d(TAG, "updateState oldState: %s player state: %s", mRemotePlayerState, state);
-
-        PlayerState oldState = mRemotePlayerState;
-        setPlayerStateForMediaItemState(state);
-
-        Log.d(TAG, "updateState newState: %s", mRemotePlayerState);
-
-        if (oldState != mRemotePlayerState) {
-            setDisplayedPlayerState(mRemotePlayerState);
-
-            switch (mRemotePlayerState) {
-                case PLAYING:
-                    onCasting();
-                    break;
-                case PAUSED:
-                    onCasting();
-                    break;
-                case FINISHED:
-                    release();
-                    break;
-                case INVALIDATED:
-                    clearItemState();
-                    break;
-                case ERROR:
-                    sendErrorToListeners(CastMediaControlIntent.ERROR_CODE_REQUEST_FAILED);
-                    release();
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    protected void setDisplayedPlayerState(PlayerState state) {
-        mDisplayedPlayerState = state;
-        for (UiListener listener : mUiListeners) {
-            listener.onPlaybackStateChanged(mDisplayedPlayerState);
-        }
-        if (mMediaStateListener != null) {
-            mMediaStateListener.onPlaybackStateChanged(mDisplayedPlayerState);
-        }
-    }
-
-    protected void updateTitle(@Nullable String newTitle) {
-        for (UiListener listener : mUiListeners) {
-            listener.onTitleChanged(newTitle);
-        }
-    }
-
-    @Override
-    public Bitmap getPoster() {
-        if (getMediaStateListener() == null) return null;
-        return getMediaStateListener().getPosterBitmap();
-    }
-
-    // This exists for compatibility with old downstream code
-    // TODO(aberent) remove
-    protected void prepareAsync(String frameUrl, long startPositionMillis){};
-
-    // This exists for compatibility with old downstream code
-    // TODO(aberent) remove
-    protected void setDataSource(Uri uri, String cookies){};
-
-    protected boolean reconnectAnyExistingRoute() {
-        // Temp version to avoid two sided patch while removing
-        return false;
-    };
-
-    @Override
-    public void checkIfPlayableRemotely(String sourceUrl, String frameUrl, String cookies,
-            String userAgent, MediaValidationCallback callback) {
-        callback.onResult(true, sourceUrl, frameUrl);
-    }
-
-    @Override
-    public String getUriPlaying() {
-        return null;
-    }
-
-    // Used by J
-    void setPreparedForTesting() {
-        mIsPrepared = true;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/remote/DefaultMediaRouteController.java b/app/src/main/java/org/chromium/chrome/browser/media/remote/DefaultMediaRouteController.java
deleted file mode 100644
index 85e408d..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/remote/DefaultMediaRouteController.java
+++ /dev/null
@@ -1,870 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.remote;
-
-import android.app.PendingIntent;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.SystemClock;
-import android.support.v7.media.MediaControlIntent;
-import android.support.v7.media.MediaItemMetadata;
-import android.support.v7.media.MediaItemStatus;
-import android.support.v7.media.MediaRouteSelector;
-import android.support.v7.media.MediaRouter;
-import android.support.v7.media.MediaRouter.RouteInfo;
-import android.support.v7.media.MediaSessionStatus;
-
-import com.google.android.gms.cast.CastMediaControlIntent;
-
-import org.chromium.base.ApplicationState;
-import org.chromium.base.ApplicationStatus;
-import org.chromium.base.Log;
-import org.chromium.base.annotations.RemovableInRelease;
-import org.chromium.base.annotations.UsedByReflection;
-import org.chromium.chrome.browser.UrlConstants;
-import org.chromium.chrome.browser.media.remote.RemoteVideoInfo.PlayerState;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-import javax.annotation.Nullable;
-
-/**
- * Class that abstracts all communication to and from the Android MediaRoutes. This class is
- * responsible for connecting to the MRs as well as sending commands and receiving status updates
- * from the remote player.
- *
- *  We have two main scenarios for Cast:
- *
- *  - the first cast: user plays the first video on the Chromecast so we start a new session with
- * the player and fling the video
- *
- *  - the consequent cast: users plays another video while the previous one is still playing
- * remotely meaning that we don't have to start the session but to replace the current video with
- * the new one
- *
- *  Casting the first video takes two intents sent to the selected media route:
- * ACTION_START_SESSION and ACTION_PLAY. The first one is sent before anything else. We get the
- * session id from the result bundle of the intent but need to wait until the session becomes
- * active before sending the video URL via the ACTION_PLAY intent.
- *
- *  Casting the second video to the same target device only takes one ACTION_PLAY intent if
- * the session is still active. Otherwise, the scenario is the same as for the first video.
- */
-@UsedByReflection("RemoteMediaPlayerController.java")
-public class DefaultMediaRouteController extends AbstractMediaRouteController {
-
-    /**
-     * Interface for MediaRouter intents result handlers.
-     */
-    protected interface ResultBundleHandler {
-        void onResult(Bundle data);
-
-        void onError(String message, Bundle data);
-    }
-
-    private static final String TAG = "MediaFling";
-
-    private static final String ACTION_RECEIVE_SESSION_STATUS_UPDATE =
-            "com.google.android.apps.chrome.videofling.RECEIVE_SESSION_STATUS_UPDATE";
-    private static final String ACTION_RECEIVE_MEDIA_STATUS_UPDATE =
-            "com.google.android.apps.chrome.videofling.RECEIVE_MEDIA_STATUS_UPDATE";
-    private static final String MIME_TYPE = "video/mp4";
-    private String mCurrentSessionId;
-    private String mCurrentItemId;
-    private boolean mSeeking;
-    private final String mIntentCategory;
-    private PendingIntent mSessionStatusUpdateIntent;
-    private BroadcastReceiver mSessionStatusBroadcastReceiver;
-    private PendingIntent mMediaStatusUpdateIntent;
-    private BroadcastReceiver mMediaStatusBroadcastReceiver;
-
-    private String mPreferredTitle;
-    private long mStartPositionMillis;
-    private final PositionExtrapolator mPositionExtrapolator = new PositionExtrapolator();
-
-    private Uri mLocalVideoUri;
-
-    private int mSessionState = MediaSessionStatus.SESSION_STATE_INVALIDATED;
-
-    private final ApplicationStatus.ApplicationStateListener mApplicationStateListener =
-            new ApplicationStatus.ApplicationStateListener() {
-                @Override
-                public void onApplicationStateChange(int newState) {
-                    switch (newState) {
-                        // HAS_DESTROYED_ACTIVITIES means all Chrome activities have been destroyed.
-                        case ApplicationState.HAS_DESTROYED_ACTIVITIES:
-                            onActivitiesDestroyed();
-                            break;
-                        default:
-                            break;
-                    }
-                }
-            };
-
-    /**
-     * Default and only constructor.
-     */
-    public DefaultMediaRouteController() {
-        mIntentCategory = getContext().getPackageName();
-    }
-
-    @Override
-    public boolean initialize() {
-        if (mediaRouterInitializationFailed()) return false;
-
-        ApplicationStatus.registerApplicationStateListener(mApplicationStateListener);
-
-        if (mSessionStatusUpdateIntent == null) {
-            Intent sessionStatusUpdateIntent = new Intent(ACTION_RECEIVE_SESSION_STATUS_UPDATE);
-            sessionStatusUpdateIntent.addCategory(mIntentCategory);
-            mSessionStatusUpdateIntent = PendingIntent.getBroadcast(getContext(), 0,
-                    sessionStatusUpdateIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-        }
-
-        if (mMediaStatusUpdateIntent == null) {
-            Intent mediaStatusUpdateIntent = new Intent(ACTION_RECEIVE_MEDIA_STATUS_UPDATE);
-            mediaStatusUpdateIntent.addCategory(mIntentCategory);
-            mMediaStatusUpdateIntent = PendingIntent.getBroadcast(getContext(), 0,
-                    mediaStatusUpdateIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-        }
-
-        return true;
-    }
-
-    @Override
-    public boolean canPlayMedia(String sourceUrl, String frameUrl) {
-
-        if (mediaRouterInitializationFailed()) return false;
-
-        if (sourceUrl == null) return false;
-
-        try {
-            String scheme = new URI(sourceUrl).getScheme();
-            if (scheme == null) return false;
-            return scheme.equals(UrlConstants.HTTP_SCHEME)
-                    || scheme.equals(UrlConstants.HTTPS_SCHEME);
-        } catch (URISyntaxException e) {
-            return false;
-        }
-    }
-
-    @Override
-    public void setRemoteVolume(int delta) {
-        boolean canChangeRemoteVolume = (getCurrentRoute().getVolumeHandling()
-                == MediaRouter.RouteInfo.PLAYBACK_VOLUME_VARIABLE);
-        if (currentRouteSupportsRemotePlayback() && canChangeRemoteVolume) {
-            getCurrentRoute().requestUpdateVolume(delta);
-        }
-    }
-
-    @Override
-    public MediaRouteSelector buildMediaRouteSelector() {
-        return new MediaRouteSelector.Builder().addControlCategory(
-                CastMediaControlIntent.categoryForRemotePlayback(getCastReceiverId())).build();
-    }
-
-    protected String getCastReceiverId() {
-        return CastMediaControlIntent.DEFAULT_MEDIA_RECEIVER_APPLICATION_ID;
-    }
-
-    @Override
-    public void resume() {
-        if (mCurrentItemId == null) return;
-
-        Intent intent = new Intent(MediaControlIntent.ACTION_RESUME);
-        intent.addCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-        intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mCurrentSessionId);
-        sendIntentToRoute(intent, new ResultBundleHandler() {
-            @Override
-            public void onResult(Bundle data) {
-                processMediaStatusBundle(data);
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {
-                release();
-            }
-        });
-
-        setDisplayedPlayerState(PlayerState.LOADING);
-    }
-
-    @Override
-    public void pause() {
-        if (mCurrentItemId == null) return;
-
-        Intent intent = new Intent(MediaControlIntent.ACTION_PAUSE);
-        intent.addCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-        intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mCurrentSessionId);
-        sendIntentToRoute(intent, new ResultBundleHandler() {
-            @Override
-            public void onResult(Bundle data) {
-                processMediaStatusBundle(data);
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {
-                // Do not release the player just because of a failed pause
-                // request. This can happen when pausing more than once for
-                // example.
-            }
-        });
-
-        // Update the last known position to the current one so that we don't
-        // jump back in time discarding whatever we extrapolated from the last
-        // time the position was updated.
-        mPositionExtrapolator.onPaused();
-        setDisplayedPlayerState(PlayerState.PAUSED);
-    }
-
-    /**
-     * Plays the given Uri on the currently selected player. This will replace any currently playing
-     * video
-     *
-     * @param preferredTitle the preferred title of the current playback session to display
-     * @param startPositionMillis from which to start playing.
-     */
-    private void playUri(@Nullable final String preferredTitle, final long startPositionMillis) {
-        RecordCastAction.castMediaType(MediaUrlResolver.getMediaType(mLocalVideoUri));
-        installBroadcastReceivers();
-
-        // If the session is already started (meaning we are casting a video already), we simply
-        // load the new URL with one ACTION_PLAY intent.
-        if (mCurrentSessionId != null) {
-            Log.d(TAG, "Playing a new url: %s", mLocalVideoUri);
-
-            // We keep the same session so only clear the playing item status.
-            clearItemState();
-            startPlayback(preferredTitle, startPositionMillis);
-            return;
-        }
-
-        Log.d(TAG, "Sending stream to app: %s", getCastReceiverId());
-        Log.d(TAG, "Url: %s", mLocalVideoUri);
-
-        startSession(true, null, new ResultBundleHandler() {
-            @Override
-            public void onResult(Bundle data) {
-                configureNewSession(data);
-
-                mPreferredTitle = preferredTitle;
-                updateTitle(mPreferredTitle);
-                mStartPositionMillis = startPositionMillis;
-                // Make sure we get a session status. If the session becomes active
-                // immediately then the broadcast session status can arrive before we have
-                // the session id, so this ensures we get it whatever happens.
-                getSessionStatus(mCurrentSessionId);
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {
-                release();
-                RecordCastAction.castDefaultPlayerResult(false);
-            }
-        });
-    }
-
-    /**
-     * Send a start session intent.
-     *
-     * @param relaunch Whether we should relaunch the cast application.
-     * @param resultBundleHandler BundleHandler to handle reply.
-     */
-    private void startSession(boolean relaunch, String sessionId,
-            ResultBundleHandler resultBundleHandler) {
-        Intent intent = new Intent(MediaControlIntent.ACTION_START_SESSION);
-        intent.addCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-
-        intent.putExtra(CastMediaControlIntent.EXTRA_CAST_STOP_APPLICATION_WHEN_SESSION_ENDS, true);
-        intent.putExtra(MediaControlIntent.EXTRA_SESSION_STATUS_UPDATE_RECEIVER,
-                mSessionStatusUpdateIntent);
-        intent.putExtra(CastMediaControlIntent.EXTRA_CAST_APPLICATION_ID, getCastReceiverId());
-        intent.putExtra(CastMediaControlIntent.EXTRA_CAST_RELAUNCH_APPLICATION, relaunch);
-        if (sessionId != null) intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, sessionId);
-
-        addIntentExtraForDebugLogging(intent);
-        sendIntentToRoute(intent, resultBundleHandler);
-    }
-
-    @RemovableInRelease
-    private void addIntentExtraForDebugLogging(Intent intent) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-            intent.putExtra(CastMediaControlIntent.EXTRA_DEBUG_LOGGING_ENABLED, true);
-        }
-    }
-
-    private void getSessionStatus(String sessionId) {
-        Intent intent = new Intent(MediaControlIntent.ACTION_GET_SESSION_STATUS);
-        intent.addCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-
-        intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, sessionId);
-
-        sendIntentToRoute(intent, new ResultBundleHandler() {
-            @Override
-            public void onResult(Bundle data) {
-                logBundle("getSessionStatus result :", data);
-                processSessionStatusBundle(data);
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {
-                release();
-            }
-        });
-    }
-
-    private void startPlayback(
-            @Nullable final String preferredTitle, final long startPositionMillis) {
-        setUnprepared();
-        Intent intent = new Intent(MediaControlIntent.ACTION_PLAY);
-        intent.addCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-        intent.setDataAndType(mLocalVideoUri, MIME_TYPE);
-        intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mCurrentSessionId);
-        intent.putExtra(MediaControlIntent.EXTRA_ITEM_STATUS_UPDATE_RECEIVER,
-                mMediaStatusUpdateIntent);
-        intent.putExtra(MediaControlIntent.EXTRA_ITEM_CONTENT_POSITION, startPositionMillis);
-
-        if (preferredTitle != null) {
-            Bundle metadata = new Bundle();
-            metadata.putString(MediaItemMetadata.KEY_TITLE, preferredTitle);
-            intent.putExtra(MediaControlIntent.EXTRA_ITEM_METADATA, metadata);
-        }
-
-        sendIntentToRoute(intent, new ResultBundleHandler() {
-            @Override
-            public void onResult(Bundle data) {
-                mCurrentItemId = data.getString(MediaControlIntent.EXTRA_ITEM_ID);
-                processMediaStatusBundle(data);
-                RecordCastAction.castDefaultPlayerResult(true);
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {
-                release();
-                RecordCastAction.castDefaultPlayerResult(false);
-            }
-        });
-    }
-
-    @Override
-    public long getPosition() {
-        return mPositionExtrapolator.getPosition();
-    }
-
-    @Override
-    public long getDuration() {
-        return mPositionExtrapolator.getDuration();
-    }
-
-    @Override
-    public void seekTo(long msec) {
-        if (msec == getPosition()) return;
-        // Update the position now since the MRP will update it only once the video is playing
-        // remotely. In particular, if the video is paused, the MRP doesn't send the command until
-        // the video is resumed.
-        mPositionExtrapolator.onSeek(msec);
-        mSeeking = true;
-        Intent intent = new Intent(MediaControlIntent.ACTION_SEEK);
-        intent.addCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-        intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mCurrentSessionId);
-        intent.putExtra(MediaControlIntent.EXTRA_ITEM_ID, mCurrentItemId);
-        intent.putExtra(MediaControlIntent.EXTRA_ITEM_CONTENT_POSITION, msec);
-        sendIntentToRoute(intent, new ResultBundleHandler() {
-            @Override
-            public void onResult(Bundle data) {
-                if (getMediaStateListener() != null) getMediaStateListener().onSeekCompleted();
-                processMediaStatusBundle(data);
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {
-                release();
-            }
-        });
-    }
-
-    @Override
-    public void release() {
-        super.release();
-
-        for (UiListener listener : getUiListeners()) {
-            listener.onRouteUnselected(this);
-        }
-        if (getMediaStateListener() != null) getMediaStateListener().onRouteUnselected();
-        setMediaStateListener(null);
-
-        if (mediaRouterInitializationFailed()) return;
-        if (mCurrentSessionId == null) {
-            // This can happen if we disconnect after a failure (because the
-            // media could not be casted).
-            disconnect();
-            return;
-        }
-
-        Intent stopIntent = new Intent(MediaControlIntent.ACTION_STOP);
-        stopIntent.addCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-        stopIntent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mCurrentSessionId);
-
-        sendIntentToRoute(stopIntent, new ResultBundleHandler() {
-            @Override
-            public void onResult(Bundle data) {
-                processMediaStatusBundle(data);
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {}
-        });
-
-        Intent endSessionIntent = new Intent(MediaControlIntent.ACTION_END_SESSION);
-        endSessionIntent.addCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
-        endSessionIntent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mCurrentSessionId);
-
-        sendIntentToRoute(endSessionIntent, new ResultBundleHandler() {
-            @Override
-            public void onResult(Bundle data) {
-                logMediaSessionStatus(data);
-
-                for (UiListener listener : getUiListeners()) {
-                    listener.onPlaybackStateChanged(PlayerState.FINISHED);
-                }
-
-                if (getMediaStateListener() != null) {
-                    getMediaStateListener().onPlaybackStateChanged(PlayerState.FINISHED);
-                }
-                recordRemainingTimeUMA();
-                disconnect();
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {
-                disconnect();
-            }
-        });
-    }
-
-    /**
-     * Disconnect from the remote screen without stopping the media playing. use release() for
-     * disconnect + stop.
-     */
-    private void disconnect() {
-        clearStreamState();
-        clearMediaRoute();
-
-        if (mSessionStatusBroadcastReceiver != null) {
-            getContext().unregisterReceiver(mSessionStatusBroadcastReceiver);
-            mSessionStatusBroadcastReceiver = null;
-        }
-        if (mMediaStatusBroadcastReceiver != null) {
-            getContext().unregisterReceiver(mMediaStatusBroadcastReceiver);
-            mMediaStatusBroadcastReceiver = null;
-        }
-        clearConnectionFailureCallback();
-
-        stopWatchingRouteSelection();
-        removeAllListeners();
-    }
-
-    @Override
-    protected void onRouteSelectedEvent(MediaRouter router, RouteInfo route) {
-        Log.d(TAG, "Selected route %s", route);
-        if (!route.isSelected()) return;
-
-        RecordCastAction.castPlayRequested();
-
-        RecordCastAction.remotePlaybackDeviceSelected(
-                RecordCastAction.DEVICE_TYPE_CAST_GENERIC);
-        installBroadcastReceivers();
-
-        if (getMediaStateListener() == null) {
-            showCastError(route.getName());
-            release();
-            return;
-        }
-
-        if (route != getCurrentRoute()) {
-            registerRoute(route);
-            clearStreamState();
-        }
-        mPositionExtrapolator.clear();
-
-        notifyRouteSelected(route);
-    }
-
-    /*
-     * Although our custom implementation of the disconnect button doesn't need this, it is needed
-     * when the route is released due to, for example, another application stealing the route, or
-     * when we switch to a YouTube video on the same device.
-     */
-    @Override
-    protected void onRouteUnselectedEvent(MediaRouter router, RouteInfo route) {
-        Log.d(TAG, "Unselected route %s", route);
-        // Preserve our best guess as to the final position; this is needed to reset the
-        // local position while switching back to local playback.
-        mPositionExtrapolator.onPaused();
-        if (getCurrentRoute() != null && route.getId().equals(getCurrentRoute().getId())) {
-            clearStreamState();
-        }
-    }
-
-    private void installBroadcastReceivers() {
-        if (mSessionStatusBroadcastReceiver == null) {
-            mSessionStatusBroadcastReceiver = new BroadcastReceiver() {
-                @Override
-                public void onReceive(Context context, Intent intent) {
-                    logIntent("Got a session broadcast intent from the MRP: ", intent);
-                    Bundle statusBundle = intent.getExtras();
-
-                    // Ignore null status bundles.
-                    if (statusBundle == null) return;
-
-                    // Ignore the status of old sessions.
-                    String sessionId = statusBundle.getString(MediaControlIntent.EXTRA_SESSION_ID);
-                    if (mCurrentSessionId == null || !mCurrentSessionId.equals(sessionId)) return;
-
-                    processSessionStatusBundle(statusBundle);
-                }
-            };
-            IntentFilter sessionBroadcastIntentFilter =
-                    new IntentFilter(ACTION_RECEIVE_SESSION_STATUS_UPDATE);
-            sessionBroadcastIntentFilter.addCategory(mIntentCategory);
-            getContext().registerReceiver(mSessionStatusBroadcastReceiver,
-                    sessionBroadcastIntentFilter);
-        }
-
-        if (mMediaStatusBroadcastReceiver == null) {
-            mMediaStatusBroadcastReceiver = new BroadcastReceiver() {
-                @Override
-                public void onReceive(Context context, Intent intent) {
-                    logIntent("Got a broadcast intent from the MRP: ", intent);
-
-                    processMediaStatusBundle(intent.getExtras());
-                }
-            };
-            IntentFilter mediaBroadcastIntentFilter =
-                    new IntentFilter(ACTION_RECEIVE_MEDIA_STATUS_UPDATE);
-            mediaBroadcastIntentFilter.addCategory(mIntentCategory);
-            getContext().registerReceiver(mMediaStatusBroadcastReceiver,
-                    mediaBroadcastIntentFilter);
-        }
-    }
-
-    /**
-     * Called when the main activity receives an onDestroy() call.
-     */
-    protected void onActivitiesDestroyed() {
-        ApplicationStatus.unregisterApplicationStateListener(mApplicationStateListener);
-        release();
-    }
-
-    /**
-     * Clear the session and the currently playing item (if any).
-     */
-    protected void clearStreamState() {
-        mLocalVideoUri = null;
-        mCurrentSessionId = null;
-        clearItemState();
-    }
-
-    @Override
-    protected void clearItemState() {
-        // Note: do not clear the stream position, since this is still needed so
-        // that we can reset the local stream position to match.
-        super.clearItemState();
-        mCurrentItemId = null;
-        mPositionExtrapolator.clear();
-        mSeeking = false;
-    }
-
-    private void processSessionStatusBundle(Bundle statusBundle) {
-        MediaSessionStatus status = MediaSessionStatus.fromBundle(
-                statusBundle.getBundle(MediaControlIntent.EXTRA_SESSION_STATUS));
-        int sessionState = status.getSessionState();
-
-        // If no change do nothing
-        if (sessionState == mSessionState) return;
-        mSessionState = sessionState;
-
-        switch (sessionState) {
-            case MediaSessionStatus.SESSION_STATE_ACTIVE:
-                if (mLocalVideoUri != null) {
-                    startPlayback(mPreferredTitle, mStartPositionMillis);
-                }
-                break;
-
-            case MediaSessionStatus.SESSION_STATE_ENDED:
-            case MediaSessionStatus.SESSION_STATE_INVALIDATED:
-                for (UiListener listener : getUiListeners()) {
-                    listener.onPlaybackStateChanged(PlayerState.INVALIDATED);
-                }
-                if (getMediaStateListener() != null) {
-                    getMediaStateListener().onPlaybackStateChanged(PlayerState.INVALIDATED);
-                }
-                // Record the remaining time UMA first, otherwise the playback state will be cleared
-                // in release().
-                recordRemainingTimeUMA();
-                // Set the current session id to null so we don't send the stop intent.
-                mCurrentSessionId = null;
-                release();
-                break;
-
-            default:
-                break;
-        }
-    }
-
-    private void processMediaStatusBundle(Bundle statusBundle) {
-        if (statusBundle == null) return;
-        logBundle("processMediaStatusBundle: ", statusBundle);
-
-        String itemId = statusBundle.getString(MediaControlIntent.EXTRA_ITEM_ID);
-        if (itemId == null || !itemId.equals(mCurrentItemId)) return;
-
-        // Extract item metadata, if available.
-        if (statusBundle.containsKey(MediaControlIntent.EXTRA_ITEM_METADATA)) {
-            Bundle metadataBundle =
-                    (Bundle) statusBundle.getParcelable(MediaControlIntent.EXTRA_ITEM_METADATA);
-            updateTitle(metadataBundle.getString(MediaItemMetadata.KEY_TITLE, mPreferredTitle));
-        }
-
-        // Extract the item status, if available.
-        if (statusBundle.containsKey(MediaControlIntent.EXTRA_ITEM_STATUS)) {
-            Bundle itemStatusBundle =
-                    (Bundle) statusBundle.getParcelable(MediaControlIntent.EXTRA_ITEM_STATUS);
-            MediaItemStatus itemStatus = MediaItemStatus.fromBundle(itemStatusBundle);
-
-            logBundle("Received item status: ", itemStatusBundle);
-
-            updateState(itemStatus.getPlaybackState());
-
-            // Update the PositionExtrapolator that the playback state has changed.
-            if (itemStatus.getPlaybackState() == MediaItemStatus.PLAYBACK_STATE_PLAYING) {
-                mPositionExtrapolator.onResumed();
-            } else if (itemStatus.getPlaybackState() == MediaItemStatus.PLAYBACK_STATE_FINISHED) {
-                mPositionExtrapolator.onFinished();
-            } else {
-                mPositionExtrapolator.onPaused();
-            }
-
-            if ((getRemotePlayerState() == PlayerState.PAUSED)
-                    || (getRemotePlayerState() == PlayerState.PLAYING)
-                    || (getRemotePlayerState() == PlayerState.LOADING)) {
-                this.mCurrentItemId = itemId;
-
-                // duration can possibly be -1 if it's unknown, so cap to 0
-                long duration = Math.max(itemStatus.getContentDuration(), 0);
-                // update the position using the remote player's position
-                // duration can possibly be -1 if it's unknown, so cap to 0
-                long position = Math.min(Math.max(itemStatus.getContentPosition(), 0), duration);
-                // TODO(zqzhang): The GMS core currently uses SystemClock.uptimeMillis() as
-                // timestamp, which does not conform to the MediaRouter support library docs. See
-                // b/28378525 and
-                // http://developer.android.com/reference/android/support/v7/media/MediaItemStatus.html#getTimestamp().
-                // Override the timestamp with elapsedRealtime() by assuming the delay between the
-                // GMS core produces the MediaItemStatus and the code reaches here is short enough.
-                // long timestamp = itemStatus.getTimestamp();
-                long timestamp = SystemClock.elapsedRealtime();
-                notifyDurationUpdated(duration);
-                notifyPositionUpdated(position);
-                mPositionExtrapolator.onPositionInfoUpdated(duration, position, timestamp);
-
-                if (mSeeking) {
-                    mSeeking = false;
-                    if (getMediaStateListener() != null) getMediaStateListener().onSeekCompleted();
-                }
-            }
-            logExtraHttpInfo(itemStatus.getExtras());
-        }
-    }
-
-    /**
-     * Send the given intent to the current route. The result will be returned in the given
-     * ResultBundleHandler. This function will also check to see if the current route can handle the
-     * intent before sending it.
-     *
-     * @param intent the intent to send to the current route.
-     * @param bundleHandler contains the result of sending the intent
-     */
-    private void sendIntentToRoute(final Intent intent, final ResultBundleHandler bundleHandler) {
-        if (getCurrentRoute() == null) {
-            logIntent("sendIntentToRoute ", intent);
-            Log.d(TAG, "The current route is null.");
-            if (bundleHandler != null) bundleHandler.onError(null, null);
-            return;
-        }
-
-        if (!getCurrentRoute().supportsControlRequest(intent)) {
-            logIntent("sendIntentToRoute ", intent);
-            Log.d(TAG, "The intent is not supported by the route: %s", getCurrentRoute());
-            if (bundleHandler != null) bundleHandler.onError(null, null);
-            return;
-        }
-
-        sendControlIntent(intent, bundleHandler);
-    }
-
-    private void sendControlIntent(final Intent intent, final ResultBundleHandler bundleHandler) {
-        Log.d(TAG, "Sending intent to %s %s", getCurrentRoute().getName(),
-                getCurrentRoute().getId());
-        logIntent("sendControlIntent ", intent);
-        if (getCurrentRoute().isDefault()) {
-            Log.d(TAG, "Route is default, not sending");
-            return;
-        }
-
-        getCurrentRoute().sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {
-            @Override
-            public void onResult(Bundle data) {
-                if (data != null && bundleHandler != null) bundleHandler.onResult(data);
-            }
-
-            @Override
-            public void onError(String message, Bundle data) {
-                logControlRequestError(intent, message, data);
-                int errorCode = 0;
-                if (data != null) {
-                    errorCode = data.getInt(CastMediaControlIntent.EXTRA_ERROR_CODE);
-                }
-
-                sendErrorToListeners(errorCode);
-
-                if (bundleHandler != null) bundleHandler.onError(message, data);
-            }
-        });
-    }
-
-    private void notifyDurationUpdated(long durationMillis) {
-        for (UiListener listener : getUiListeners()) {
-            listener.onDurationUpdated(durationMillis);
-        }
-    }
-
-    private void notifyPositionUpdated(long position) {
-        for (UiListener listener : getUiListeners()) {
-            listener.onPositionChanged(position);
-        }
-    }
-
-    private void recordRemainingTimeUMA() {
-        long duration = getDuration();
-        long remainingTime = Math.max(0, duration - getPosition());
-        // Duration has already been cleared.
-        if (getDuration() <= 0) return;
-        RecordCastAction.castEndedTimeRemaining(duration, remainingTime);
-    }
-
-    private String bundleToString(Bundle bundle) {
-        if (bundle == null) return "";
-
-        StringBuilder extras = new StringBuilder();
-        extras.append("[");
-        for (String key : bundle.keySet()) {
-            Object value = bundle.get(key);
-            String valueText = value == null ? "null" : value.toString();
-            if (value instanceof Bundle) valueText = bundleToString((Bundle) value);
-            extras.append(key).append("=").append(valueText).append(",");
-        }
-        extras.append("]");
-        return extras.toString();
-    }
-
-    @Override
-    protected void startCastingVideo() {
-        MediaStateListener listener = getMediaStateListener();
-        if (listener == null) return;
-
-        String url = listener.getSourceUrl();
-
-        Log.d(TAG, "startCastingVideo called, url = %s", url);
-
-        // checkIfPlayableRemotely will have rejected null URLs.
-        assert url != null;
-
-        RecordCastAction.castDomainAndRegistry(listener.getFrameUrl().toString());
-
-        mLocalVideoUri = Uri.parse(url);
-        mStartPositionMillis = listener.getStartPositionMillis();
-        playUri(listener.getTitle(), mStartPositionMillis);
-    }
-
-    private void configureNewSession(Bundle data) {
-        mCurrentSessionId = data.getString(MediaControlIntent.EXTRA_SESSION_ID);
-        mSessionState = MediaSessionStatus.SESSION_STATE_INVALIDATED;
-        Log.d(TAG, "Got a session id: %s", mCurrentSessionId);
-    }
-
-    @Override
-    public void checkIfPlayableRemotely(final String sourceUrl, final String frameUrl,
-            final String cookies, String userAgent, final MediaValidationCallback callback) {
-        new MediaUrlResolver(new MediaUrlResolver.Delegate() {
-
-            @Override
-            public Uri getUri() {
-                return Uri.parse(sourceUrl);
-            }
-
-            @Override
-            public String getCookies() {
-                return cookies;
-            }
-
-            @Override
-            public void deliverResult(Uri uri, boolean playable) {
-                callback.onResult(playable, uri.toString(), frameUrl);
-            }
-        }, userAgent).execute();
-    }
-
-    @Override
-    public String getUriPlaying() {
-        if (mLocalVideoUri == null) return null;
-        return mLocalVideoUri.toString();
-    }
-
-    @RemovableInRelease
-    private void logBundle(String message, Bundle bundle) {
-        Log.d(TAG, message + bundleToString(bundle));
-    }
-
-    @RemovableInRelease
-    private void logControlRequestError(Intent intent, String message, Bundle data) {
-        // The intent may contain some PII so we don't want to log it in the released
-        // version by default.
-        Log.e(TAG, String.format(
-                "Error sending control request %s %s. Data: %s Error: %s", intent,
-                bundleToString(intent.getExtras()), bundleToString(data), message));
-    }
-
-    @RemovableInRelease
-    private void logExtraHttpInfo(Bundle extras) {
-        if (extras != null) {
-            if (extras.containsKey(MediaItemStatus.EXTRA_HTTP_STATUS_CODE)) {
-                int httpStatus = extras.getInt(MediaItemStatus.EXTRA_HTTP_STATUS_CODE);
-                Log.d(TAG, "HTTP status: %s", httpStatus);
-            }
-            if (extras.containsKey(MediaItemStatus.EXTRA_HTTP_RESPONSE_HEADERS)) {
-                Bundle headers = extras.getBundle(MediaItemStatus.EXTRA_HTTP_RESPONSE_HEADERS);
-                Log.d(TAG, "HTTP headers: %s", bundleToString(headers));
-            }
-        }
-    }
-
-    @RemovableInRelease
-    private void logIntent(String prefix, Intent intent) {
-        Log.d(TAG, prefix + intent + " extras: " + bundleToString(intent.getExtras()));
-    }
-
-    @RemovableInRelease
-    private void logMediaSessionStatus(Bundle data) {
-        MediaSessionStatus status = MediaSessionStatus.fromBundle(
-                data.getBundle(MediaControlIntent.EXTRA_SESSION_STATUS));
-        int sessionState = status.getSessionState();
-        Log.d(TAG, "Session state after ending session: %s", sessionState);
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/remote/ExpandedControllerActivity.java b/app/src/main/java/org/chromium/chrome/browser/media/remote/ExpandedControllerActivity.java
index 017c3c6..959eb51 100644
--- a/app/src/main/java/org/chromium/chrome/browser/media/remote/ExpandedControllerActivity.java
+++ b/app/src/main/java/org/chromium/chrome/browser/media/remote/ExpandedControllerActivity.java
@@ -21,8 +21,6 @@ import android.view.WindowManager;
 import android.widget.ImageView;
 import android.widget.TextView;
 
-import com.google.android.gms.cast.CastMediaControlIntent;
-
 import org.chromium.chrome.R;
 import org.chromium.chrome.browser.media.remote.RemoteVideoInfo.PlayerState;
 import org.chromium.chrome.browser.metrics.MediaNotificationUma;
@@ -285,7 +283,6 @@ public class ExpandedControllerActivity
 
     @Override
     public void onError(int error, String message) {
-        if (error == CastMediaControlIntent.ERROR_CODE_SESSION_START_FAILED) finish();
     }
 
     @Override
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/remote/MediaUrlResolver.java b/app/src/main/java/org/chromium/chrome/browser/media/remote/MediaUrlResolver.java
deleted file mode 100644
index d78410e..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/remote/MediaUrlResolver.java
+++ /dev/null
@@ -1,268 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.remote;
-
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.text.TextUtils;
-
-import org.chromium.base.Log;
-import org.chromium.base.VisibleForTesting;
-import org.chromium.base.metrics.RecordHistogram;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.net.URLStreamHandler;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-
-/**
- * Resolves the final URL if it's a redirect. Works asynchronously, uses HTTP
- * HEAD request to determine if the URL is redirected.
- */
-public class MediaUrlResolver extends AsyncTask<Void, Void, MediaUrlResolver.Result> {
-
-    // Cast.Sender.UrlResolveResult UMA histogram values; must match values of
-    // RemotePlaybackUrlResolveResult in histograms.xml. Do not change these values, as they are
-    // being used in UMA.
-    private static final int RESOLVE_RESULT_SUCCESS = 0;
-    private static final int RESOLVE_RESULT_MALFORMED_URL = 1;
-    private static final int RESOLVE_RESULT_NO_CORS = 2;
-    private static final int RESOLVE_RESULT_INCOMPATIBLE_CORS = 3;
-    private static final int RESOLVE_RESULT_SERVER_ERROR = 4;
-    private static final int RESOLVE_RESULT_NETWORK_ERROR = 5;
-    private static final int RESOLVE_RESULT_UNSUPPORTED_MEDIA = 6;
-    private static final int RESOLVE_RESULT_HUC_EXCEPTION = 7;
-
-    // Range of histogram.
-    private static final int HISTOGRAM_RESULT_COUNT = 8;
-
-    // Acceptal response codes for URL resolving request.
-    private static final Integer[] SUCCESS_RESPONSE_CODES = {
-        // Request succeeded.
-        HttpURLConnection.HTTP_OK,
-        HttpURLConnection.HTTP_PARTIAL,
-
-        // HttpURLConnection only follows up to 5 redirects, this response is unlikely but possible.
-        HttpURLConnection.HTTP_MOVED_PERM,
-        HttpURLConnection.HTTP_MOVED_TEMP,
-    };
-
-    /**
-     * The interface to get the initial URI with cookies from and pass the final
-     * URI to.
-     */
-    public interface Delegate {
-        /**
-         * @return the original URL to resolve.
-         */
-        Uri getUri();
-
-        /**
-         * @return the cookies to fetch the URL with.
-         */
-        String getCookies();
-
-        /**
-         * Passes the resolved URL to the delegate.
-         *
-         * @param uri the resolved URL.
-         */
-        void deliverResult(Uri uri, boolean palyable);
-    }
-
-
-    protected static final class Result {
-        private final Uri mUri;
-        private final boolean mPlayable;
-
-        public Result(Uri uri, boolean playable) {
-            mUri = uri;
-            mPlayable = playable;
-        }
-
-        public Uri getUri() {
-            return mUri;
-        }
-
-        public boolean isPlayable() {
-            return mPlayable;
-        }
-    }
-
-    private static final String TAG = "MediaFling";
-
-    private static final String COOKIES_HEADER_NAME = "Cookies";
-    private static final String USER_AGENT_HEADER_NAME = "User-Agent";
-    private static final String ORIGIN_HEADER_NAME = "Origin";
-    private static final String RANGE_HEADER_NAME = "Range";
-    private static final String CORS_HEADER_NAME = "Access-Control-Allow-Origin";
-
-    private static final String CHROMECAST_ORIGIN = "https://www.gstatic.com";
-
-    // Media types supported for cast, see
-    // media/base/container_names.h for the actual enum where these are defined.
-    // See https://developers.google.com/cast/docs/media#media-container-formats for the formats
-    // supported by Cast devices.
-    private static final int MEDIA_TYPE_UNKNOWN = 0;
-    private static final int MEDIA_TYPE_AAC = 1;
-    private static final int MEDIA_TYPE_HLS = 22;
-    private static final int MEDIA_TYPE_MP3 = 26;
-    private static final int MEDIA_TYPE_MPEG4 = 29;
-    private static final int MEDIA_TYPE_OGG = 30;
-    private static final int MEDIA_TYPE_WAV = 35;
-    private static final int MEDIA_TYPE_WEBM = 36;
-    private static final int MEDIA_TYPE_DASH = 38;
-    private static final int MEDIA_TYPE_SMOOTHSTREAM = 39;
-
-    // We don't want to necessarily fetch the whole video but we don't want to miss the CORS header.
-    // Assume that 64k should be more than enough to keep all the headers.
-    private static final String RANGE_HEADER_VALUE = "bytes=0-65536";
-
-    private final Delegate mDelegate;
-
-    private final String mUserAgent;
-    private final URLStreamHandler mStreamHandler;
-
-    /**
-     * The constructor
-     * @param delegate The customer for this URL resolver.
-     * @param userAgent The browser user agent
-     */
-    public MediaUrlResolver(Delegate delegate, String userAgent) {
-        this(delegate, userAgent, null);
-    }
-
-    @VisibleForTesting
-    MediaUrlResolver(Delegate delegate, String userAgent, URLStreamHandler streamHandler) {
-        mDelegate = delegate;
-        mUserAgent = userAgent;
-        mStreamHandler = streamHandler;
-    }
-
-    @Override
-    protected MediaUrlResolver.Result doInBackground(Void... params) {
-        Uri uri = mDelegate.getUri();
-        if (uri == null || uri.equals(Uri.EMPTY)) {
-            return new MediaUrlResolver.Result(Uri.EMPTY, false);
-        }
-        String cookies = mDelegate.getCookies();
-
-        Map<String, List<String>> headers = null;
-        HttpURLConnection urlConnection = null;
-        try {
-            URL requestUrl = new URL(null, uri.toString(), mStreamHandler);
-            urlConnection = (HttpURLConnection) requestUrl.openConnection();
-            if (!TextUtils.isEmpty(cookies)) {
-                urlConnection.setRequestProperty(COOKIES_HEADER_NAME, cookies);
-            }
-
-            // Pretend that this is coming from the Chromecast.
-            urlConnection.setRequestProperty(ORIGIN_HEADER_NAME, CHROMECAST_ORIGIN);
-            urlConnection.setRequestProperty(USER_AGENT_HEADER_NAME, mUserAgent);
-            if (!isEnhancedMedia(uri)) {
-                // Manifest files are typically smaller than 64K so range request can fail.
-                urlConnection.setRequestProperty(RANGE_HEADER_NAME, RANGE_HEADER_VALUE);
-            }
-
-            // This triggers resolving the URL and receiving the headers.
-            headers = urlConnection.getHeaderFields();
-
-            uri = Uri.parse(urlConnection.getURL().toString());
-
-            // If server's response is not valid, don't try to fling the video.
-            int responseCode = urlConnection.getResponseCode();
-            if (!Arrays.asList(SUCCESS_RESPONSE_CODES).contains(responseCode)) {
-                recordResultHistogram(RESOLVE_RESULT_SERVER_ERROR);
-                Log.e(TAG, "Server response is not valid: %d", responseCode);
-                uri = Uri.EMPTY;
-            }
-        } catch (IOException e) {
-            recordResultHistogram(RESOLVE_RESULT_NETWORK_ERROR);
-            Log.e(TAG, "Failed to fetch the final url", e);
-            uri = Uri.EMPTY;
-        } catch (ArrayIndexOutOfBoundsException | NullPointerException e) {
-            recordResultHistogram(RESOLVE_RESULT_HUC_EXCEPTION);
-            Log.e(TAG, "Threading issue with HUC, see https://crbug.com/754480", e);
-            uri = Uri.EMPTY;
-        } finally {
-            if (urlConnection != null) urlConnection.disconnect();
-        }
-        return new MediaUrlResolver.Result(uri, canPlayMedia(uri, headers));
-    }
-
-    @Override
-    protected void onPostExecute(MediaUrlResolver.Result result) {
-        mDelegate.deliverResult(result.getUri(), result.isPlayable());
-    }
-
-    private boolean canPlayMedia(Uri uri, Map<String, List<String>> headers) {
-        if (uri == null || uri.equals(Uri.EMPTY)) {
-            recordResultHistogram(RESOLVE_RESULT_MALFORMED_URL);
-            return false;
-        }
-
-        if (headers != null && headers.containsKey(CORS_HEADER_NAME)) {
-            // Check that the CORS data is valid for Chromecast
-            List<String> corsData = headers.get(CORS_HEADER_NAME);
-            if (corsData.isEmpty() || (!corsData.get(0).equals("*")
-                    && !corsData.get(0).equals(CHROMECAST_ORIGIN))) {
-                recordResultHistogram(RESOLVE_RESULT_INCOMPATIBLE_CORS);
-                return false;
-            }
-        } else if (isEnhancedMedia(uri)) {
-            // HLS media requires CORS headers.
-            // TODO(avayvod): it actually requires CORS on the final video URLs vs the manifest.
-            // Clank assumes that if CORS is set for the manifest it's set for everything but
-            // it not necessary always true. See b/19138712
-            Log.d(TAG, "HLS stream without CORS header: %s", uri);
-            recordResultHistogram(RESOLVE_RESULT_NO_CORS);
-            return false;
-        }
-
-        if (getMediaType(uri) == MEDIA_TYPE_UNKNOWN) {
-            Log.d(TAG, "Unsupported media container format: %s", uri);
-            recordResultHistogram(RESOLVE_RESULT_UNSUPPORTED_MEDIA);
-            return false;
-        }
-
-        recordResultHistogram(RESOLVE_RESULT_SUCCESS);
-        return true;
-    }
-
-    private boolean isEnhancedMedia(Uri uri) {
-        int mediaType = getMediaType(uri);
-        return mediaType == MEDIA_TYPE_HLS
-                || mediaType == MEDIA_TYPE_DASH
-                || mediaType == MEDIA_TYPE_SMOOTHSTREAM;
-    }
-
-    @VisibleForTesting
-    void recordResultHistogram(int result) {
-        RecordHistogram.recordEnumeratedHistogram("Cast.Sender.UrlResolveResult", result,
-                HISTOGRAM_RESULT_COUNT);
-    }
-
-    static int getMediaType(Uri uri) {
-        String path = uri.getPath();
-
-        if (path == null) return MEDIA_TYPE_UNKNOWN;
-
-        path = path.toLowerCase(Locale.US);
-        if (path.endsWith(".m3u8")) return MEDIA_TYPE_HLS;
-        if (path.endsWith(".mp4")) return MEDIA_TYPE_MPEG4;
-        if (path.endsWith(".mpd")) return MEDIA_TYPE_DASH;
-        if (path.endsWith(".ism")) return MEDIA_TYPE_SMOOTHSTREAM;
-        if (path.endsWith(".m4a") || path.endsWith(".aac")) return MEDIA_TYPE_AAC;
-        if (path.endsWith(".mp3")) return MEDIA_TYPE_MP3;
-        if (path.endsWith(".wav")) return MEDIA_TYPE_WAV;
-        if (path.endsWith(".webm")) return MEDIA_TYPE_WEBM;
-        if (path.endsWith(".ogg")) return MEDIA_TYPE_OGG;
-        return MEDIA_TYPE_UNKNOWN;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/remote/PositionExtrapolator.java b/app/src/main/java/org/chromium/chrome/browser/media/remote/PositionExtrapolator.java
deleted file mode 100644
index 455401b..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/remote/PositionExtrapolator.java
+++ /dev/null
@@ -1,122 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.remote;
-
-import android.os.SystemClock;
-
-/**
- * Class for extrapolating current playback position. The class occasionally receives updated
- * playback position information from the MediaRoute, and extrapolates the current playback
- * position.
- */
-public class PositionExtrapolator {
-    private static final String TAG = "MediaFling";
-
-    private long mDuration;
-    private long mLastKnownPosition;
-    private long mTimestamp;
-    private boolean mIsPlaying;
-
-    public PositionExtrapolator() {
-        mDuration = 0;
-        mLastKnownPosition = 0;
-        mTimestamp = 0;
-        mIsPlaying = false;
-    }
-
-    /**
-     * Clears the duration and timestamp.
-     */
-    public void clear() {
-        // Note: do not clear the stream position, since this is still needed so
-        // that we can reset the local stream position to match.
-        mDuration = 0;
-        mTimestamp = 0;
-    }
-
-    /**
-     * Update the extrapolator with the latest position info.
-     * @param duration The new duration.
-     * @param position The new playback position.
-     * @param timestamp The time stamp of this info, must be directly or indirectly aquired via
-     * {@link SystemClock.elapsedRealtime()}. The time stamp from the Cast receiver uses
-     * elapsedRealtime, so it can be used here. Don't use {@link SystemClock.uptimeMillis()} since
-     * it doesn't include the device sleep time.
-     */
-    public void onPositionInfoUpdated(
-            long duration, long position, long timestamp) {
-        mDuration = Math.max(duration, 0);
-        mLastKnownPosition = Math.min(mDuration, Math.max(position, 0));
-        mTimestamp = timestamp;
-    }
-
-    /**
-     * Must be called whenever the remote playback is paused. If the playback
-     * state changes from playing to paused, the last known stream position will be updated by the
-     * extrapolated value.
-     */
-    public void onPaused() {
-        if (!mIsPlaying) return;
-
-        long elapsedTime = SystemClock.elapsedRealtime();
-        onPositionInfoUpdated(mDuration, getPositionWithElapsedTime(elapsedTime), elapsedTime);
-
-        mIsPlaying = false;
-    }
-
-    /**
-     * Must be called whenever the remote playback resumes. If the playback state changes from
-     * paused to playing, the timestamp will be updated by the current {@link
-     * SystemClock.elapsedRealtime()}.
-     */
-    public void onResumed() {
-        if (mIsPlaying) return;
-
-        onPositionInfoUpdated(mDuration, mLastKnownPosition, SystemClock.elapsedRealtime());
-        mIsPlaying = true;
-    }
-
-    /**
-     * Must be called whenever the remote playback is finished. The last known position will be
-     * updated by the duration.
-     */
-    public void onFinished() {
-        onPositionInfoUpdated(mDuration, mDuration, SystemClock.elapsedRealtime());
-        mIsPlaying = false;
-    }
-
-    /**
-     * Must be called whenever the remote playback is seeking. The last known position will be
-     * updated by the position to be seeked to, and the extrapolator will assume the playback is
-     * paused during seeking.
-     * @param position The position to seek to.
-     */
-    public void onSeek(long position) {
-        onPositionInfoUpdated(mDuration, position, SystemClock.elapsedRealtime());
-        mIsPlaying = false;
-    }
-
-    /**
-     * @return The current playback position.
-     */
-    public long getPosition() {
-        return getPositionWithElapsedTime(SystemClock.elapsedRealtime());
-    }
-
-    /**
-     * @return The duration of the remote media.
-     */
-    public long getDuration() {
-        return mDuration;
-    }
-
-    private long getPositionWithElapsedTime(long elapsedTime) {
-        if ((mTimestamp == 0) || !mIsPlaying || mLastKnownPosition >= mDuration) {
-            return mLastKnownPosition;
-        }
-
-        return Math.min(mLastKnownPosition + (elapsedTime - mTimestamp), mDuration);
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/remote/RemoteMediaPlayerController.java b/app/src/main/java/org/chromium/chrome/browser/media/remote/RemoteMediaPlayerController.java
index 3fb5d57..0529c18 100644
--- a/app/src/main/java/org/chromium/chrome/browser/media/remote/RemoteMediaPlayerController.java
+++ b/app/src/main/java/org/chromium/chrome/browser/media/remote/RemoteMediaPlayerController.java
@@ -18,8 +18,6 @@ import android.support.v7.app.MediaRouteChooserDialogFragment;
 import android.support.v7.app.MediaRouteControllerDialogFragment;
 import android.support.v7.app.MediaRouteDialogFactory;
 
-import com.google.android.gms.cast.CastMediaControlIntent;
-
 import org.chromium.base.ApplicationStatus;
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
@@ -168,12 +166,6 @@ public class RemoteMediaPlayerController implements MediaRouteController.UiListe
         controller.addUiListener(this);
     }
 
-    /**
-     * Called when a lower layer requests that a video be cast. This will typically be a request
-     * from Blink when the cast button is pressed on the default video controls.
-     * @param player the player for which cast is being requested
-     * @param frameUrl the URL of the frame containing the video, needed for YouTube videos
-     */
     public void requestRemotePlayback(
             MediaRouteController.MediaStateListener player, MediaRouteController controller) {
         Activity currentActivity = ApplicationStatus.getLastTrackedFocusedActivity();
@@ -283,9 +275,6 @@ public class RemoteMediaPlayerController implements MediaRouteController.UiListe
 
     @Override
     public void onError(int error, String errorMessage) {
-        if (error == CastMediaControlIntent.ERROR_CODE_SESSION_START_FAILED) {
-            showMessageToast(errorMessage);
-        }
     }
 
     @Override
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/remote/RemoteMediaPlayerWrapper.java b/app/src/main/java/org/chromium/chrome/browser/media/remote/RemoteMediaPlayerWrapper.java
deleted file mode 100644
index b174633..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/remote/RemoteMediaPlayerWrapper.java
+++ /dev/null
@@ -1,159 +0,0 @@
-// Copyright 2018 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.remote;
-
-import com.google.android.gms.cast.CastDevice;
-import com.google.android.gms.cast.MediaInfo;
-import com.google.android.gms.cast.MediaStatus;
-import com.google.android.gms.cast.RemoteMediaPlayer;
-import com.google.android.gms.common.api.GoogleApiClient;
-
-import org.chromium.chrome.browser.media.router.MediaController;
-import org.chromium.chrome.browser.media.router.cast.CastSessionUtil;
-import org.chromium.chrome.browser.media.ui.MediaNotificationInfo;
-import org.chromium.chrome.browser.media.ui.MediaNotificationManager;
-
-/**
- * A wrapper around a RemoteMediaPlayer that exposes simple playback commands without the
- * the complexities of the GMS cast calls.
- */
-public class RemoteMediaPlayerWrapper implements RemoteMediaPlayer.OnMetadataUpdatedListener,
-                                                 RemoteMediaPlayer.OnStatusUpdatedListener,
-                                                 MediaController {
-    private final CastDevice mCastDevice;
-
-    private GoogleApiClient mApiClient;
-    private RemoteMediaPlayer mMediaPlayer;
-    private MediaNotificationInfo.Builder mNotificationBuilder;
-
-    public RemoteMediaPlayerWrapper(GoogleApiClient apiClient,
-            MediaNotificationInfo.Builder notificationBuilder, CastDevice castDevice) {
-        mApiClient = apiClient;
-        mCastDevice = castDevice;
-        mNotificationBuilder = notificationBuilder;
-
-        mMediaPlayer = new RemoteMediaPlayer();
-        mMediaPlayer.setOnStatusUpdatedListener(this);
-        mMediaPlayer.setOnMetadataUpdatedListener(this);
-
-        updateNotificationMetadata();
-    }
-
-    private void updateNotificationMetadata() {
-        CastSessionUtil.setNotificationMetadata(mNotificationBuilder, mCastDevice, mMediaPlayer);
-        MediaNotificationManager.show(mNotificationBuilder.build());
-    }
-
-    private boolean canSendCommand() {
-        return mApiClient != null && mMediaPlayer != null && mApiClient.isConnected();
-    }
-
-    // RemoteMediaPlayer.OnStatusUpdatedListener implementation.
-    @Override
-    public void onStatusUpdated() {
-        MediaStatus mediaStatus = mMediaPlayer.getMediaStatus();
-        if (mediaStatus == null) return;
-
-        int playerState = mediaStatus.getPlayerState();
-        if (playerState == MediaStatus.PLAYER_STATE_PAUSED
-                || playerState == MediaStatus.PLAYER_STATE_PLAYING) {
-            mNotificationBuilder.setPaused(playerState != MediaStatus.PLAYER_STATE_PLAYING);
-            mNotificationBuilder.setActions(
-                    MediaNotificationInfo.ACTION_STOP | MediaNotificationInfo.ACTION_PLAY_PAUSE);
-        } else {
-            mNotificationBuilder.setActions(MediaNotificationInfo.ACTION_STOP);
-        }
-        MediaNotificationManager.show(mNotificationBuilder.build());
-    }
-
-    // RemoteMediaPlayer.OnMetadataUpdatedListener implementation.
-    @Override
-    public void onMetadataUpdated() {
-        updateNotificationMetadata();
-    }
-
-    /**
-     * Forwards the message to the underlying RemoteMediaPlayer.
-     */
-    public void onMediaMessage(String message) {
-        if (mMediaPlayer != null)
-            mMediaPlayer.onMessageReceived(mCastDevice, CastSessionUtil.MEDIA_NAMESPACE, message);
-    }
-
-    /**
-     * Starts loading the provided media URL, without autoplay.
-     */
-    public void load(String mediaUrl) {
-        if (!canSendCommand()) return;
-
-        MediaInfo.Builder mediaInfoBuilder =
-                new MediaInfo.Builder(mediaUrl).setContentType("*/*").setStreamType(
-                        MediaInfo.STREAM_TYPE_BUFFERED);
-
-        mMediaPlayer.load(mApiClient, mediaInfoBuilder.build(), /* autoplay */ false);
-    }
-
-    /**
-     * Starts playback. No-op if are not in a valid state.
-     * Doesn't verify the command's success/failure.
-     */
-    @Override
-    public void play() {
-        if (!canSendCommand()) return;
-
-        mMediaPlayer.play(mApiClient);
-    }
-
-    /**
-     * Pauses playback. No-op if are not in a valid state.
-     * Doesn't verify the command's success/failure.
-     */
-    @Override
-    public void pause() {
-        if (!canSendCommand()) return;
-
-        mMediaPlayer.pause(mApiClient);
-    }
-
-    /**
-     * Sets the mute state. Does not affect the stream volume.
-     * No-op if are not in a valid state. Doesn't verify the command's success/failure.
-     */
-    @Override
-    public void setMute(boolean mute) {
-        if (!canSendCommand()) return;
-
-        mMediaPlayer.setStreamMute(mApiClient, mute);
-    }
-
-    /**
-     * Sets the stream volume. Does not affect the mute state.
-     * No-op if are not in a valid state. Doesn't verify the command's success/failure.
-     */
-    @Override
-    public void setVolume(double volume) {
-        if (!canSendCommand()) return;
-
-        mMediaPlayer.setStreamVolume(mApiClient, volume);
-    }
-
-    /**
-     * Seeks to the given position (in milliseconds).
-     * No-op if are not in a valid state. Doesn't verify the command's success/failure.
-     */
-    @Override
-    public void seek(long position) {
-        if (!canSendCommand()) return;
-
-        mMediaPlayer.seek(mApiClient, position);
-    }
-
-    /**
-     * Called when the session has stopped, and we should no longer send commands.
-     */
-    public void clearApiClient() {
-        mApiClient = null;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/ChromeMediaRouter.java b/app/src/main/java/org/chromium/chrome/browser/media/router/ChromeMediaRouter.java
index 381b7b6..c5e4e73 100644
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/ChromeMediaRouter.java
+++ b/app/src/main/java/org/chromium/chrome/browser/media/router/ChromeMediaRouter.java
@@ -13,10 +13,7 @@ import org.chromium.base.SysUtils;
 import org.chromium.base.VisibleForTesting;
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.base.annotations.JNINamespace;
-import org.chromium.chrome.browser.media.router.cast.CastMediaRouteProvider;
 import org.chromium.chrome.browser.media.router.cast.MediaSink;
-import org.chromium.chrome.browser.media.router.cast.MediaSource;
-import org.chromium.chrome.browser.media.router.cast.remoting.RemotingMediaRouteProvider;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -38,12 +35,6 @@ public class ChromeMediaRouter implements MediaRouteManager {
             new MediaRouteProvider.Factory() {
                 @Override
                 public void addProviders(MediaRouteManager manager) {
-                    MediaRouteProvider castProvider = CastMediaRouteProvider.create(manager);
-                    manager.addMediaRouteProvider(castProvider);
-
-                    MediaRouteProvider remotingProvider =
-                            RemotingMediaRouteProvider.create(manager);
-                    manager.addMediaRouteProvider(remotingProvider);
                 }
             };
 
@@ -261,17 +252,6 @@ public class ChromeMediaRouter implements MediaRouteManager {
         return getSink(sourceUrn, index).getName();
     }
 
-    /**
-     * Initiates route creation with the given parameters. Notifies the native client of success
-     * and failure.
-     * @param sourceId the id of the {@link MediaSource} to route to the sink.
-     * @param sinkId the id of the {@link MediaSink} to route the source to.
-     * @param presentationId the id of the presentation to be used by the page.
-     * @param origin the origin of the frame requesting a new route.
-     * @param tabId the id of the tab the requesting frame belongs to.
-     * @param isIncognito whether the route is being requested from an Incognito profile.
-     * @param requestId the id of the route creation request tracked by the native side.
-     */
     @CalledByNative
     public void createRoute(
             String sourceId,
@@ -292,16 +272,6 @@ public class ChromeMediaRouter implements MediaRouteManager {
                 sourceId, sinkId, presentationId, origin, tabId, isIncognito, requestId);
     }
 
-    /**
-     * Initiates route joining with the given parameters. Notifies the native client of success
-     * or failure.
-     * @param sourceId the id of the {@link MediaSource} to route to the sink.
-     * @param sinkId the id of the {@link MediaSink} to route the source to.
-     * @param presentationId the id of the presentation to be used by the page.
-     * @param origin the origin of the frame requesting a new route.
-     * @param tabId the id of the tab the requesting frame belongs to.
-     * @param requestId the id of the route creation request tracked by the native side.
-     */
     @CalledByNative
     public void joinRoute(
             String sourceId,
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/ChromeMediaRouterDialogController.java b/app/src/main/java/org/chromium/chrome/browser/media/router/ChromeMediaRouterDialogController.java
index 8617b53..e8063d1 100644
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/ChromeMediaRouterDialogController.java
+++ b/app/src/main/java/org/chromium/chrome/browser/media/router/ChromeMediaRouterDialogController.java
@@ -10,10 +10,7 @@ import android.support.v7.media.MediaRouteSelector;
 
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.base.annotations.JNINamespace;
-import org.chromium.chrome.browser.media.router.cast.CastMediaSource;
 import org.chromium.chrome.browser.media.router.cast.MediaSink;
-import org.chromium.chrome.browser.media.router.cast.MediaSource;
-import org.chromium.chrome.browser.media.router.cast.remoting.RemotingMediaSource;
 
 /**
  * Implements the JNI interface called from the C++ Media Router dialog controller implementation
@@ -44,26 +41,7 @@ public class ChromeMediaRouterDialogController implements MediaRouteDialogDelega
      */
     @CalledByNative
     public void openRouteChooserDialog(String[] sourceUrns) {
-        if (isShowingDialog()) return;
-
-        MediaSource source = null;
-        for (String sourceUrn : sourceUrns) {
-            source = CastMediaSource.from(sourceUrn);
-            if (source == null) source = RemotingMediaSource.from(sourceUrn);
-
-            if (source != null) break;
-        }
-
-        MediaRouteSelector routeSelector = source == null ? null : source.buildRouteSelector();
-
-        if (routeSelector == null) {
-            nativeOnMediaSourceNotSupported(mNativeDialogController);
-            return;
-        }
-
-        mDialogManager =
-                new MediaRouteChooserDialogManager(source.getSourceId(), routeSelector, this);
-        mDialogManager.openDialog();
+        return;
     }
 
     /**
@@ -73,21 +51,7 @@ public class ChromeMediaRouterDialogController implements MediaRouteDialogDelega
      */
     @CalledByNative
     public void openRouteControllerDialog(String sourceUrn, String mediaRouteId) {
-        if (isShowingDialog()) return;
-
-        MediaSource source = CastMediaSource.from(sourceUrn);
-        if (source == null) source = RemotingMediaSource.from(sourceUrn);
-
-        MediaRouteSelector routeSelector = source == null ? null : source.buildRouteSelector();
-
-        if (routeSelector == null) {
-            nativeOnMediaSourceNotSupported(mNativeDialogController);
-            return;
-        }
-
-        mDialogManager = new MediaRouteControllerDialogManager(
-                source.getSourceId(), routeSelector, mediaRouteId, this);
-        mDialogManager.openDialog();
+        return;
     }
 
     /**
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/BaseMediaRouteProvider.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/BaseMediaRouteProvider.java
deleted file mode 100644
index af6c32d..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/BaseMediaRouteProvider.java
+++ /dev/null
@@ -1,231 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.os.Handler;
-import android.support.v7.media.MediaRouteSelector;
-import android.support.v7.media.MediaRouter;
-import android.support.v7.media.MediaRouter.RouteInfo;
-
-import org.chromium.base.Log;
-import org.chromium.chrome.browser.media.router.DiscoveryDelegate;
-import org.chromium.chrome.browser.media.router.MediaController;
-import org.chromium.chrome.browser.media.router.MediaRoute;
-import org.chromium.chrome.browser.media.router.MediaRouteManager;
-import org.chromium.chrome.browser.media.router.MediaRouteProvider;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
-
-/**
- * A {@link BaseMediaRouteProvider} common implementation for MediaRouteProviders.
- */
-public abstract class BaseMediaRouteProvider
-        implements MediaRouteProvider, DiscoveryDelegate,
-                   ChromeCastSessionManager.CastSessionManagerListener {
-    private static final String TAG = "MediaRouter";
-
-    protected static final List<MediaSink> NO_SINKS = Collections.emptyList();
-
-    protected final MediaRouter mAndroidMediaRouter;
-    protected final MediaRouteManager mManager;
-    protected final Map<String, DiscoveryCallback> mDiscoveryCallbacks =
-            new HashMap<String, DiscoveryCallback>();
-    protected final Map<String, MediaRoute> mRoutes = new HashMap<String, MediaRoute>();
-    protected Handler mHandler = new Handler();
-
-    // There can be only one Cast session at the same time on Android.
-    protected CastSession mSession;
-
-    protected BaseMediaRouteProvider(MediaRouter androidMediaRouter, MediaRouteManager manager) {
-        mAndroidMediaRouter = androidMediaRouter;
-        mManager = manager;
-    }
-
-    /**
-     * @return A MediaSource object constructed from |sourceId|, or null if the derived class does
-     * not support the source.
-     */
-    @Nullable
-    protected abstract MediaSource getSourceFromId(@Nonnull String sourceId);
-
-    /**
-     * @return A CastSessionLaunchRequest encapsulating a session launch request.
-     */
-    @Nullable
-    protected abstract ChromeCastSessionManager.CastSessionLaunchRequest createSessionLaunchRequest(
-            MediaSource source, MediaSink sink, String presentationId, String origin, int tabId,
-            boolean isIncognito, int nativeRequestId);
-
-    /**
-     * Forward the sinks back to the native counterpart.
-     */
-    protected void onSinksReceivedInternal(String sourceId, @Nonnull List<MediaSink> sinks) {
-        Log.d(TAG, "Reporting %d sinks for source: %s", sinks.size(), sourceId);
-        mManager.onSinksReceived(sourceId, this, sinks);
-    }
-
-    /**
-     * {@link DiscoveryDelegate} implementation.
-     */
-    @Override
-    public void onSinksReceived(String sourceId, @Nonnull List<MediaSink> sinks) {
-        Log.d(TAG, "Received %d sinks for sourceId: %s", sinks.size(), sourceId);
-        mHandler.post(() -> { onSinksReceivedInternal(sourceId, sinks); });
-    }
-
-    /**
-     * {@link MediaRouteProvider} implementation.
-     */
-    @Override
-    public boolean supportsSource(@Nonnull String sourceId) {
-        return getSourceFromId(sourceId) != null;
-    }
-
-    @Override
-    public void startObservingMediaSinks(@Nonnull String sourceId) {
-        Log.d(TAG, "startObservingMediaSinks: " + sourceId);
-
-        if (mAndroidMediaRouter == null) {
-            // If the MediaRouter API is not available, report no devices so the page doesn't even
-            // try to cast.
-            onSinksReceived(sourceId, NO_SINKS);
-            return;
-        }
-
-        MediaSource source = getSourceFromId(sourceId);
-        if (source == null) {
-            // If the source is invalid or not supported by this provider, report no devices
-            // available.
-            onSinksReceived(sourceId, NO_SINKS);
-            return;
-        }
-
-        // No-op, if already monitoring the application for this source.
-        String applicationId = source.getApplicationId();
-        DiscoveryCallback callback = mDiscoveryCallbacks.get(applicationId);
-        if (callback != null) {
-            callback.addSourceUrn(sourceId);
-            return;
-        }
-
-        MediaRouteSelector routeSelector = source.buildRouteSelector();
-        if (routeSelector == null) {
-            // If the application invalid, report no devices available.
-            onSinksReceived(sourceId, NO_SINKS);
-            return;
-        }
-
-        List<MediaSink> knownSinks = new ArrayList<MediaSink>();
-        for (RouteInfo route : mAndroidMediaRouter.getRoutes()) {
-            if (route.matchesSelector(routeSelector)) {
-                knownSinks.add(MediaSink.fromRoute(route));
-            }
-        }
-
-        callback = new DiscoveryCallback(sourceId, knownSinks, this, routeSelector);
-        mAndroidMediaRouter.addCallback(
-                routeSelector, callback, MediaRouter.CALLBACK_FLAG_REQUEST_DISCOVERY);
-        mDiscoveryCallbacks.put(applicationId, callback);
-    }
-
-    @Override
-    public void stopObservingMediaSinks(@Nonnull String sourceId) {
-        Log.d(TAG, "stopObservingMediaSinks: " + sourceId);
-        if (mAndroidMediaRouter == null) return;
-
-        MediaSource source = getSourceFromId(sourceId);
-        if (source == null) return;
-
-        String applicationId = source.getApplicationId();
-        DiscoveryCallback callback = mDiscoveryCallbacks.get(applicationId);
-        if (callback == null) return;
-
-        callback.removeSourceUrn(sourceId);
-
-        if (callback.isEmpty()) {
-            mAndroidMediaRouter.removeCallback(callback);
-            mDiscoveryCallbacks.remove(applicationId);
-        }
-    }
-
-    @Override
-    public void createRoute(String sourceId, String sinkId, String presentationId, String origin,
-            int tabId, boolean isIncognito, int nativeRequestId) {
-        if (mAndroidMediaRouter == null) {
-            mManager.onRouteRequestError("Not supported", nativeRequestId);
-            return;
-        }
-
-        MediaSink sink = MediaSink.fromSinkId(sinkId, mAndroidMediaRouter);
-        if (sink == null) {
-            mManager.onRouteRequestError("No sink", nativeRequestId);
-            return;
-        }
-
-        MediaSource source = getSourceFromId(sourceId);
-        if (source == null) {
-            mManager.onRouteRequestError("Unsupported source URL", nativeRequestId);
-            return;
-        }
-
-        ChromeCastSessionManager.CastSessionLaunchRequest request = createSessionLaunchRequest(
-                source, sink, presentationId, origin, tabId, isIncognito, nativeRequestId);
-
-        ChromeCastSessionManager.get().requestSessionLaunch(request);
-    }
-
-    @Override
-    public abstract void joinRoute(
-            String sourceId, String presentationId, String origin, int tabId, int nativeRequestId);
-
-    @Override
-    public abstract void closeRoute(String routeId);
-
-    @Override
-    public abstract void detachRoute(String routeId);
-
-    @Override
-    public abstract void sendStringMessage(String routeId, String message, int nativeCallbackId);
-
-    // ChromeCastSessionObserver implementation.
-    @Override
-    public abstract void onSessionStarting(
-            ChromeCastSessionManager.CastSessionLaunchRequest originalRequest);
-
-    @Override
-    public abstract void onSessionEnded();
-
-    @Override
-    public void onSessionStartFailed() {
-        for (String routeId : mRoutes.keySet()) {
-            mManager.onRouteClosedWithError(routeId, "Launch error");
-        }
-        mRoutes.clear();
-    };
-
-    @Override
-    public void onSessionStarted(CastSession session) {
-        mSession = session;
-    }
-
-    @Override
-    public void onSessionStopAction() {
-        if (mSession == null) return;
-
-        for (String routeId : mRoutes.keySet()) closeRoute(routeId);
-    }
-
-    @Override
-    @Nullable
-    public MediaController getMediaController(String routeId) {
-        return null;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMediaRouteProvider.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMediaRouteProvider.java
deleted file mode 100644
index f8ee310..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMediaRouteProvider.java
+++ /dev/null
@@ -1,431 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.support.v7.media.MediaRouter;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import org.chromium.base.Log;
-import org.chromium.base.VisibleForTesting;
-import org.chromium.chrome.browser.media.router.ChromeMediaRouter;
-import org.chromium.chrome.browser.media.router.MediaRoute;
-import org.chromium.chrome.browser.media.router.MediaRouteManager;
-import org.chromium.chrome.browser.media.router.MediaRouteProvider;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-import javax.annotation.Nullable;
-
-/**
- * A {@link MediaRouteProvider} implementation for Cast devices and applications.
- */
-public class CastMediaRouteProvider extends BaseMediaRouteProvider {
-    private static final String TAG = "MediaRouter";
-
-    private static final String AUTO_JOIN_PRESENTATION_ID = "auto-join";
-    private static final String PRESENTATION_ID_SESSION_ID_PREFIX = "cast-session_";
-
-    private final CastMessageHandler mMessageHandler;
-    private ClientRecord mLastRemovedRouteRecord;
-    private final Map<String, ClientRecord> mClientRecords = new HashMap<String, ClientRecord>();
-
-    /**
-     * @return Initialized {@link CastMediaRouteProvider} object.
-     */
-    public static CastMediaRouteProvider create(MediaRouteManager manager) {
-        return new CastMediaRouteProvider(ChromeMediaRouter.getAndroidMediaRouter(), manager);
-    }
-
-    @Override
-    public void onSessionStartFailed() {
-        super.onSessionStartFailed();
-        mClientRecords.clear();
-    }
-
-    @Override
-    public void onSessionStarted(CastSession session) {
-        super.onSessionStarted(session);
-        mMessageHandler.onSessionCreated(mSession);
-    }
-
-    @Override
-    public void onSessionEnded() {
-        if (mSession == null) return;
-
-        if (mClientRecords.isEmpty()) {
-            for (String routeId : mRoutes.keySet()) mManager.onRouteClosed(routeId);
-            mRoutes.clear();
-        } else {
-            mLastRemovedRouteRecord = mClientRecords.values().iterator().next();
-            for (ClientRecord client : mClientRecords.values()) {
-                mManager.onRouteClosed(client.routeId);
-
-                mRoutes.remove(client.routeId);
-            }
-            mClientRecords.clear();
-        }
-
-        mSession = null;
-
-        if (mAndroidMediaRouter != null) {
-            mAndroidMediaRouter.selectRoute(mAndroidMediaRouter.getDefaultRoute());
-        }
-    }
-
-    public void onMessageSentResult(boolean success, int callbackId) {
-        mManager.onMessageSentResult(success, callbackId);
-    }
-
-    public void onMessage(String clientId, String message) {
-        ClientRecord clientRecord = mClientRecords.get(clientId);
-        if (clientRecord == null) return;
-
-        if (!clientRecord.isConnected) {
-            Log.d(TAG, "Queueing message to client %s: %s", clientId, message);
-            clientRecord.pendingMessages.add(message);
-            return;
-        }
-
-        Log.d(TAG, "Sending message to client %s: %s", clientId, message);
-        mManager.onMessage(clientRecord.routeId, message);
-    }
-
-    public CastMessageHandler getMessageHandler() {
-        return mMessageHandler;
-    }
-
-    public Set<String> getClients() {
-        return mClientRecords.keySet();
-    }
-
-    public Map<String, ClientRecord> getClientRecords() {
-        return mClientRecords;
-    }
-
-    @Override
-    protected MediaSource getSourceFromId(String sourceId) {
-        return CastMediaSource.from(sourceId);
-    }
-
-    @Override
-    protected ChromeCastSessionManager.CastSessionLaunchRequest createSessionLaunchRequest(
-            MediaSource source, MediaSink sink, String presentationId, String origin, int tabId,
-            boolean isIncognito, int nativeRequestId) {
-        return new CreateRouteRequest(source, sink, presentationId, origin, tabId, isIncognito,
-                nativeRequestId, this, CreateRouteRequest.RequestedCastSessionType.CAST,
-                mMessageHandler);
-    }
-
-    @Override
-    public void onSessionStarting(
-            ChromeCastSessionManager.CastSessionLaunchRequest sessionLaunchRequest) {
-        CreateRouteRequest request = (CreateRouteRequest) sessionLaunchRequest;
-        MediaSink sink = request.getSink();
-        MediaSource source = request.getSource();
-
-        MediaRoute route =
-                new MediaRoute(sink.getId(), source.getSourceId(), request.getPresentationId());
-        addRoute(route, request.getOrigin(), request.getTabId());
-        mManager.onRouteCreated(route.id, route.sinkId, request.getNativeRequestId(), this, true);
-
-        String clientId = ((CastMediaSource) source).getClientId();
-
-        if (clientId != null) {
-            ClientRecord clientRecord = mClientRecords.get(clientId);
-            if (clientRecord != null) {
-                sendReceiverAction(clientRecord.routeId, sink, clientId, "cast");
-            }
-        }
-    }
-
-    @Override
-    public void joinRoute(String sourceId, String presentationId, String origin, int tabId,
-            int nativeRequestId) {
-        CastMediaSource source = CastMediaSource.from(sourceId);
-        if (source == null || source.getClientId() == null) {
-            mManager.onRouteRequestError("Unsupported presentation URL", nativeRequestId);
-            return;
-        }
-
-        if (mSession == null) {
-            mManager.onRouteRequestError("No presentation", nativeRequestId);
-            return;
-        }
-
-        if (!canJoinExistingSession(presentationId, origin, tabId, source)) {
-            mManager.onRouteRequestError("No matching route", nativeRequestId);
-            return;
-        }
-
-        MediaRoute route = new MediaRoute(mSession.getSinkId(), sourceId, presentationId);
-        addRoute(route, origin, tabId);
-        mManager.onRouteCreated(route.id, route.sinkId, nativeRequestId, this, false);
-    }
-
-    @Override
-    public void closeRoute(String routeId) {
-        MediaRoute route = mRoutes.get(routeId);
-        if (route == null) return;
-
-        if (mSession == null) {
-            mRoutes.remove(routeId);
-            mManager.onRouteClosed(routeId);
-            return;
-        }
-
-        ClientRecord client = getClientRecordByRouteId(routeId);
-        if (client != null && mAndroidMediaRouter != null) {
-            MediaSink sink = MediaSink.fromSinkId(mSession.getSinkId(), mAndroidMediaRouter);
-            if (sink != null) sendReceiverAction(routeId, sink, client.clientId, "stop");
-        }
-
-        ChromeCastSessionManager.get().stopApplication();
-    }
-
-    @Override
-    public void detachRoute(String routeId) {
-        mRoutes.remove(routeId);
-
-        removeClient(getClientRecordByRouteId(routeId));
-    }
-
-    @Override
-    public void sendStringMessage(String routeId, String message, int nativeCallbackId) {
-        Log.d(TAG, "Received message from client: %s", message);
-
-        if (!mRoutes.containsKey(routeId)) {
-            mManager.onMessageSentResult(false, nativeCallbackId);
-            return;
-        }
-
-        boolean success = false;
-        try {
-            JSONObject jsonMessage = new JSONObject(message);
-
-            String messageType = jsonMessage.getString("type");
-            // TODO(zqzhang): Move the handling of "client_connect", "client_disconnect" and
-            // "leave_session" from CastMRP to CastMessageHandler. Also, need to have a
-            // ClientManager for client managing.
-            if ("client_connect".equals(messageType)) {
-                success = handleClientConnectMessage(jsonMessage);
-            } else if ("client_disconnect".equals(messageType)) {
-                success = handleClientDisconnectMessage(jsonMessage);
-            } else if ("leave_session".equals(messageType)) {
-                success = handleLeaveSessionMessage(jsonMessage);
-            } else if (mSession != null) {
-                success = mMessageHandler.handleSessionMessage(jsonMessage);
-            }
-        } catch (JSONException e) {
-            Log.e(TAG, "JSONException while handling internal message: " + e);
-            success = false;
-        }
-
-        mManager.onMessageSentResult(success, nativeCallbackId);
-    }
-
-    private boolean handleClientConnectMessage(JSONObject jsonMessage) throws JSONException {
-        String clientId = jsonMessage.getString("clientId");
-        if (clientId == null) return false;
-
-        ClientRecord clientRecord = mClientRecords.get(clientId);
-        if (clientRecord == null) return false;
-
-        clientRecord.isConnected = true;
-        if (mSession != null) mSession.onClientConnected(clientId);
-
-        if (clientRecord.pendingMessages.size() == 0) return true;
-        for (String message : clientRecord.pendingMessages) {
-            Log.d(TAG, "Deqeueing message for client %s: %s", clientId, message);
-            mManager.onMessage(clientRecord.routeId, message);
-        }
-        clientRecord.pendingMessages.clear();
-
-        return true;
-    }
-
-    private boolean handleClientDisconnectMessage(JSONObject jsonMessage) throws JSONException {
-        String clientId = jsonMessage.getString("clientId");
-        if (clientId == null) return false;
-
-        ClientRecord client = mClientRecords.get(clientId);
-        if (client == null) return false;
-
-        mRoutes.remove(client.routeId);
-        removeClient(client);
-
-        mManager.onRouteClosed(client.routeId);
-
-        return true;
-    }
-
-    private boolean handleLeaveSessionMessage(JSONObject jsonMessage) throws JSONException {
-        String clientId = jsonMessage.getString("clientId");
-        if (clientId == null || mSession == null) return false;
-
-        String sessionId = jsonMessage.getString("message");
-        if (!mSession.getSessionId().equals(sessionId)) return false;
-
-        ClientRecord leavingClient = mClientRecords.get(clientId);
-        if (leavingClient == null) return false;
-
-        int sequenceNumber = jsonMessage.optInt("sequenceNumber", -1);
-        onMessage(clientId, buildInternalMessage("leave_session", sequenceNumber, clientId, null));
-
-        // Send a "disconnect_session" message to all the clients that match with the leaving
-        // client's auto join policy.
-        for (ClientRecord client : mClientRecords.values()) {
-            if ((CastMediaSource.AUTOJOIN_TAB_AND_ORIGIN_SCOPED.equals(leavingClient.autoJoinPolicy)
-                        && isSameOrigin(client.origin, leavingClient.origin)
-                        && client.tabId == leavingClient.tabId)
-                    || (CastMediaSource.AUTOJOIN_ORIGIN_SCOPED.equals(leavingClient.autoJoinPolicy)
-                               && isSameOrigin(client.origin, leavingClient.origin))) {
-                onMessage(client.clientId,
-                        buildInternalMessage("disconnect_session", -1, client.clientId, sessionId));
-            }
-        }
-
-        return true;
-    }
-
-    private String buildInternalMessage(
-            String type, int sequenceNumber, String clientId, String message) throws JSONException {
-        JSONObject jsonMessage = new JSONObject();
-        jsonMessage.put("type", type);
-        jsonMessage.put("sequenceNumber", sequenceNumber);
-        jsonMessage.put("timeoutMillis", 0);
-        jsonMessage.put("clientId", clientId);
-        jsonMessage.put("message", message);
-        return jsonMessage.toString();
-    }
-
-    @VisibleForTesting
-    CastMediaRouteProvider(MediaRouter androidMediaRouter, MediaRouteManager manager) {
-        super(androidMediaRouter, manager);
-        mMessageHandler = new CastMessageHandler(this);
-    }
-
-    private boolean canAutoJoin(CastMediaSource source, String origin, int tabId) {
-        if (source.getAutoJoinPolicy().equals(CastMediaSource.AUTOJOIN_PAGE_SCOPED)) return false;
-
-        CastMediaSource currentSource = CastMediaSource.from(mSession.getSourceId());
-        if (!currentSource.getApplicationId().equals(source.getApplicationId())) return false;
-
-        ClientRecord client = null;
-        if (!mClientRecords.isEmpty()) {
-            client = mClientRecords.values().iterator().next();
-        } else if (mLastRemovedRouteRecord != null) {
-            client = mLastRemovedRouteRecord;
-            return isSameOrigin(origin, client.origin) && tabId == client.tabId;
-        }
-        if (client == null) return false;
-
-        boolean sameOrigin = isSameOrigin(origin, client.origin);
-        if (source.getAutoJoinPolicy().equals(CastMediaSource.AUTOJOIN_ORIGIN_SCOPED)) {
-            return sameOrigin;
-        } else if (source.getAutoJoinPolicy().equals(
-                           CastMediaSource.AUTOJOIN_TAB_AND_ORIGIN_SCOPED)) {
-            return sameOrigin && tabId == client.tabId;
-        }
-
-        return false;
-    }
-
-    private boolean canJoinExistingSession(
-            String presentationId, String origin, int tabId, CastMediaSource source) {
-        if (AUTO_JOIN_PRESENTATION_ID.equals(presentationId)) {
-            return canAutoJoin(source, origin, tabId);
-        } else if (presentationId.startsWith(PRESENTATION_ID_SESSION_ID_PREFIX)) {
-            String sessionId = presentationId.substring(PRESENTATION_ID_SESSION_ID_PREFIX.length());
-            if (mSession.getSessionId().equals(sessionId)) return true;
-        } else {
-            for (MediaRoute route : mRoutes.values()) {
-                if (route.presentationId.equals(presentationId)) return true;
-            }
-        }
-        return false;
-    }
-
-    @Nullable
-    private ClientRecord getClientRecordByRouteId(String routeId) {
-        for (ClientRecord record : mClientRecords.values()) {
-            if (record.routeId.equals(routeId)) return record;
-        }
-        return null;
-    }
-
-    @VisibleForTesting
-    void addRoute(MediaRoute route, String origin, int tabId) {
-        mRoutes.put(route.id, route);
-
-        CastMediaSource source = CastMediaSource.from(route.sourceId);
-        final String clientId = source.getClientId();
-
-        if (clientId == null || mClientRecords.get(clientId) != null) return;
-
-        mClientRecords.put(clientId,
-                new ClientRecord(
-                        route.id,
-                        clientId,
-                        source.getApplicationId(),
-                        source.getAutoJoinPolicy(),
-                        origin,
-                        tabId));
-    }
-
-    // TODO(zqzhang): Move this method to CastMessageHandler.
-    private void sendReceiverAction(
-            String routeId, MediaSink sink, String clientId, String action) {
-        try {
-            JSONObject jsonReceiver = new JSONObject();
-            jsonReceiver.put("label", sink.getId());
-            jsonReceiver.put("friendlyName", sink.getName());
-            jsonReceiver.put("capabilities", CastSessionImpl.getCapabilities(sink.getDevice()));
-            jsonReceiver.put("volume", null);
-            jsonReceiver.put("isActiveInput", null);
-            jsonReceiver.put("displayStatus", null);
-            jsonReceiver.put("receiverType", "cast");
-
-            JSONObject jsonReceiverAction = new JSONObject();
-            jsonReceiverAction.put("receiver", jsonReceiver);
-            jsonReceiverAction.put("action", action);
-
-            JSONObject json = new JSONObject();
-            json.put("type", "receiver_action");
-            json.put("sequenceNumber", -1);
-            json.put("timeoutMillis", 0);
-            json.put("clientId", clientId);
-            json.put("message", jsonReceiverAction);
-
-            onMessage(clientId, json.toString());
-        } catch (JSONException e) {
-            Log.e(TAG, "Failed to send receiver action message", e);
-        }
-    }
-
-    private void removeClient(@Nullable ClientRecord client) {
-        if (client == null) return;
-
-        mLastRemovedRouteRecord = client;
-        mClientRecords.remove(client.clientId);
-    }
-
-    /**
-     * Compares two origins. Empty origin strings correspond to unique origins in
-     * url::Origin.
-     *
-     * @param originA A URL origin.
-     * @param originB A URL origin.
-     * @return True if originA and originB represent the same origin, false otherwise.
-     */
-    private static final boolean isSameOrigin(String originA, String originB) {
-        if (originA == null || originA.isEmpty() || originB == null || originB.isEmpty())
-            return false;
-        return originA.equals(originB);
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMediaSource.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMediaSource.java
deleted file mode 100644
index f69d614..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMediaSource.java
+++ /dev/null
@@ -1,261 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.net.Uri;
-import android.support.v7.media.MediaRouteSelector;
-
-import com.google.android.gms.cast.CastMediaControlIntent;
-
-import java.util.Arrays;
-import java.util.List;
-
-import javax.annotation.Nullable;
-
-/**
- * Abstracts parsing the Cast application id and other parameters from the source ID.
- */
-public class CastMediaSource implements MediaSource {
-    public static final String AUTOJOIN_CUSTOM_CONTROLLER_SCOPED = "custom_controller_scoped";
-    public static final String AUTOJOIN_TAB_AND_ORIGIN_SCOPED = "tab_and_origin_scoped";
-    public static final String AUTOJOIN_ORIGIN_SCOPED = "origin_scoped";
-    public static final String AUTOJOIN_PAGE_SCOPED = "page_scoped";
-    private static final List<String> AUTOJOIN_POLICIES =
-            Arrays.asList(AUTOJOIN_CUSTOM_CONTROLLER_SCOPED, AUTOJOIN_TAB_AND_ORIGIN_SCOPED,
-                    AUTOJOIN_ORIGIN_SCOPED, AUTOJOIN_PAGE_SCOPED);
-
-    private static final String CAST_SOURCE_ID_SEPARATOR = "/";
-    private static final String CAST_SOURCE_ID_APPLICATION_ID = "__castAppId__";
-    private static final String CAST_SOURCE_ID_CLIENT_ID = "__castClientId__";
-    private static final String CAST_SOURCE_ID_AUTOJOIN_POLICY = "__castAutoJoinPolicy__";
-    private static final String CAST_APP_CAPABILITIES_PREFIX = "(";
-    private static final String CAST_APP_CAPABILITIES_SUFFIX = ")";
-    private static final String CAST_APP_CAPABILITIES_SEPARATOR = ",";
-    private static final List<String> CAST_APP_CAPABILITIES =
-            Arrays.asList("video_out", "audio_out", "video_in", "audio_in", "multizone_group");
-
-    /**
-     * The protocol for Cast Presentation URLs.
-     */
-    private static final String CAST_URL_PROTOCOL = "cast:";
-
-    /**
-     * The query parameter key for Cast Client ID in a Cast Presentation URL.
-     */
-    private static final String CAST_URL_CLIENT_ID = "clientId";
-
-    /**
-     * The query parameter key for autojoin policy in a Cast Presentation URL.
-     */
-    private static final String CAST_URL_AUTOJOIN_POLICY = "autoJoinPolicy";
-
-    /**
-     * The query parameter key for app capabilities in a Cast Presentation URL.
-     */
-    private static final String CAST_URL_CAPABILITIES = "capabilities";
-
-    /**
-     * The original presentation URL that the {@link CastMediaSource} object was created from.
-     */
-    private final String mSourceId;
-
-    /**
-     * The Cast application id, can be invalid in which case {@link CastMediaRouteProvider}
-     * will explicitly report no sinks available.
-     */
-    private final String mApplicationId;
-
-    /**
-     * A numeric identifier for the Cast Web SDK, unique for the frame providing the
-     * presentation URL. Can be null.
-     */
-    private final String mClientId;
-
-    /**
-     * Defines Cast-specific behavior for {@link CastMediaRouteProvider#joinRoute}. Defaults to
-     * {@link CastMediaSource#AUTOJOIN_TAB_AND_ORIGIN_SCOPED}.
-     */
-    private final String mAutoJoinPolicy;
-
-    /**
-     * Defines the capabilities of the particular application id. Can be null.
-     */
-    private final String[] mCapabilities;
-
-    /**
-     * Initializes the media source from the source id.
-     * @param sourceId the source id for the Cast media source (a presentation url).
-     * @return an initialized media source if the id is valid, null otherwise.
-     */
-    @Nullable
-    public static CastMediaSource from(String sourceId) {
-        assert sourceId != null;
-        return sourceId.startsWith(CAST_URL_PROTOCOL) ? fromCastUrl(sourceId)
-                                                      : fromLegacyUrl(sourceId);
-    }
-
-    /**
-     * Returns a new {@link MediaRouteSelector} to use for Cast device filtering for this
-     * particular media source or null if the application id is invalid.
-     *
-     * @return an initialized route selector or null.
-     */
-    @Override
-    public MediaRouteSelector buildRouteSelector() {
-        try {
-            return new MediaRouteSelector.Builder()
-                    .addControlCategory(CastMediaControlIntent.categoryForCast(mApplicationId))
-                    .build();
-        } catch (IllegalArgumentException e) {
-            return null;
-        }
-    }
-
-    /**
-     * @return the Cast application id corresponding to the source.
-     */
-    @Override
-    public String getApplicationId() {
-        return mApplicationId;
-    }
-
-    /**
-     * @return the client id if passed in the source id. Can be null.
-     */
-    @Nullable
-    public String getClientId() {
-        return mClientId;
-    }
-
-    /**
-     * @return the auto join policy which must be one of the AUTOJOIN constants defined above.
-     */
-    public String getAutoJoinPolicy() {
-        return mAutoJoinPolicy;
-    }
-
-    /**
-     * @return the id identifying the media source
-     */
-    @Override
-    public String getSourceId() {
-        return mSourceId;
-    }
-
-    /**
-     * @return application capabilities
-     */
-    public String[] getCapabilities() {
-        return mCapabilities == null ? null : Arrays.copyOf(mCapabilities, mCapabilities.length);
-    }
-
-    private CastMediaSource(String sourceId, String applicationId, String clientId,
-            String autoJoinPolicy, String[] capabilities) {
-        mSourceId = sourceId;
-        mApplicationId = applicationId;
-        mClientId = clientId;
-        mAutoJoinPolicy = autoJoinPolicy == null ? AUTOJOIN_TAB_AND_ORIGIN_SCOPED : autoJoinPolicy;
-        mCapabilities = capabilities;
-    }
-
-    @Nullable
-    private static String extractParameter(String[] fragments, String key) {
-        String keyPrefix = key + "=";
-        for (String parameter : fragments) {
-            if (parameter.startsWith(keyPrefix)) return parameter.substring(keyPrefix.length());
-        }
-        return null;
-    }
-
-    @Nullable
-    private static String[] extractCapabilities(String capabilitiesParameter) {
-        if (capabilitiesParameter.length()
-                < CAST_APP_CAPABILITIES_PREFIX.length() + CAST_APP_CAPABILITIES_SUFFIX.length()) {
-            return null;
-        }
-
-        if (!capabilitiesParameter.startsWith(CAST_APP_CAPABILITIES_PREFIX)
-                || !capabilitiesParameter.endsWith(CAST_APP_CAPABILITIES_SUFFIX)) {
-            return null;
-        }
-
-        String capabilitiesList =
-                capabilitiesParameter.substring(CAST_APP_CAPABILITIES_PREFIX.length(),
-                        capabilitiesParameter.length() - CAST_APP_CAPABILITIES_SUFFIX.length());
-        String[] capabilities = capabilitiesList.split(CAST_APP_CAPABILITIES_SEPARATOR);
-        for (String capability : capabilities) {
-            if (!CAST_APP_CAPABILITIES.contains(capability)) return null;
-        }
-        return capabilities;
-    }
-
-    /**
-     * Helper method to create a MediaSource object from a Cast (cast:) presentation URL.
-     * @param sourceId the source id for the Cast media source.
-     * @return an initialized media source if the uri is a valid Cast presentation URL, null
-     * otherwise.
-     */
-    @Nullable
-    private static CastMediaSource fromCastUrl(String sourceId) {
-        // Strip the scheme as the Uri parser works better without it.
-        Uri sourceUri = Uri.parse(sourceId.substring(CAST_URL_PROTOCOL.length()));
-        String applicationId = sourceUri.getPath();
-        if (applicationId == null) return null;
-
-        String clientId = sourceUri.getQueryParameter(CAST_URL_CLIENT_ID);
-        String autoJoinPolicy = sourceUri.getQueryParameter(CAST_URL_AUTOJOIN_POLICY);
-        if (autoJoinPolicy != null && !AUTOJOIN_POLICIES.contains(autoJoinPolicy)) {
-            return null;
-        }
-
-        String[] capabilities = null;
-        String capabilitiesParam = sourceUri.getQueryParameter(CAST_URL_CAPABILITIES);
-        if (capabilitiesParam != null) {
-            capabilities = capabilitiesParam.split(CAST_APP_CAPABILITIES_SEPARATOR);
-            for (String capability : capabilities) {
-                if (!CAST_APP_CAPABILITIES.contains(capability)) return null;
-            }
-        }
-
-        return new CastMediaSource(sourceId, applicationId, clientId, autoJoinPolicy, capabilities);
-    }
-
-    /**
-     * @deprecated Legacy Cast Presentation URLs are deprecated in favor of cast: URLs.
-     * TODO(crbug.com/757358): remove this method when we drop support for legacy URLs.
-     * Helper method to create a MediaSource object from a legacy (https:) presentation URL.
-     * @param sourceId the source id for the Cast media source.
-     * @return an initialized media source if the uri is a valid https presentation URL, null
-     * otherwise.
-     */
-    @Deprecated
-    @Nullable
-    private static CastMediaSource fromLegacyUrl(String sourceId) {
-        Uri sourceUri = Uri.parse(sourceId);
-        String uriFragment = sourceUri.getFragment();
-        if (uriFragment == null) return null;
-
-        String[] parameters = uriFragment.split(CAST_SOURCE_ID_SEPARATOR);
-
-        String applicationId = extractParameter(parameters, CAST_SOURCE_ID_APPLICATION_ID);
-        if (applicationId == null) return null;
-
-        String[] capabilities = null;
-        int capabilitiesIndex = applicationId.indexOf(CAST_APP_CAPABILITIES_PREFIX);
-        if (capabilitiesIndex != -1) {
-            capabilities = extractCapabilities(applicationId.substring(capabilitiesIndex));
-            if (capabilities == null) return null;
-
-            applicationId = applicationId.substring(0, capabilitiesIndex);
-        }
-
-        String clientId = extractParameter(parameters, CAST_SOURCE_ID_CLIENT_ID);
-        String autoJoinPolicy = extractParameter(parameters, CAST_SOURCE_ID_AUTOJOIN_POLICY);
-        if (autoJoinPolicy != null && !AUTOJOIN_POLICIES.contains(autoJoinPolicy)) {
-            return null;
-        }
-        return new CastMediaSource(sourceId, applicationId, clientId, autoJoinPolicy, capabilities);
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMessageHandler.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMessageHandler.java
deleted file mode 100644
index c485f6c..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastMessageHandler.java
+++ /dev/null
@@ -1,624 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.os.Handler;
-import android.support.v4.util.ArrayMap;
-import android.util.SparseArray;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import org.chromium.base.Log;
-import org.chromium.base.VisibleForTesting;
-
-import java.util.ArrayDeque;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Queue;
-
-/**
- * The handler for cast messages. It receives events between the Cast SDK and the page, process and
- * dispatch the messages accordingly. The handler talks to the Cast SDK via CastSession, and
- * talks to the pages via the media router.
- */
-public class CastMessageHandler {
-    private static final String TAG = "MediaRouter";
-
-    // Sequence number used when no sequence number is required or was initially passed.
-    static final int INVALID_SEQUENCE_NUMBER = -1;
-
-    private static final String MEDIA_MESSAGE_TYPES[] = {
-            "PLAY",
-            "LOAD",
-            "PAUSE",
-            "SEEK",
-            "STOP_MEDIA",
-            "MEDIA_SET_VOLUME",
-            "MEDIA_GET_STATUS",
-            "EDIT_TRACKS_INFO",
-            "QUEUE_LOAD",
-            "QUEUE_INSERT",
-            "QUEUE_UPDATE",
-            "QUEUE_REMOVE",
-            "QUEUE_REORDER",
-    };
-
-    private static final String MEDIA_SUPPORTED_COMMANDS[] = {
-            "pause",
-            "seek",
-            "stream_volume",
-            "stream_mute",
-    };
-
-    // Lock used to lazy initialize sMediaOverloadedMessageTypes.
-    private static final Object INIT_LOCK = new Object();
-
-    // Map associating types that have a different names outside of the media namespace and inside.
-    // In other words, some types are sent as MEDIA_FOO or FOO_MEDIA by the client by the Cast
-    // expect them to be named FOO. The reason being that FOO might exist in multiple namespaces
-    // but the client isn't aware of namespacing.
-    private static Map<String, String> sMediaOverloadedMessageTypes;
-
-    private SparseArray<RequestRecord> mRequests;
-    private ArrayMap<String, Queue<Integer>> mStopRequests;
-    private Queue<RequestRecord> mVolumeRequests;
-
-    // The reference to CastSession, only valid after calling {@link onSessionCreated}, and will be
-    // reset to null when calling {@link onApplicationStopped}.
-    private CastSession mSession;
-    private final CastMediaRouteProvider mRouteProvider;
-    private Handler mHandler;
-
-    /**
-     * The record for client requests. {@link CastMessageHandler} uses this class to manage the
-     * client requests and match responses to the requests.
-     */
-    static class RequestRecord {
-        public final String clientId;
-        public final int sequenceNumber;
-
-        public RequestRecord(String clientId, int sequenceNumber) {
-            this.clientId = clientId;
-            this.sequenceNumber = sequenceNumber;
-        }
-    }
-
-    /**
-     * Initializes a new {@link CastMessageHandler} instance.
-     * @param session  The {@link CastSession} for communicating with the Cast SDK.
-     * @param provider The {@link CastMediaRouteProvider} for communicating with the page.
-     */
-    public CastMessageHandler(CastMediaRouteProvider provider) {
-        mRouteProvider = provider;
-        mRequests = new SparseArray<RequestRecord>();
-        mStopRequests = new ArrayMap<String, Queue<Integer>>();
-        mVolumeRequests = new ArrayDeque<RequestRecord>();
-        mHandler = new Handler();
-
-        synchronized (INIT_LOCK) {
-            if (sMediaOverloadedMessageTypes == null) {
-                sMediaOverloadedMessageTypes = new HashMap<String, String>();
-                sMediaOverloadedMessageTypes.put("STOP_MEDIA", "STOP");
-                sMediaOverloadedMessageTypes.put("MEDIA_SET_VOLUME", "SET_VOLUME");
-                sMediaOverloadedMessageTypes.put("MEDIA_GET_STATUS", "GET_STATUS");
-            }
-        }
-    }
-
-    @VisibleForTesting
-    static String[] getMediaMessageTypesForTest() {
-        return MEDIA_MESSAGE_TYPES;
-    }
-
-    @VisibleForTesting
-    static Map<String, String> getMediaOverloadedMessageTypesForTest() {
-        return sMediaOverloadedMessageTypes;
-    }
-
-    @VisibleForTesting
-    SparseArray<RequestRecord> getRequestsForTest() {
-        return mRequests;
-    }
-
-    @VisibleForTesting
-    Queue<RequestRecord> getVolumeRequestsForTest() {
-        return mVolumeRequests;
-    }
-
-    @VisibleForTesting
-    Map<String, Queue<Integer>> getStopRequestsForTest() {
-        return mStopRequests;
-    }
-
-    /**
-     * Set the session when a session is created, and notify all clients that are not connected.
-     * @param session The newly created session.
-     */
-    public void onSessionCreated(CastSession session) {
-        mSession = session;
-        for (ClientRecord client : mRouteProvider.getClientRecords().values()) {
-            if (!client.isConnected) continue;
-
-            mSession.onClientConnected(client.clientId);
-        }
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // Functions for handling messages from the page to the Cast device.
-
-    /**
-     * Handles messages related to the cast session, i.e. messages happening on a established
-     * connection. All these messages are sent from the page to the Cast SDK.
-     * @param message The JSONObject message to be handled.
-     */
-    public boolean handleSessionMessage(JSONObject message) throws JSONException {
-        String messageType = message.getString("type");
-        if ("v2_message".equals(messageType)) {
-            return handleCastV2Message(message);
-        } else if ("app_message".equals(messageType)) {
-            return handleAppMessage(message);
-        } else {
-            Log.e(TAG, "Unsupported message: %s", message);
-            return false;
-        }
-    }
-
-    // An example of the Cast V2 message:
-    //    {
-    //        "type": "v2_message",
-    //        "message": {
-    //          "type": "...",
-    //          ...
-    //        },
-    //        "sequenceNumber": 0,
-    //        "timeoutMillis": 0,
-    //        "clientId": "144042901280235697"
-    //    }
-    @VisibleForTesting
-    boolean handleCastV2Message(JSONObject jsonMessage)
-            throws JSONException {
-        assert "v2_message".equals(jsonMessage.getString("type"));
-
-        final String clientId = jsonMessage.getString("clientId");
-        if (clientId == null || !mRouteProvider.getClients().contains(clientId)) return false;
-
-        JSONObject jsonCastMessage = jsonMessage.getJSONObject("message");
-        String messageType = jsonCastMessage.getString("type");
-        final int sequenceNumber = jsonMessage.optInt("sequenceNumber", INVALID_SEQUENCE_NUMBER);
-
-        if ("STOP".equals(messageType)) {
-            handleStopMessage(clientId, sequenceNumber);
-            return true;
-        }
-
-        if ("SET_VOLUME".equals(messageType)) {
-            CastSession.HandleVolumeMessageResult result =
-                    mSession.handleVolumeMessage(
-                    jsonCastMessage.getJSONObject("volume"), clientId, sequenceNumber);
-            if (!result.mSucceeded) return false;
-
-            // For each successful volume message we need to respond with an empty "v2_message" so
-            // the Cast Web SDK can call the success callback of the page.  If we expect the volume
-            // to change as the result of the command, we're relying on {@link
-            // Cast.CastListener#onVolumeChanged} to get called by the Android Cast SDK when the
-            // receiver status is updated. We keep the sequence number until then.  If the volume
-            // doesn't change as the result of the command, we won't get notified by the Android SDK
-            // when the status update is received so we respond to the volume message immediately.
-            if (result.mShouldWaitForVolumeChange) {
-                mVolumeRequests.add(new RequestRecord(clientId, sequenceNumber));
-            } else {
-                // It's usually bad to have request and response on the same call stack so post the
-                // response to the Android message loop.
-                mHandler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            onVolumeChanged(clientId, sequenceNumber);
-                        }
-                    });
-            }
-            return true;
-        }
-
-        if (Arrays.asList(MEDIA_MESSAGE_TYPES).contains(messageType)) {
-            if (sMediaOverloadedMessageTypes.containsKey(messageType)) {
-                messageType = sMediaOverloadedMessageTypes.get(messageType);
-                jsonCastMessage.put("type", messageType);
-            }
-            return sendJsonCastMessage(
-                    jsonCastMessage, CastSessionUtil.MEDIA_NAMESPACE, clientId, sequenceNumber);
-        }
-
-        return true;
-    }
-
-    @VisibleForTesting
-    void handleStopMessage(String clientId, int sequenceNumber) {
-        Queue<Integer> sequenceNumbersForClient = mStopRequests.get(clientId);
-        if (sequenceNumbersForClient == null) {
-            sequenceNumbersForClient = new ArrayDeque<Integer>();
-            mStopRequests.put(clientId, sequenceNumbersForClient);
-        }
-        sequenceNumbersForClient.add(sequenceNumber);
-
-        mSession.stopApplication();
-    }
-
-    // An example of the Cast application message:
-    // {
-    //   "type":"app_message",
-    //   "message": {
-    //     "sessionId":"...",
-    //     "namespaceName":"...",
-    //     "message": ...
-    //   },
-    //   "sequenceNumber":0,
-    //   "timeoutMillis":3000,
-    //   "clientId":"14417311915272175"
-    // }
-    @VisibleForTesting
-    boolean handleAppMessage(JSONObject jsonMessage) throws JSONException {
-        assert "app_message".equals(jsonMessage.getString("type"));
-
-        String clientId = jsonMessage.getString("clientId");
-        if (clientId == null || !mRouteProvider.getClients().contains(clientId)) return false;
-
-        JSONObject jsonAppMessageWrapper = jsonMessage.getJSONObject("message");
-
-        if (!mSession.getSessionId().equals(jsonAppMessageWrapper.getString("sessionId"))) {
-            return false;
-        }
-
-        String namespaceName = jsonAppMessageWrapper.getString("namespaceName");
-        if (namespaceName == null || namespaceName.isEmpty()) return false;
-
-        if (!mSession.getNamespaces().contains(namespaceName)) return false;
-
-        int sequenceNumber = jsonMessage.optInt("sequenceNumber", INVALID_SEQUENCE_NUMBER);
-
-        Object actualMessageObject = jsonAppMessageWrapper.get("message");
-        if (actualMessageObject == null) return false;
-
-        if (actualMessageObject instanceof String) {
-            String actualMessage = jsonAppMessageWrapper.getString("message");
-            return mSession.sendStringCastMessage(
-                    actualMessage, namespaceName, clientId, sequenceNumber);
-        }
-
-        JSONObject actualMessage = jsonAppMessageWrapper.getJSONObject("message");
-        return sendJsonCastMessage(actualMessage, namespaceName, clientId, sequenceNumber);
-    }
-
-    @VisibleForTesting
-    boolean sendJsonCastMessage(
-            JSONObject message,
-            final String namespace,
-            final String clientId,
-            final int sequenceNumber) throws JSONException {
-        if (mSession.isApiClientInvalid()) return false;
-
-        removeNullFields(message);
-
-        // Map the request id to a valid sequence number only.
-        if (sequenceNumber != INVALID_SEQUENCE_NUMBER) {
-            // If for some reason, there is already a requestId other than 0, it
-            // is kept. Otherwise, one is generated. In all cases it's associated with the
-            // sequenceNumber passed by the client.
-            int requestId = message.optInt("requestId", 0);
-            if (requestId == 0) {
-                requestId = CastRequestIdGenerator.getNextRequestId();
-                message.put("requestId", requestId);
-            }
-            mRequests.append(requestId, new RequestRecord(clientId, sequenceNumber));
-        }
-
-        return mSession.sendStringCastMessage(
-                message.toString(), namespace, clientId, sequenceNumber);
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // Functions for handling messages from the Cast device to the pages.
-
-    /**
-     * Forwards the messages from the Cast device to the clients, and perform proper actions if it
-     * is media message.
-     * @param namespace The application specific namespace this message belongs to.
-     * @param message The message within the namespace that's being sent by the receiver
-     */
-    public void onMessageReceived(String namespace, String message) {
-        RequestRecord request = null;
-        try {
-            JSONObject jsonMessage = new JSONObject(message);
-            int requestId = jsonMessage.getInt("requestId");
-            if (mRequests.indexOfKey(requestId) >= 0) {
-                request = mRequests.get(requestId);
-                mRequests.delete(requestId);
-            }
-        } catch (JSONException e) {
-        }
-
-        if (CastSessionUtil.MEDIA_NAMESPACE.equals(namespace)) {
-            onMediaMessage(message, request);
-            return;
-        }
-
-        onAppMessage(message, namespace, request);
-    }
-
-    /**
-     * Forwards the media message to the page via the media router.
-     * The MEDIA_STATUS message needs to be sent to all the clients.
-     * @param message The media that's being send by the receiver.
-     * @param request The information about the client and the sequence number to respond with.
-     */
-    @VisibleForTesting
-    void onMediaMessage(String message, RequestRecord request) {
-        mSession.onMediaMessage(message);
-
-        if (isMediaStatusMessage(message)) {
-            // MEDIA_STATUS needs to be sent to all the clients.
-            for (String clientId : mRouteProvider.getClients()) {
-                if (request != null && clientId.equals(request.clientId)) continue;
-
-                sendClientMessageTo(
-                        clientId, "v2_message", message, INVALID_SEQUENCE_NUMBER);
-            }
-        }
-        if (request != null) {
-            sendClientMessageTo(
-                    request.clientId, "v2_message", message, request.sequenceNumber);
-        }
-    }
-
-    /**
-     * Forwards the application specific message to the page via the media router.
-     * @param message The message within the namespace that's being sent by the receiver.
-     * @param namespace The application specific namespace this message belongs to.
-     * @param request The information about the client and the sequence number to respond with.
-     */
-    @VisibleForTesting
-    void onAppMessage(String message, String namespace, RequestRecord request) {
-        try {
-            JSONObject jsonMessage = new JSONObject();
-            jsonMessage.put("sessionId", mSession.getSessionId());
-            jsonMessage.put("namespaceName", namespace);
-            jsonMessage.put("message", message);
-            if (request != null) {
-                sendClientMessageTo(request.clientId, "app_message",
-                        jsonMessage.toString(), request.sequenceNumber);
-            } else {
-                broadcastClientMessage("app_message", jsonMessage.toString());
-            }
-        } catch (JSONException e) {
-            Log.e(TAG, "Failed to create the message wrapper", e);
-        }
-    }
-
-    /**
-     * Notifies the application has stopped to all requesting clients.
-     */
-    public void onApplicationStopped() {
-        for (String clientId : mRouteProvider.getClients()) {
-            Queue<Integer> sequenceNumbersForClient = mStopRequests.get(clientId);
-            if (sequenceNumbersForClient == null) {
-                sendClientMessageTo(
-                        clientId, "remove_session", mSession.getSessionId(),
-                        INVALID_SEQUENCE_NUMBER);
-                continue;
-            }
-
-            for (int sequenceNumber : sequenceNumbersForClient) {
-                sendClientMessageTo(
-                        clientId, "remove_session", mSession.getSessionId(), sequenceNumber);
-            }
-            mStopRequests.remove(clientId);
-        }
-        mSession = null;
-    }
-
-    /**
-     * When the Cast device volume really changed, updates the session status and notify all
-     * requesting clients.
-     */
-    public void onVolumeChanged() {
-        mSession.updateSessionStatus();
-
-        if (mVolumeRequests.isEmpty()) return;
-
-        for (RequestRecord r : mVolumeRequests) onVolumeChanged(r.clientId, r.sequenceNumber);
-        mVolumeRequests.clear();
-    }
-
-    @VisibleForTesting
-    void onVolumeChanged(String clientId, int sequenceNumber) {
-        sendClientMessageTo(clientId, "v2_message", null, sequenceNumber);
-    }
-
-    /**
-     * Notifies a client that an app message has been sent.
-     * @param clientId The client id the message is sent from.
-     * @param sequenceNumber The sequence number of the message.
-     */
-    public void onAppMessageSent(String clientId, int sequenceNumber) {
-        sendClientMessageTo(clientId, "app_message", null, sequenceNumber);
-    }
-
-    /**
-     * Broadcasts the message to all clients.
-     * @param type    The type of the message.
-     * @param message The message to broadcast.
-     */
-    public void broadcastClientMessage(String type, String message) {
-        for (String clientId : mRouteProvider.getClients()) {
-            sendClientMessageTo(clientId, type, message, INVALID_SEQUENCE_NUMBER);
-        }
-    }
-
-    /**
-     * Sends a message to a specific client.
-     * @param clientId The id of the receiving client.
-     * @param type     The type of the message.
-     * @param message  The message to be sent.
-     * @param sequenceNumber The sequence number for matching requesting and responding messages.
-     */
-    public void sendClientMessageTo(
-            String clientId, String type, String message, int sequenceNumber) {
-        mRouteProvider.onMessage(clientId,
-                buildInternalMessage(type, message, clientId, sequenceNumber));
-    }
-
-    @VisibleForTesting
-    String buildInternalMessage(
-            String type, String message, String clientId, int sequenceNumber) {
-        JSONObject json = new JSONObject();
-        try {
-            json.put("type", type);
-            json.put("sequenceNumber", sequenceNumber);
-            json.put("timeoutMillis", 0);
-            json.put("clientId", clientId);
-
-            // TODO(mlamouri): we should have a more reliable way to handle string, null and Object
-            // messages.
-            if (message == null
-                    || "remove_session".equals(type)
-                    || "disconnect_session".equals(type)) {
-                json.put("message", message);
-            } else {
-                JSONObject jsonMessage = new JSONObject(message);
-                if ("v2_message".equals(type)
-                        && "MEDIA_STATUS".equals(jsonMessage.getString("type"))) {
-                    sanitizeMediaStatusMessage(jsonMessage);
-                }
-                json.put("message", jsonMessage);
-            }
-        } catch (JSONException e) {
-            Log.e(TAG, "Failed to build the reply: " + e);
-        }
-
-        return json.toString();
-    }
-
-    /**
-     * @return A message containing the information of the {@link CastSession}.
-     */
-    public String buildSessionMessage() {
-        if (mSession == null) return "{}";
-
-        CastSessionInfo sessionInfo = mSession.getSessionInfo();
-        if (sessionInfo == null) return "{}";
-
-        try {
-            // "volume" is a part of "receiver" initialized below.
-            JSONObject jsonVolume = new JSONObject();
-            jsonVolume.put("level", sessionInfo.receiver.volume.level);
-            jsonVolume.put("muted", sessionInfo.receiver.volume.muted);
-
-            // "receiver" is a part of "message" initialized below.
-            JSONObject jsonReceiver = new JSONObject();
-            jsonReceiver.put("label", sessionInfo.receiver.label);
-            jsonReceiver.put("friendlyName", sessionInfo.receiver.friendlyName);
-            jsonReceiver.put("capabilities", toJSONArray(sessionInfo.receiver.capabilities));
-            jsonReceiver.put("volume", jsonVolume);
-            jsonReceiver.put("isActiveInput", sessionInfo.receiver.isActiveInput);
-            jsonReceiver.put("displayStatus", sessionInfo.receiver.displayStatus);
-            jsonReceiver.put("receiverType", sessionInfo.receiver.receiverType);
-
-            JSONArray jsonNamespaces = new JSONArray();
-            for (String namespace : sessionInfo.namespaces) {
-                JSONObject jsonNamespace = new JSONObject();
-                jsonNamespace.put("name", namespace);
-                jsonNamespaces.put(jsonNamespace);
-            }
-
-            JSONObject jsonMessage = new JSONObject();
-            jsonMessage.put("sessionId", sessionInfo.sessionId);
-            jsonMessage.put("statusText", sessionInfo.statusText);
-            jsonMessage.put("receiver", jsonReceiver);
-            jsonMessage.put("namespaces", jsonNamespaces);
-            jsonMessage.put("media", toJSONArray(sessionInfo.media));
-            jsonMessage.put("status", sessionInfo.status);
-            jsonMessage.put("transportId", sessionInfo.transportId);
-            jsonMessage.put("appId", sessionInfo.appId);
-            jsonMessage.put("displayName", sessionInfo.displayName);
-
-            return jsonMessage.toString();
-        } catch (JSONException e) {
-            Log.w(TAG, "Building session message failed", e);
-            return "{}";
-        }
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // Utility functions
-
-    /**
-     * Modifies the received MediaStatus message to match the format expected by the client.
-     */
-    private void sanitizeMediaStatusMessage(JSONObject object) throws JSONException {
-        object.put("sessionId", mSession.getSessionId());
-
-        JSONArray mediaStatus = object.getJSONArray("status");
-        for (int i = 0; i < mediaStatus.length(); ++i) {
-            JSONObject status = mediaStatus.getJSONObject(i);
-            status.put("sessionId", mSession.getSessionId());
-            if (!status.has("supportedMediaCommands")) continue;
-
-            JSONArray commands = new JSONArray();
-            int bitfieldCommands = status.getInt("supportedMediaCommands");
-            for (int j = 0; j < 4; ++j) {
-                if ((bitfieldCommands & (1 << j)) != 0) {
-                    commands.put(MEDIA_SUPPORTED_COMMANDS[j]);
-                }
-            }
-
-            status.put("supportedMediaCommands", commands);  // Removes current entry.
-        }
-    }
-
-    /**
-     * Remove 'null' fields from a JSONObject. This method calls itself recursively until all the
-     * fields have been looked at.
-     * TODO(mlamouri): move to some util class?
-     */
-    private static void removeNullFields(Object object) throws JSONException {
-        if (object instanceof JSONArray) {
-            JSONArray array = (JSONArray) object;
-            for (int i = 0; i < array.length(); ++i) removeNullFields(array.get(i));
-        } else if (object instanceof JSONObject) {
-            JSONObject json = (JSONObject) object;
-            JSONArray names = json.names();
-            if (names == null) return;
-            for (int i = 0; i < names.length(); ++i) {
-                String key = names.getString(i);
-                if (json.isNull(key)) {
-                    json.remove(key);
-                } else {
-                    removeNullFields(json.get(key));
-                }
-            }
-        }
-    }
-
-    @VisibleForTesting
-    boolean isMediaStatusMessage(String message) {
-        try {
-            JSONObject jsonMessage = new JSONObject(message);
-            return "MEDIA_STATUS".equals(jsonMessage.getString("type"));
-        } catch (JSONException e) {
-            return false;
-        }
-    }
-
-    private JSONArray toJSONArray(List<String> from) throws JSONException {
-        JSONArray result = new JSONArray();
-        for (String entry : from) {
-            result.put(entry);
-        }
-        return result;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastRequestIdGenerator.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastRequestIdGenerator.java
deleted file mode 100644
index c753a83..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastRequestIdGenerator.java
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-/**
- * Returns a request id in a range that is considered fairly unique. These request ids are used to
- * communicate with the cast device and identify messages and their responses.
- */
-public class CastRequestIdGenerator {
-    private static final Object LOCK = new Object();
-    private static CastRequestIdGenerator sInstance;
-
-    private int mRequestId;
-
-    /** Returns the next requestId in the range allocated to communicate with the device. */
-    public static int getNextRequestId() {
-        CastRequestIdGenerator instance = getInstance();
-
-        // Return the current |mRequestId| then increment. Never return 0 because it is reserved.
-        if (instance.mRequestId == 0) ++instance.mRequestId;
-        return instance.mRequestId++;
-    }
-
-    /** Returns the Singleton instance of the CastRequestIdGenerator. */
-    private static CastRequestIdGenerator getInstance() {
-        synchronized (LOCK) {
-            if (sInstance == null) sInstance = new CastRequestIdGenerator();
-        }
-        return sInstance;
-    }
-
-    private CastRequestIdGenerator() {
-        mRequestId = (int) Math.floor(Math.random() * 100000.0) * 1000;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSession.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSession.java
deleted file mode 100644
index 8062fcc..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSession.java
+++ /dev/null
@@ -1,137 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import org.chromium.chrome.browser.media.router.MediaController;
-
-import java.util.Set;
-
-import javax.annotation.Nullable;
-
-/**
- * The interface for talking to the GMS core. We need to isolate this
- * interface from its implementation so that we can mock it with out
- * dependencies on the GMS core. Otherwise junit tests will fail on
- * the bots since they don't support GMS core for junit tests. For
- * example, see: https://crbug.com/588758
- */
-public interface CastSession {
-    /**
-     * The return type for {@link handleVolumeMessage}.
-     */
-    static class HandleVolumeMessageResult {
-        public final boolean mSucceeded;
-        public final boolean mShouldWaitForVolumeChange;
-
-        /**
-         * Initializes a {@link HandleVolumeMessageResult}.
-         */
-        public HandleVolumeMessageResult(boolean succeeded, boolean shouldWaitForVolumeChange) {
-            mSucceeded = succeeded;
-            mShouldWaitForVolumeChange = shouldWaitForVolumeChange;
-        }
-    }
-
-    /**
-     * @return If the gms core api client is invalid.
-     */
-    boolean isApiClientInvalid();
-
-    /**
-     * @return The sink id of the CastSession.
-     */
-    String getSinkId();
-
-    /**
-     * @return The source id of the CastSession.
-     */
-    String getSourceId();
-
-    /**
-     * @return The id of the CastSession.
-     */
-    String getSessionId();
-
-    /**
-     * @return The namespaces supported by the CastSession.
-     */
-    Set<String> getNamespaces();
-
-    /**
-     * @return The message handler of the CastSession.
-     */
-    CastMessageHandler getMessageHandler();
-
-    /**
-     * @return The session information.
-     */
-    CastSessionInfo getSessionInfo();
-
-    /**
-     * Sends the string message to the Cast device through the Cast SDK.
-     * @param message        The message to send.
-     * @param namespace      The namespace of the message.
-     * @param clientId       The id of the client sending the message.
-     * @param sequenceNumber The sequence number of the message, which is used for matching
-     *                       responses to requests.
-     */
-    boolean sendStringCastMessage(
-            String message, String namespace, String clientId, int sequenceNumber);
-
-    /**
-     * Handles SET_VOLUME messages, and sets the volume of the Cast device through the Cast SDK.
-     * @param volume         A JSONObject containing the volume information.
-     *                       Example:
-     *                       {
-     *                         "volume" {
-     *                           "level": 0.9,
-     *                           "muted": null
-     *                         }
-     *                       }
-     * @param clientId       The id of the client sending the message.
-     * @param sequenceNumber The sequence number of the message, which is used for matching
-     *                       responses to requests.
-     */
-    HandleVolumeMessageResult handleVolumeMessage(
-            JSONObject volume, String clientId, int sequenceNumber)
-            throws JSONException;
-
-    /**
-     * Stops the application. The methods tells the Cast SDK to stop the application and on
-     * response, it will notify all the clients through the message handler.
-     */
-    void stopApplication();
-
-    /**
-     * Perform proper actions when a client is connected to the session.
-     */
-    void onClientConnected(String clientId);
-
-    /**
-     * When a media message is received from the Cast device, forwards the message to the
-     * MediaPlayer.
-     * @param message The media message received from the Cast device.
-     */
-    void onMediaMessage(String message);
-
-    /**
-     * Perform proper actions when the Cast device volume has changed.
-     */
-    void onVolumeChanged();
-
-    /**
-     * Updates the session info when it changes and broadcast the change.
-     */
-    void updateSessionStatus();
-
-    /**
-     * Returns a controller for the media content.
-     */
-    @Nullable
-    MediaController getMediaController();
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionImpl.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionImpl.java
deleted file mode 100644
index 17797a4..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionImpl.java
+++ /dev/null
@@ -1,491 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.content.Intent;
-
-import com.google.android.gms.cast.ApplicationMetadata;
-import com.google.android.gms.cast.Cast;
-import com.google.android.gms.cast.CastDevice;
-import com.google.android.gms.cast.MediaStatus;
-import com.google.android.gms.cast.RemoteMediaPlayer;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.common.api.ResultCallback;
-import com.google.android.gms.common.api.Status;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import org.chromium.base.Log;
-import org.chromium.chrome.R;
-import org.chromium.chrome.browser.media.router.MediaController;
-import org.chromium.chrome.browser.media.ui.MediaNotificationInfo;
-import org.chromium.chrome.browser.media.ui.MediaNotificationListener;
-import org.chromium.chrome.browser.media.ui.MediaNotificationManager;
-import org.chromium.chrome.browser.metrics.MediaNotificationUma;
-import org.chromium.chrome.browser.tab.Tab;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- * A wrapper around the established Cast application session.
- */
-public class CastSessionImpl implements MediaNotificationListener, CastSession {
-    private static final String TAG = "MediaRouter";
-
-    // The value is borrowed from the Android Cast SDK code to match their behavior.
-    private static final double MIN_VOLUME_LEVEL_DELTA = 1e-7;
-
-    private static class CastMessagingChannel implements Cast.MessageReceivedCallback {
-        private final CastSession mSession;
-
-        public CastMessagingChannel(CastSessionImpl session) {
-            mSession = session;
-        }
-
-        @Override
-        public void onMessageReceived(CastDevice castDevice, String namespace, String message) {
-            Log.d(TAG, "Received message from Cast device: namespace=\"" + namespace
-                       + "\" message=\"" + message + "\"");
-            mSession.getMessageHandler().onMessageReceived(namespace, message);
-        }
-    }
-
-    private final CastMessagingChannel mMessageChannel;
-    private final CastDevice mCastDevice;
-    private final MediaSource mSource;
-    private final CastMessageHandler mMessageHandler;
-
-    private GoogleApiClient mApiClient;
-    private String mSessionId;
-    private String mApplicationStatus;
-    private ApplicationMetadata mApplicationMetadata;
-    private boolean mStoppingApplication;
-    private MediaNotificationInfo.Builder mNotificationBuilder;
-    private RemoteMediaPlayer mMediaPlayer;
-
-    private Set<String> mNamespaces = new HashSet<String>();
-
-    /**
-     * Initializes a new {@link CastSessionImpl} instance.
-     * @param apiClient The Google Play Services client used to create the session.
-     * @param sessionId The session identifier to use with the Cast SDK.
-     * @param origin The origin of the frame requesting the route.
-     * @param tabId The id of the tab containing the frame requesting the route.
-     * @param isIncognito Whether the route is beging requested from an Incognito profile.
-     * @param source The {@link MediaSource} corresponding to this session.
-     * @param routeProvider The {@link CastMediaRouteProvider} instance managing this session.
-     */
-    public CastSessionImpl(GoogleApiClient apiClient, String sessionId,
-            ApplicationMetadata metadata, String applicationStatus, CastDevice castDevice,
-            String origin, int tabId, boolean isIncognito, MediaSource source,
-            CastMessageHandler messageHandler) {
-        mSessionId = sessionId;
-        mApiClient = apiClient;
-        mSource = source;
-        mApplicationMetadata = metadata;
-        mApplicationStatus = applicationStatus;
-        mCastDevice = castDevice;
-        mMessageHandler = messageHandler;
-        mMessageChannel = new CastMessagingChannel(this);
-        updateNamespaces();
-
-        if (mNamespaces.contains(CastSessionUtil.MEDIA_NAMESPACE)) {
-            mMediaPlayer = new RemoteMediaPlayer();
-            mMediaPlayer.setOnStatusUpdatedListener(
-                    new RemoteMediaPlayer.OnStatusUpdatedListener() {
-                        @Override
-                        public void onStatusUpdated() {
-                            MediaStatus mediaStatus = mMediaPlayer.getMediaStatus();
-                            if (mediaStatus == null) return;
-
-                            int playerState = mediaStatus.getPlayerState();
-                            if (playerState == MediaStatus.PLAYER_STATE_PAUSED
-                                    || playerState == MediaStatus.PLAYER_STATE_PLAYING) {
-                                mNotificationBuilder.setPaused(
-                                        playerState != MediaStatus.PLAYER_STATE_PLAYING);
-                                mNotificationBuilder.setActions(MediaNotificationInfo.ACTION_STOP
-                                        | MediaNotificationInfo.ACTION_PLAY_PAUSE);
-                            } else {
-                                mNotificationBuilder.setActions(MediaNotificationInfo.ACTION_STOP);
-                            }
-                            MediaNotificationManager.show(mNotificationBuilder.build());
-                        }
-                    });
-            mMediaPlayer.setOnMetadataUpdatedListener(
-                    new RemoteMediaPlayer.OnMetadataUpdatedListener() {
-                        @Override
-                        public void onMetadataUpdated() {
-                            CastSessionUtil.setNotificationMetadata(
-                                    mNotificationBuilder, mCastDevice, mMediaPlayer);
-                            MediaNotificationManager.show(mNotificationBuilder.build());
-                        }
-                    });
-        }
-
-        Intent contentIntent = Tab.createBringTabToFrontIntent(tabId);
-        if (contentIntent != null) {
-            contentIntent.putExtra(MediaNotificationUma.INTENT_EXTRA_NAME,
-                    MediaNotificationUma.SOURCE_PRESENTATION);
-        }
-        mNotificationBuilder =
-                new MediaNotificationInfo.Builder()
-                        .setPaused(false)
-                        .setOrigin(origin)
-                        // TODO(avayvod): the same session might have more than one tab id. Should
-                        // we track the last foreground alive tab and update the notification with
-                        // it?
-                        .setTabId(tabId)
-                        .setPrivate(isIncognito)
-                        .setActions(MediaNotificationInfo.ACTION_STOP)
-                        .setContentIntent(contentIntent)
-                        .setNotificationSmallIcon(R.drawable.ic_notification_media_route)
-                        .setDefaultNotificationLargeIcon(R.drawable.cast_playing_square)
-                        .setId(R.id.presentation_notification)
-                        .setListener(this);
-
-        CastSessionUtil.setNotificationMetadata(mNotificationBuilder, mCastDevice, mMediaPlayer);
-        MediaNotificationManager.show(mNotificationBuilder.build());
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // MediaNotificationListener implementation.
-
-    @Override
-    public void onPlay(int actionSource) {
-        if (mMediaPlayer == null || isApiClientInvalid()) return;
-
-        mMediaPlayer.play(mApiClient);
-    }
-
-    @Override
-    public void onPause(int actionSource) {
-        if (mMediaPlayer == null || isApiClientInvalid()) return;
-
-        mMediaPlayer.pause(mApiClient);
-    }
-
-    @Override
-    public void onStop(int actionSource) {
-        stopApplication();
-        ChromeCastSessionManager.get().onSessionStopAction();
-    }
-
-    @Override
-    public void onMediaSessionAction(int action) {}
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // Utility functions.
-
-    /**
-     * @param device The {@link CastDevice} queried for it's capabilities.
-     * @return The capabilities of the Cast device.
-     * TODO(zqzhang): move to a CastUtils class?
-     */
-    protected static List<String> getCapabilities(CastDevice device) {
-        List<String> capabilities = new ArrayList<String>();
-        if (device.hasCapability(CastDevice.CAPABILITY_AUDIO_IN)) {
-            capabilities.add("audio_in");
-        }
-        if (device.hasCapability(CastDevice.CAPABILITY_AUDIO_OUT)) {
-            capabilities.add("audio_out");
-        }
-        if (device.hasCapability(CastDevice.CAPABILITY_VIDEO_IN)) {
-            capabilities.add("video_in");
-        }
-        if (device.hasCapability(CastDevice.CAPABILITY_VIDEO_OUT)) {
-            capabilities.add("video_out");
-        }
-        return capabilities;
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // Namespace handling.
-
-    private void updateNamespaces() {
-        if (mApplicationMetadata == null) return;
-
-        List<String> newNamespaces = mApplicationMetadata.getSupportedNamespaces();
-
-        Set<String> toRemove = new HashSet<String>(mNamespaces);
-        toRemove.removeAll(newNamespaces);
-        for (String namespaceToRemove : toRemove) unregisterNamespace(namespaceToRemove);
-
-        for (String newNamespace : newNamespaces) {
-            if (!mNamespaces.contains(newNamespace)) addNamespace(newNamespace);
-        }
-    }
-
-    private void addNamespace(String namespace) {
-        assert !mNamespaces.contains(namespace);
-
-        if (isApiClientInvalid()) return;
-
-        // If application metadata is null, register the callback anyway.
-        if (mApplicationMetadata != null && !mApplicationMetadata.isNamespaceSupported(namespace)) {
-            return;
-        }
-
-        try {
-            Cast.CastApi.setMessageReceivedCallbacks(mApiClient, namespace, mMessageChannel);
-            mNamespaces.add(namespace);
-        } catch (IOException e) {
-            Log.e(TAG, "Failed to register namespace listener for %s", namespace, e);
-        }
-    }
-
-    private void unregisterNamespace(String namespace) {
-        assert mNamespaces.contains(namespace);
-
-        if (isApiClientInvalid()) return;
-
-        try {
-            Cast.CastApi.removeMessageReceivedCallbacks(mApiClient, namespace);
-            mNamespaces.remove(namespace);
-        } catch (IOException e) {
-            Log.e(TAG, "Failed to remove the namespace listener for %s", namespace, e);
-        }
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // CastSession implementations.
-
-    @Override
-    public boolean isApiClientInvalid() {
-        return mApiClient == null || !mApiClient.isConnected();
-    }
-
-    @Override
-    public String getSourceId() {
-        return mSource.getSourceId();
-    }
-
-    @Override
-    public String getSinkId() {
-        return mCastDevice.getDeviceId();
-    }
-
-    @Override
-    public String getSessionId() {
-        return mSessionId;
-    }
-
-    @Override
-    public Set<String> getNamespaces() {
-        return mNamespaces;
-    }
-
-    @Override
-    public CastMessageHandler getMessageHandler() {
-        return mMessageHandler;
-    }
-
-    @Override
-    public CastSessionInfo getSessionInfo() {
-        if (isApiClientInvalid()) return null;
-
-        // Due to a Google Play Services issue, the api client might still get disconnected so that
-        // calls like {@link Cast.CastApi#getVolume()} will throw an {@link IllegalStateException}.
-        // Until the issue is fixed, catch the exception and return null if it was thrown instead of
-        // crashing. See https://crbug.com/708964 for details.
-        try {
-            CastSessionInfo.VolumeInfo.Builder volumeBuilder =
-                    new CastSessionInfo.VolumeInfo.Builder()
-                            .setLevel(Cast.CastApi.getVolume(mApiClient))
-                            .setMuted(Cast.CastApi.isMute(mApiClient));
-
-            CastSessionInfo.ReceiverInfo.Builder receiverBuilder =
-                    new CastSessionInfo.ReceiverInfo.Builder()
-                            .setLabel(mCastDevice.getDeviceId())
-                            .setFriendlyName(mCastDevice.getFriendlyName())
-                            .setVolume(volumeBuilder.build())
-                            .setIsActiveInput(Cast.CastApi.getActiveInputState(mApiClient))
-                            .setDisplayStatus(null)
-                            .setReceiverType("cast")
-                            .addCapabilities(getCapabilities(mCastDevice));
-
-            CastSessionInfo.Builder sessionInfoBuilder =
-                    new CastSessionInfo.Builder()
-                            .setSessionId(mSessionId)
-                            .setStatusText(mApplicationStatus)
-                            .setReceiver(receiverBuilder.build())
-                            .setStatus("connected")
-                            .setTransportId("web-4")
-                            .addNamespaces(mNamespaces);
-
-            if (mApplicationMetadata != null) {
-                sessionInfoBuilder.setAppId(mApplicationMetadata.getApplicationId())
-                        .setDisplayName(mApplicationMetadata.getName());
-            } else {
-                sessionInfoBuilder.setAppId(mSource.getApplicationId())
-                        .setDisplayName(mCastDevice.getFriendlyName());
-            }
-
-            return sessionInfoBuilder.build();
-        } catch (IllegalStateException e) {
-            Log.e(TAG, "Couldn't get session info", e);
-            return null;
-        }
-    }
-
-    @Override
-    public boolean sendStringCastMessage(
-            final String message,
-            final String namespace,
-            final String clientId,
-            final int sequenceNumber) {
-        if (isApiClientInvalid()) return false;
-        Log.d(TAG, "Sending message to Cast device in namespace %s: %s", namespace, message);
-
-        try {
-            Cast.CastApi.sendMessage(mApiClient, namespace, message)
-                    .setResultCallback(
-                            new ResultCallback<Status>() {
-                                @Override
-                                public void onResult(Status result) {
-                                    if (!result.isSuccess()) {
-                                        // TODO(avayvod): should actually report back to the page.
-                                        // See https://crbug.com/550445.
-                                        Log.e(TAG, "Failed to send the message: " + result);
-                                        return;
-                                    }
-
-                                    // Media commands wait for the media status update as a result.
-                                    if (CastSessionUtil.MEDIA_NAMESPACE.equals(namespace)) return;
-
-                                    // App messages wait for the empty message with the sequence
-                                    // number.
-                                    mMessageHandler.onAppMessageSent(clientId, sequenceNumber);
-                                }
-                            });
-        } catch (Exception e) {
-            Log.e(TAG, "Exception while sending message", e);
-            return false;
-        }
-        return true;
-    }
-
-    // SET_VOLUME messages have a |level| and |muted| properties. One of them is
-    // |null| and the other one isn't. |muted| is expected to be a boolean while
-    // |level| is a float from 0.0 to 1.0.
-    // Example:
-    // {
-    //   "volume" {
-    //     "level": 0.9,
-    //     "muted": null
-    //   }
-    // }
-    @Override
-    public HandleVolumeMessageResult handleVolumeMessage(
-            JSONObject volume, final String clientId, final int sequenceNumber)
-            throws JSONException {
-        if (volume == null) return new HandleVolumeMessageResult(false, false);
-
-        if (isApiClientInvalid()) return new HandleVolumeMessageResult(false, false);
-
-        boolean waitForVolumeChange = false;
-        try {
-            if (!volume.isNull("muted")) {
-                boolean newMuted = volume.getBoolean("muted");
-                if (Cast.CastApi.isMute(mApiClient) != newMuted) {
-                    Cast.CastApi.setMute(mApiClient, newMuted);
-                    waitForVolumeChange = true;
-                }
-            }
-            if (!volume.isNull("level")) {
-                double newLevel = volume.getDouble("level");
-                double currentLevel = Cast.CastApi.getVolume(mApiClient);
-                if (!Double.isNaN(currentLevel)
-                        && Math.abs(currentLevel - newLevel) > MIN_VOLUME_LEVEL_DELTA) {
-                    Cast.CastApi.setVolume(mApiClient, newLevel);
-                    waitForVolumeChange = true;
-                }
-            }
-        } catch (IOException e) {
-            Log.e(TAG, "Failed to send volume command: " + e);
-            return new HandleVolumeMessageResult(false, false);
-        }
-
-        return new HandleVolumeMessageResult(true, waitForVolumeChange);
-    }
-
-    @Override
-    public void stopApplication() {
-        if (mStoppingApplication) return;
-
-        if (isApiClientInvalid()) return;
-
-        mStoppingApplication = true;
-        Cast.CastApi.stopApplication(mApiClient, mSessionId)
-                .setResultCallback(new ResultCallback<Status>() {
-                    @Override
-                    public void onResult(Status status) {
-                        mMessageHandler.onApplicationStopped();
-                        // TODO(avayvod): handle a failure to stop the application.
-                        // https://crbug.com/535577
-
-                        Set<String> namespaces = new HashSet<String>(mNamespaces);
-                        for (String namespace : namespaces) unregisterNamespace(namespace);
-                        mNamespaces.clear();
-
-                        mSessionId = null;
-                        mApiClient = null;
-
-                        ChromeCastSessionManager.get().onSessionEnded();
-                        mStoppingApplication = false;
-
-                        MediaNotificationManager.clear(R.id.presentation_notification);
-                    }
-                });
-    }
-
-    @Override
-    public void onMediaMessage(String message) {
-        if (mMediaPlayer != null) {
-            mMediaPlayer.onMessageReceived(mCastDevice, CastSessionUtil.MEDIA_NAMESPACE, message);
-        }
-    }
-
-    @Override
-    public void onVolumeChanged() {
-        mMessageHandler.onVolumeChanged();
-    }
-
-    @Override
-    public void updateSessionStatus() {
-        if (isApiClientInvalid()) return;
-
-        try {
-            mApplicationStatus = Cast.CastApi.getApplicationStatus(mApiClient);
-            mApplicationMetadata = Cast.CastApi.getApplicationMetadata(mApiClient);
-
-            updateNamespaces();
-
-            mMessageHandler.broadcastClientMessage(
-                    "update_session", mMessageHandler.buildSessionMessage());
-        } catch (IllegalStateException e) {
-            Log.e(TAG, "Can't get application status", e);
-        }
-    }
-
-    @Override
-    public void onClientConnected(String clientId) {
-        mMessageHandler.sendClientMessageTo(
-                clientId, "new_session", mMessageHandler.buildSessionMessage(),
-                CastMessageHandler.INVALID_SEQUENCE_NUMBER);
-
-        if (mMediaPlayer != null && !isApiClientInvalid()) mMediaPlayer.requestStatus(mApiClient);
-    }
-
-    @Override
-    public MediaController getMediaController() {
-        // MediaController is not used with the CastSessionImpl.
-        return null;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionInfo.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionInfo.java
deleted file mode 100644
index 3ef11cf..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionInfo.java
+++ /dev/null
@@ -1,324 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * The metadata information of {@link CastSession}.
- */
-public class CastSessionInfo {
-    /**
-     * The volume information of receivers.
-     */
-    public static class VolumeInfo {
-        /**
-         * The receiver volume.
-         */
-        public final double level;
-        /**
-         * Whether the receiver is muted.
-         */
-        public final boolean muted;
-
-        /**
-         * Use this class to construct an instance of {@link VolumeInfo}.
-         */
-        public static class Builder {
-            private double mLevel;
-            private boolean mMuted;
-
-            public Builder setLevel(double level) {
-                mLevel = level;
-                return this;
-            }
-
-            public Builder setMuted(boolean muted) {
-                mMuted = muted;
-                return this;
-            }
-
-            /**
-             * Initializes the builder with the default values.
-             */
-            public Builder() {
-            }
-
-            public VolumeInfo build() {
-                return new VolumeInfo(mLevel, mMuted);
-            }
-        }
-
-        private VolumeInfo(double level, boolean muted) {
-            this.level = level;
-            this.muted = muted;
-        }
-    }
-
-    /**
-     * The receiver information.
-     */
-    public static class ReceiverInfo {
-        /**
-         * Label of the receiver.
-         */
-        public final String label;
-        /**
-         * The friendly name of the receiver.
-         */
-        public final String friendlyName;
-        /**
-         * Receiver capabilities.
-         */
-        public final List<String> capabilities;
-        /**
-         * Receiver volume information.
-         */
-        public final VolumeInfo volume;
-        /**
-         * The receiver device's active-input state.
-         */
-        public final int isActiveInput;
-        /**
-         * The display status of the receiver.
-         */
-        public final String displayStatus;
-        /**
-         * The type of the receiver.
-         */
-        public final String receiverType;
-
-        /**
-         * Use this class to create an instance of {@link ReceiverInfo}.
-         */
-        public static class Builder {
-            private String mLabel = "";
-            private String mFriendlyName = "";
-            private List<String> mCapabilities = new ArrayList<String>();
-            private VolumeInfo mVolume;
-            private int mIsActiveInput;
-            private String mDisplayStatus = "";
-            private String mReceiverType = "";
-
-            public Builder setLabel(String label) {
-                mLabel = label;
-                return this;
-            }
-
-            public Builder setFriendlyName(String friendlyName) {
-                mFriendlyName = friendlyName;
-                return this;
-            }
-
-            public Builder addCapability(String capability) {
-                mCapabilities.add(capability);
-                return this;
-            }
-
-            public Builder addCapabilities(Collection<String> capabilities) {
-                mCapabilities.addAll(capabilities);
-                return this;
-            }
-
-            public Builder setVolume(VolumeInfo volume) {
-                mVolume = volume;
-                return this;
-            }
-
-            public Builder setIsActiveInput(int isActiveInput) {
-                mIsActiveInput = isActiveInput;
-                return this;
-            }
-
-            public Builder setDisplayStatus(String displayStatus) {
-                mDisplayStatus = displayStatus;
-                return this;
-            }
-
-            public Builder setReceiverType(String receiverType) {
-                mReceiverType = receiverType;
-                return this;
-            }
-
-            /**
-             * Initializes the builder with the default values.
-             */
-            public Builder() {
-            }
-
-            public ReceiverInfo build() {
-                return new ReceiverInfo(
-                        mLabel,
-                        mFriendlyName,
-                        mCapabilities,
-                        mVolume,
-                        mIsActiveInput,
-                        mDisplayStatus,
-                        mReceiverType);
-            }
-        }
-
-        private ReceiverInfo(
-                String label,
-                String friendlyName,
-                List<String> capabilities,
-                VolumeInfo volume,
-                int isActiveInput,
-                String displayStatus,
-                String receiverType) {
-            this.label = label;
-            this.friendlyName = friendlyName;
-            this.capabilities = capabilities;
-            this.volume = volume;
-            this.isActiveInput = isActiveInput;
-            this.displayStatus = displayStatus;
-            this.receiverType = receiverType;
-        }
-    }
-
-    /**
-     * The id of the {@link CastSession}.
-     */
-    public final String sessionId;
-    /**
-     * The application status (in Cast SDK) of the {@link CastSession}.
-     */
-    public final String statusText;
-    /**
-     * The receiver information of the {@link CastSession}.
-     */
-    public final ReceiverInfo receiver;
-    /**
-     * The namespaces registered in the {@link CastSession}.
-     */
-    public final List<String> namespaces;
-    /**
-     * The media in the {@link CastSession}.
-     */
-    public final List<String> media;
-    /**
-     * The status of the {@link CastSession}.
-     */
-    public final String status;
-    /**
-     * The tranport id of the {@link CastSession}.
-     */
-    public final String transportId;
-    /**
-     * The app id of the {@link CastSession}.
-     */
-    public final String appId;
-    /**
-     * The display name of the {@link CastSession}.
-     */
-    public final String displayName;
-
-    /**
-     * Use this class to create an instance of {@link CastSessionInfo}.
-     */
-    public static class Builder {
-        private String mSessionId = "";
-        private String mStatusText = "";
-        private ReceiverInfo mReceiver;
-        private List<String> mNamespaces = new ArrayList<String>();
-        private List<String> mMedia = new ArrayList<String>();
-        private String mStatus = "";
-        private String mTransportId = "";
-        private String mAppId = "";
-        private String mDisplayName = "";
-
-        public Builder setSessionId(String sessionId) {
-            mSessionId = sessionId;
-            return this;
-        }
-
-        public Builder setStatusText(String statusText) {
-            mStatusText = statusText;
-            return this;
-        }
-
-        public Builder setReceiver(ReceiverInfo receiver) {
-            mReceiver = receiver;
-            return this;
-        }
-
-        public Builder addNamespace(String namespace) {
-            mNamespaces.add(namespace);
-            return this;
-        }
-
-        public Builder addNamespaces(Collection<String> namespaces) {
-            mNamespaces.addAll(namespaces);
-            return this;
-        }
-
-        public Builder addMedia(String namespace) {
-            mMedia.add(namespace);
-            return this;
-        }
-
-        public Builder setStatus(String status) {
-            mStatus = status;
-            return this;
-        }
-
-        public Builder setTransportId(String transportId) {
-            mTransportId = transportId;
-            return this;
-        }
-
-        public Builder setAppId(String appId) {
-            mAppId = appId;
-            return this;
-        }
-
-        public Builder setDisplayName(String displayName) {
-            mDisplayName = displayName;
-            return this;
-        }
-
-        /**
-         * Initializes the builder with the default values.
-         */
-        public Builder() {
-        }
-
-        public CastSessionInfo build() {
-            return new CastSessionInfo(
-                    mSessionId,
-                    mStatusText,
-                    mReceiver,
-                    mNamespaces,
-                    mMedia,
-                    mStatus,
-                    mTransportId,
-                    mAppId,
-                    mDisplayName);
-        }
-    }
-
-    private CastSessionInfo(
-            String sessionId,
-            String statusText,
-            ReceiverInfo receiver,
-            List<String> namespaces,
-            List<String> media,
-            String status,
-            String transportId,
-            String appId,
-            String displayName) {
-        this.sessionId = sessionId;
-        this.statusText = statusText;
-        this.receiver = receiver;
-        this.namespaces = namespaces;
-        this.media = media;
-        this.status = status;
-        this.transportId = transportId;
-        this.appId = appId;
-        this.displayName = displayName;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionUtil.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionUtil.java
deleted file mode 100644
index cc24e95..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CastSessionUtil.java
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright 2018 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import com.google.android.gms.cast.CastDevice;
-import com.google.android.gms.cast.RemoteMediaPlayer;
-
-import org.chromium.chrome.browser.media.ui.MediaNotificationInfo;
-import org.chromium.content_public.common.MediaMetadata;
-
-/**
- * Helper class that implements functions useful to all CastSession types.
- */
-public class CastSessionUtil {
-    public static final String MEDIA_NAMESPACE = "urn:x-cast:com.google.cast.media";
-
-    /**
-     * Builds a MediaMetadata from the given CastDevice and MediaPlayer, and sets it on the builder
-     */
-    public static void setNotificationMetadata(MediaNotificationInfo.Builder builder,
-            CastDevice castDevice, RemoteMediaPlayer mediaPlayer) {
-        MediaMetadata notificationMetadata = new MediaMetadata("", "", "");
-        builder.setMetadata(notificationMetadata);
-
-        if (castDevice != null) notificationMetadata.setTitle(castDevice.getFriendlyName());
-
-        if (mediaPlayer == null) return;
-
-        com.google.android.gms.cast.MediaInfo info = mediaPlayer.getMediaInfo();
-        if (info == null) return;
-
-        com.google.android.gms.cast.MediaMetadata metadata = info.getMetadata();
-        if (metadata == null) return;
-
-        String title = metadata.getString(com.google.android.gms.cast.MediaMetadata.KEY_TITLE);
-        if (title != null) notificationMetadata.setTitle(title);
-
-        String artist = metadata.getString(com.google.android.gms.cast.MediaMetadata.KEY_ARTIST);
-        if (artist == null) {
-            artist = metadata.getString(com.google.android.gms.cast.MediaMetadata.KEY_ALBUM_ARTIST);
-        }
-        if (artist != null) notificationMetadata.setArtist(artist);
-
-        String album =
-                metadata.getString(com.google.android.gms.cast.MediaMetadata.KEY_ALBUM_TITLE);
-        if (album != null) notificationMetadata.setAlbum(album);
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/ChromeCastSessionManager.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/ChromeCastSessionManager.java
deleted file mode 100644
index eddd689..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/ChromeCastSessionManager.java
+++ /dev/null
@@ -1,230 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.annotation.SuppressLint;
-
-import com.google.android.gms.cast.ApplicationMetadata;
-import com.google.android.gms.cast.Cast;
-import com.google.android.gms.cast.CastStatusCodes;
-
-import org.chromium.base.Log;
-
-/**
- * Manages the lifetime of the active CastSessions and broadcasts state changes to observers.
- */
-public class ChromeCastSessionManager {
-    private static final String TAG = "cr_CastSessionMgr";
-
-    // Singleton instance.
-    private static ChromeCastSessionManager sInstance;
-
-    /**
-     * Defines the events relevant to CastSession state changes.
-     * NOTE: This interface is modeled after Cast SDK V3's SessionManagerListener, but does not map
-     * exactly to it.
-     */
-    public interface CastSessionManagerListener {
-        // Called right before a session launch is started.
-        public void onSessionStarting(
-                ChromeCastSessionManager.CastSessionLaunchRequest originalRequest);
-
-        // Called after a successful session launch.
-        public void onSessionStarted(CastSession session);
-
-        // Called after a failed session launch.
-        public void onSessionStartFailed();
-
-        // Called when a session is shutting down (as a result of user action, or when a new
-        // session is being launched).
-        public void onSessionStopAction();
-
-        // Called after a session has shut down.
-        public void onSessionEnded();
-    }
-
-    /**
-     * Encapsulates a request to start a cast session. Mostly used to simplify testing.
-     */
-    public interface CastSessionLaunchRequest {
-        // Starts the request.
-        // Success or failure will be reported to the ChromeCastSessionManager via the
-        // onSessionStarted() and onSessionStartFailed() calls.
-        public void start(Cast.Listener listener);
-
-        // Gets the session observer that should be notified of the session launch.
-        public CastSessionManagerListener getSessionListener();
-    }
-
-    private class CastListener extends Cast.Listener {
-        private CastSession mSession;
-
-        CastListener() {}
-
-        void setSession(CastSession session) {
-            mSession = session;
-        }
-
-        @Override
-        public void onApplicationStatusChanged() {
-            if (mSession == null) return;
-
-            mSession.updateSessionStatus();
-        }
-
-        @Override
-        public void onApplicationMetadataChanged(ApplicationMetadata metadata) {
-            if (mSession == null) return;
-
-            mSession.updateSessionStatus();
-        }
-
-        // TODO(https://crbug.com/635567): Fix this properly.
-        @Override
-        @SuppressLint("DefaultLocale")
-        public void onApplicationDisconnected(int errorCode) {
-            if (errorCode != CastStatusCodes.SUCCESS) {
-                Log.e(TAG, String.format("Application disconnected with: %d", errorCode));
-            }
-
-            // This callback can be called more than once if the application is stopped from Chrome.
-            if (mSession == null) return;
-
-            mSession.stopApplication();
-            mSession = null;
-        }
-
-        @Override
-        public void onVolumeChanged() {
-            if (mSession == null) return;
-
-            mSession.onVolumeChanged();
-        }
-    }
-
-    // The current active session. There can only be one active session on Android.
-    // NOTE: This is a Chromium abstraction, different from the Cast SDK CastSession.
-    private CastSession mSession;
-
-    // Listener tied to |mSession|.
-    private CastListener mListener;
-
-    // Request to be started once |mSession| is stopped.
-    private CastSessionLaunchRequest mPendingSessionLaunchRequest;
-
-    // Object that initiated the current cast session and that should be notified
-    // of changes to the session.
-    private CastSessionManagerListener mCurrentSessionListener;
-
-    // Whether we are currently in the process of launching a session.
-    private boolean mSessionLaunching = false;
-
-    public static ChromeCastSessionManager get() {
-        if (sInstance == null) sInstance = new ChromeCastSessionManager();
-
-        return sInstance;
-    }
-
-    /**
-     * Should only be used for testing purposes.
-     */
-    public static void resetInstanceForTesting() {
-        sInstance = null;
-    }
-
-    private ChromeCastSessionManager() {}
-
-    /**
-     * Called after a session successfully launched and was created.
-     * @param session the newly created session.
-     */
-    public void onSessionStarted(CastSession session) {
-        assert mSession == null;
-
-        mSession = session;
-        mSessionLaunching = false;
-        mCurrentSessionListener.onSessionStarted(session);
-    }
-
-    /**
-     * Called to initiate a new session launch. Will stop the current session if it exists.
-     * Calls back into onSessionStarting().
-     * Calling this method when we already have a session will stop that session first.
-     * Requests will be dropped if we are in the process of launching a new session.
-     * @param request the encapsulated information required to launch the session.
-     */
-    public void requestSessionLaunch(CastSessionLaunchRequest request) {
-        // Do not attempt to launch more than one session at a time.
-        if (mSessionLaunching) return;
-
-        // Since we only can only have one session, close it before starting a new one.
-        if (mSession != null) {
-            mPendingSessionLaunchRequest = request;
-            mSession.stopApplication();
-            return;
-        }
-
-        launchSession(request);
-    }
-
-    /**
-     * Stops the current session.
-     */
-    public void stopApplication() {
-        mSession.stopApplication();
-    }
-
-    /**
-     * Starts the session request.
-     * Will result in a call to onSessionStarted() or onSessionStartFailed() based on the
-     * success/failure of the launch.
-     */
-    private void launchSession(CastSessionLaunchRequest request) {
-        assert mSession == null;
-
-        mSessionLaunching = true;
-
-        mCurrentSessionListener = request.getSessionListener();
-        mCurrentSessionListener.onSessionStarting(request);
-
-        mListener = new CastListener();
-
-        request.start(mListener);
-    }
-
-    /**
-     * Called when the session has received a stop action.
-     */
-    public void onSessionStopAction() {
-        mCurrentSessionListener.onSessionStopAction();
-    }
-
-    /**
-     * Called when the session has ended. The session may no longer be valid at this point.
-     */
-    public void onSessionEnded() {
-        mCurrentSessionListener.onSessionEnded();
-
-        mSession = null;
-        mCurrentSessionListener = null;
-        mListener = null;
-
-        if (mPendingSessionLaunchRequest != null) {
-            launchSession(mPendingSessionLaunchRequest);
-            mPendingSessionLaunchRequest = null;
-        }
-    }
-
-    /**
-     * Called when the session has failed to launch.
-     */
-    public void onSessionStartFailed() {
-        mCurrentSessionListener.onSessionStartFailed();
-        mCurrentSessionListener = null;
-        mListener = null;
-
-        mSessionLaunching = false;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/ClientRecord.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/ClientRecord.java
deleted file mode 100644
index b3d43cf..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/ClientRecord.java
+++ /dev/null
@@ -1,70 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import org.chromium.chrome.browser.media.router.MediaRoute;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Contains information about a single client connection to the {@link MediaRoute}.
- */
-public class ClientRecord {
-    /**
-     * The route id through which the client is connected. Should be a 1:1 relationship.
-     */
-    public final String routeId;
-
-    /**
-     * The unique id of this client.
-     */
-    public final String clientId;
-
-    /**
-     * The Cast application id for this client.
-     */
-    public final String appId;
-
-    /**
-     * Defines the ways other clients can join or leave the corresponding session.
-     */
-    public final String autoJoinPolicy;
-
-    /**
-     * The origin of the frame that created/joined the route.
-     */
-    public final String origin;
-
-    /**
-     * The id of the tab that created/joined the route.
-     */
-    public final int tabId;
-
-    /**
-     * Whether the client is ready to receive messages.
-     */
-    public boolean isConnected;
-
-    /**
-     * The pending messages for the client.
-     */
-    public List<String> pendingMessages = new ArrayList<String>();
-
-    ClientRecord(
-            String routeId,
-            String clientId,
-            String appId,
-            String autoJoinPolicy,
-            String origin,
-            int tabId) {
-        this.routeId = routeId;
-        this.clientId = clientId;
-        this.appId = appId;
-        this.autoJoinPolicy = autoJoinPolicy;
-        this.origin = origin;
-        this.tabId = tabId;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CreateRouteRequest.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CreateRouteRequest.java
deleted file mode 100644
index e434693..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/CreateRouteRequest.java
+++ /dev/null
@@ -1,270 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.annotation.SuppressLint;
-import android.os.Bundle;
-
-import com.google.android.gms.cast.Cast;
-import com.google.android.gms.cast.LaunchOptions;
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.common.api.PendingResult;
-import com.google.android.gms.common.api.ResultCallback;
-import com.google.android.gms.common.api.Status;
-
-import org.chromium.base.ContextUtils;
-import org.chromium.base.Log;
-import org.chromium.chrome.browser.media.router.ChromeMediaRouter;
-import org.chromium.chrome.browser.media.router.MediaRoute;
-import org.chromium.chrome.browser.media.router.cast.remoting.RemotingCastSession;
-
-import javax.annotation.Nullable;
-
-/**
- * Establishes a {@link MediaRoute} by starting a Cast application represented by the given
- * presentation URL. Reports success or failure to {@link ChromeMediaRouter}.
- * Since there're numerous asynchronous calls involved in getting the application to launch
- * the class is implemented as a state machine.
- */
-public class CreateRouteRequest implements GoogleApiClient.ConnectionCallbacks,
-                                           GoogleApiClient.OnConnectionFailedListener,
-                                           ResultCallback<Cast.ApplicationConnectionResult>,
-                                           ChromeCastSessionManager.CastSessionLaunchRequest {
-    private static final String TAG = "MediaRouter";
-
-    private static final int STATE_IDLE = 0;
-    private static final int STATE_CONNECTING_TO_API = 1;
-    private static final int STATE_API_CONNECTION_SUSPENDED = 2;
-    private static final int STATE_LAUNCHING_APPLICATION = 3;
-    private static final int STATE_LAUNCH_SUCCEEDED = 4;
-    private static final int STATE_TERMINATED = 5;
-
-    private final MediaSource mSource;
-    private final MediaSink mSink;
-    private final String mPresentationId;
-    private final String mOrigin;
-    private final int mTabId;
-    private final boolean mIsIncognito;
-    private final int mRequestId;
-    private final CastMessageHandler mMessageHandler;
-    private final ChromeCastSessionManager.CastSessionManagerListener mSessionListener;
-    private final RequestedCastSessionType mSessionType;
-
-    private GoogleApiClient mApiClient;
-    private int mState = STATE_IDLE;
-
-    // Used to identify whether the request should launch a CastSessionImpl or a RemotingCastSession
-    // (based off of wheter the route creation was requested by a RemotingMediaRouteProvider or a
-    // CastMediaRouteProvider).
-    public enum RequestedCastSessionType { CAST, REMOTE }
-
-    /**
-     * Initializes the request.
-     * @param source The {@link MediaSource} defining the application to launch on the Cast device.
-     * @param sink The {@link MediaSink} identifying the selected Cast device.
-     * @param presentationId The presentation id assigned to the route by {@link ChromeMediaRouter}.
-     * @param origin The origin of the frame requesting the route.
-     * @param tabId The id of the tab containing the frame requesting the route.
-     * @param isIncognito Whether the route is being requested from an Incognito profile.
-     * @param requestId The id of the route creation request for tracking by
-     * {@link ChromeMediaRouter}.
-     * @param listener The listener that should be notified of session/route creation changes.
-     * @param messageHandler A message handler (used to create CastSessionImpl instances).
-     */
-    public CreateRouteRequest(MediaSource source, MediaSink sink, String presentationId,
-            String origin, int tabId, boolean isIncognito, int requestId,
-            ChromeCastSessionManager.CastSessionManagerListener listener,
-            RequestedCastSessionType sessionType, @Nullable CastMessageHandler messageHandler) {
-        assert source != null;
-        assert sink != null;
-
-        mSource = source;
-        mSink = sink;
-        mPresentationId = presentationId;
-        mOrigin = origin;
-        mTabId = tabId;
-        mIsIncognito = isIncognito;
-        mRequestId = requestId;
-        mSessionListener = listener;
-        mSessionType = sessionType;
-        mMessageHandler = messageHandler;
-    }
-
-    public MediaSource getSource() {
-        return mSource;
-    }
-
-    public MediaSink getSink() {
-        return mSink;
-    }
-
-    public String getPresentationId() {
-        return mPresentationId;
-    }
-
-    public String getOrigin() {
-        return mOrigin;
-    }
-
-    public int getTabId() {
-        return mTabId;
-    }
-
-    public boolean isIncognito() {
-        return mIsIncognito;
-    }
-
-    public int getNativeRequestId() {
-        return mRequestId;
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // ChromeCastSessionManager.CastSessionLaunchRequest implementation.
-
-    /**
-     * Returns the object that should be notified of session changes that result
-     * from this route creation request.
-     */
-    @Override
-    public ChromeCastSessionManager.CastSessionManagerListener getSessionListener() {
-        return mSessionListener;
-    }
-
-    /**
-     * Starts the process of launching the application on the Cast device.
-     */
-    @Override
-    public void start(Cast.Listener castListener) {
-        if (mState != STATE_IDLE) throwInvalidState();
-
-        mApiClient = createApiClient(castListener);
-        mApiClient.connect();
-        mState = STATE_CONNECTING_TO_API;
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // GoogleApiClient.* implementations.
-
-    @Override
-    public void onConnected(Bundle connectionHint) {
-        if (mState != STATE_CONNECTING_TO_API && mState != STATE_API_CONNECTION_SUSPENDED) {
-            throwInvalidState();
-        }
-
-        if (mState == STATE_API_CONNECTION_SUSPENDED) return;
-
-        try {
-            launchApplication(mApiClient, mSource.getApplicationId(), true)
-                    .setResultCallback(this);
-            mState = STATE_LAUNCHING_APPLICATION;
-        } catch (Exception e) {
-            Log.e(TAG, "Launch application failed: %s", mSource.getApplicationId(), e);
-            reportError();
-        }
-    }
-
-    @Override
-    public void onConnectionSuspended(int cause) {
-        mState = STATE_API_CONNECTION_SUSPENDED;
-    }
-
-    @Override
-    public void onConnectionFailed(ConnectionResult result) {
-        if (mState != STATE_CONNECTING_TO_API) throwInvalidState();
-
-        Log.e(TAG, "GoogleApiClient connection failed: %d, %b", result.getErrorCode(),
-                result.hasResolution());
-        reportError();
-    }
-
-    /**
-     * ResultCallback<Cast.ApplicationConnectionResult> implementation.
-     */
-    @Override
-    public void onResult(Cast.ApplicationConnectionResult result) {
-        if (mState != STATE_LAUNCHING_APPLICATION
-                && mState != STATE_API_CONNECTION_SUSPENDED) {
-            throwInvalidState();
-        }
-
-        Status status = result.getStatus();
-        if (!status.isSuccess()) {
-            Log.e(TAG, "Launch application failed with status: %s, %d, %s",
-                    mSource.getApplicationId(), status.getStatusCode(), status.getStatusMessage());
-            reportError();
-            return;
-        }
-
-        mState = STATE_LAUNCH_SUCCEEDED;
-        reportSuccess(result);
-    }
-
-    private GoogleApiClient createApiClient(Cast.Listener listener) {
-        Cast.CastOptions.Builder apiOptionsBuilder =
-                new Cast.CastOptions.Builder(mSink.getDevice(), listener)
-                         // TODO(avayvod): hide this behind the flag or remove
-                         .setVerboseLoggingEnabled(true);
-
-        return new GoogleApiClient.Builder(ContextUtils.getApplicationContext())
-                .addApi(Cast.API, apiOptionsBuilder.build())
-                .addConnectionCallbacks(this)
-                .addOnConnectionFailedListener(this)
-                .build();
-    }
-
-    private PendingResult<Cast.ApplicationConnectionResult> launchApplication(
-            GoogleApiClient apiClient,
-            String appId,
-            boolean relaunchIfRunning) {
-        LaunchOptions.Builder builder = new LaunchOptions.Builder();
-        return Cast.CastApi.launchApplication(apiClient, appId,
-                builder.setRelaunchIfRunning(relaunchIfRunning)
-                        .build());
-    }
-
-    // TODO(crbug.com/635567): Fix this properly.
-    @SuppressLint("DefaultLocale")
-    private void throwInvalidState() {
-        throw new RuntimeException(String.format("Invalid state: %d", mState));
-    }
-
-    private void reportSuccess(Cast.ApplicationConnectionResult result) {
-        if (mState != STATE_LAUNCH_SUCCEEDED) throwInvalidState();
-
-        CastSession session = null;
-
-        switch (mSessionType) {
-            case CAST:
-                session = new CastSessionImpl(mApiClient, result.getSessionId(),
-                        result.getApplicationMetadata(), result.getApplicationStatus(),
-                        mSink.getDevice(), mOrigin, mTabId, mIsIncognito, mSource, mMessageHandler);
-                break;
-            case REMOTE:
-                session = new RemotingCastSession(mApiClient, result.getSessionId(),
-                        result.getApplicationMetadata(), result.getApplicationStatus(),
-                        mSink.getDevice(), mOrigin, mTabId, mIsIncognito, mSource);
-                break;
-        }
-
-        ChromeCastSessionManager.get().onSessionStarted(session);
-
-        terminate();
-    }
-
-    private void reportError() {
-        if (mState == STATE_TERMINATED) throwInvalidState();
-
-        ChromeCastSessionManager.get().onSessionStartFailed();
-
-        terminate();
-    }
-
-    private void terminate() {
-        mApiClient.unregisterConnectionCallbacks(this);
-        mApiClient.unregisterConnectionFailedListener(this);
-        mState = STATE_TERMINATED;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/DiscoveryCallback.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/DiscoveryCallback.java
deleted file mode 100644
index 53905fa..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/DiscoveryCallback.java
+++ /dev/null
@@ -1,90 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.support.v7.media.MediaRouteSelector;
-import android.support.v7.media.MediaRouter;
-
-import org.chromium.chrome.browser.media.router.DiscoveryDelegate;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- * Callback for discovering routes with one particular filter. Keeps a set of all source URIs that
- * media sinks were requested for. Once a route is added or removed, updates the
- * {@link ChromeMediaRouter} with the new routes.
- */
-public class DiscoveryCallback extends MediaRouter.Callback {
-    private final DiscoveryDelegate mDiscoveryDelegate;
-    private final MediaRouteSelector mRouteSelector;
-    private Set<String> mSourceUrns = new HashSet<String>();
-    private List<MediaSink> mSinks = new ArrayList<MediaSink>();
-
-    public DiscoveryCallback(String sourceUrn, List<MediaSink> knownSinks,
-            DiscoveryDelegate delegate, MediaRouteSelector selector) {
-        assert delegate != null;
-        assert sourceUrn != null && !sourceUrn.isEmpty();
-
-        mSinks.addAll(knownSinks);
-        mDiscoveryDelegate = delegate;
-        mRouteSelector = selector;
-
-        addSourceUrn(sourceUrn);
-    }
-
-    public void addSourceUrn(String sourceUrn) {
-        if (mSourceUrns.add(sourceUrn)) {
-            mDiscoveryDelegate.onSinksReceived(sourceUrn, new ArrayList<MediaSink>(mSinks));
-        }
-    }
-
-    public void removeSourceUrn(String sourceUrn) {
-        mSourceUrns.remove(sourceUrn);
-    }
-
-    public boolean isEmpty() {
-        return mSourceUrns.isEmpty();
-    }
-
-    @Override
-    public void onRouteAdded(MediaRouter router, MediaRouter.RouteInfo route) {
-        if (route == null || !route.matchesSelector(mRouteSelector)) return;
-
-        MediaSink sink = MediaSink.fromRoute(route);
-        if (mSinks.contains(sink)) return;
-        mSinks.add(sink);
-        updateChromeMediaRouter();
-    }
-
-    @Override
-    public void onRouteRemoved(MediaRouter router, MediaRouter.RouteInfo route) {
-        MediaSink sink = MediaSink.fromRoute(route);
-        if (!mSinks.contains(sink)) return;
-        mSinks.remove(sink);
-        updateChromeMediaRouter();
-    }
-
-    @Override
-    public void onRouteChanged(MediaRouter router, MediaRouter.RouteInfo route) {
-        // Sometimes onRouteAdded is not called for the route as it doesn't yet match the selector.
-        // onRouteChanged() will be called later when the matching category is added.
-        if (route == null) return;
-
-        if (route.matchesSelector(mRouteSelector)) {
-            onRouteAdded(router, route);
-        } else {
-            onRouteRemoved(router, route);
-        }
-    }
-
-    private void updateChromeMediaRouter() {
-        for (String sourceUrn : mSourceUrns) {
-            mDiscoveryDelegate.onSinksReceived(sourceUrn, new ArrayList<MediaSink>(mSinks));
-        }
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/MediaSink.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/MediaSink.java
index 7bb6985..066e181 100644
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/MediaSink.java
+++ b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/MediaSink.java
@@ -7,7 +7,6 @@ package org.chromium.chrome.browser.media.router.cast;
 import android.support.v7.media.MediaRouter;
 import android.support.v7.media.MediaRouter.RouteInfo;
 
-import com.google.android.gms.cast.CastDevice;
 
 import javax.annotation.Nullable;
 
@@ -18,18 +17,15 @@ public class MediaSink {
     private static final String CAST_SINK_URN_PREFIX = "urn:x-org.chromium:media:sink:cast-";
     private final String mId;
     private final String mName;
-    private final CastDevice mDevice;
 
     /**
      * Constructor.
      * @param id A unique identifier of the sink.
      * @param name A user friendly name of the sink.
-     * @param device {@link CastDevice} corresponding to this sink.
      */
-    public MediaSink(String id, String name, CastDevice device) {
+    public MediaSink(String id, String name) {
         mId = id;
         mName = name;
-        mDevice = device;
     }
 
     /**
@@ -53,10 +49,6 @@ public class MediaSink {
         return CAST_SINK_URN_PREFIX + getId();
     }
 
-    public CastDevice getDevice() {
-        return mDevice;
-    }
-
     @Override
     public boolean equals(Object o) {
         if (o == this) return true;
@@ -88,8 +80,7 @@ public class MediaSink {
     public static MediaSink fromRoute(MediaRouter.RouteInfo route) {
         return new MediaSink(
             route.getId(),
-            route.getName(),
-            CastDevice.getFromBundle(route.getExtras()));
+            route.getName());
     }
 
     /**
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/MediaSource.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/MediaSource.java
deleted file mode 100644
index bc82093..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/MediaSource.java
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast;
-
-import android.support.v7.media.MediaRouteSelector;
-
-/**
- * Abstracts parsing the Cast application id and other parameters from the source URN.
- */
-public interface MediaSource {
-    /**
-     * Returns a new {@link MediaRouteSelector} to use for Cast device filtering for this
-     * particular media source or null if the application id is invalid.
-     *
-     * @return an initialized route selector or null.
-     */
-    public MediaRouteSelector buildRouteSelector();
-
-    /**
-     * @return the Cast application id corresponding to the source.
-     */
-    public String getApplicationId();
-
-    /**
-     * @return the id identifying the media source
-     */
-    public String getSourceId();
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingCastSession.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingCastSession.java
deleted file mode 100644
index db97951..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingCastSession.java
+++ /dev/null
@@ -1,192 +0,0 @@
-// Copyright 2018 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package org.chromium.chrome.browser.media.router.cast.remoting;
-
-import com.google.android.gms.cast.ApplicationMetadata;
-import com.google.android.gms.cast.Cast;
-import com.google.android.gms.cast.CastDevice;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.common.api.ResultCallback;
-import com.google.android.gms.common.api.Status;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import org.chromium.chrome.R;
-import org.chromium.chrome.browser.media.remote.RemoteMediaPlayerWrapper;
-import org.chromium.chrome.browser.media.router.MediaController;
-import org.chromium.chrome.browser.media.router.cast.CastMessageHandler;
-import org.chromium.chrome.browser.media.router.cast.CastSession;
-import org.chromium.chrome.browser.media.router.cast.CastSessionInfo;
-import org.chromium.chrome.browser.media.router.cast.ChromeCastSessionManager;
-import org.chromium.chrome.browser.media.router.cast.MediaSource;
-import org.chromium.chrome.browser.media.ui.MediaNotificationInfo;
-import org.chromium.chrome.browser.media.ui.MediaNotificationListener;
-import org.chromium.chrome.browser.media.ui.MediaNotificationManager;
-
-import java.util.HashSet;
-import java.util.Set;
-
-/**
- * A wrapper around a RemoteMediaPlayer, used in remote playback.
- */
-public class RemotingCastSession implements MediaNotificationListener, CastSession {
-    private final CastDevice mCastDevice;
-    private final MediaSource mSource;
-
-    private GoogleApiClient mApiClient;
-    private String mSessionId;
-    private String mApplicationStatus;
-    private ApplicationMetadata mApplicationMetadata;
-    private MediaNotificationInfo.Builder mNotificationBuilder;
-    private RemoteMediaPlayerWrapper mMediaPlayerWrapper;
-    private boolean mStoppingApplication = false;
-
-    public RemotingCastSession(GoogleApiClient apiClient, String sessionId,
-            ApplicationMetadata metadata, String applicationStatus, CastDevice castDevice,
-            String origin, int tabId, boolean isIncognito, MediaSource source) {
-        mCastDevice = castDevice;
-        mSource = source;
-        mApiClient = apiClient;
-        mApplicationMetadata = metadata;
-        mSessionId = sessionId;
-
-        mNotificationBuilder =
-                new MediaNotificationInfo.Builder()
-                        .setPaused(false)
-                        .setOrigin(origin)
-                        // TODO(avayvod): the same session might have more than one tab id. Should
-                        // we track the last foreground alive tab and update the notification with
-                        // it?
-                        .setTabId(tabId)
-                        .setPrivate(isIncognito)
-                        .setActions(MediaNotificationInfo.ACTION_STOP)
-                        .setNotificationSmallIcon(R.drawable.ic_notification_media_route)
-                        .setDefaultNotificationLargeIcon(R.drawable.cast_playing_square)
-                        .setId(R.id.presentation_notification)
-                        .setListener(this);
-
-        mMediaPlayerWrapper =
-                new RemoteMediaPlayerWrapper(mApiClient, mNotificationBuilder, mCastDevice);
-
-        mMediaPlayerWrapper.load(((RemotingMediaSource) source).getMediaUrl());
-    }
-
-    @Override
-    public boolean isApiClientInvalid() {
-        return mApiClient == null || !mApiClient.isConnected();
-    }
-
-    @Override
-    public String getSourceId() {
-        return mSource.getSourceId();
-    }
-
-    @Override
-    public String getSinkId() {
-        return mCastDevice.getDeviceId();
-    }
-
-    @Override
-    public String getSessionId() {
-        return mSessionId;
-    }
-
-    @Override
-    public Set<String> getNamespaces() {
-        return new HashSet<String>();
-    }
-
-    @Override
-    public CastMessageHandler getMessageHandler() {
-        return null;
-    }
-
-    @Override
-    public CastSessionInfo getSessionInfo() {
-        // Only used by the CastMessageHandler, which is unused in the RemotingCastSession case.
-        return null;
-    }
-
-    @Override
-    public boolean sendStringCastMessage(
-            String message, String namespace, String clientId, int sequenceNumber) {
-        // String messages are not used in remoting scenarios.
-        return false;
-    }
-
-    @Override
-    public HandleVolumeMessageResult handleVolumeMessage(
-            JSONObject volume, String clientId, int sequenceNumber) throws JSONException {
-        // RemoteMediaPlayer's setStreamVolume() should be used instead of volume messages.
-        return null;
-    }
-
-    @Override
-    public void stopApplication() {
-        if (mStoppingApplication) return;
-
-        if (isApiClientInvalid()) return;
-
-        mStoppingApplication = true;
-        Cast.CastApi.stopApplication(mApiClient, mSessionId)
-                .setResultCallback(new ResultCallback<Status>() {
-                    @Override
-                    public void onResult(Status status) {
-                        // TODO(https://crbug.com/535577): handle a failure to stop the application.
-
-                        mSessionId = null;
-                        mApiClient = null;
-                        mMediaPlayerWrapper.clearApiClient();
-
-                        ChromeCastSessionManager.get().onSessionEnded();
-                        mStoppingApplication = false;
-
-                        MediaNotificationManager.clear(R.id.presentation_notification);
-                    }
-                });
-    }
-
-    @Override
-    public void onClientConnected(String clientId) {}
-
-    @Override
-    public void onMediaMessage(String message) {
-        mMediaPlayerWrapper.onMediaMessage(message);
-    }
-
-    @Override
-    public void onVolumeChanged() {}
-
-    @Override
-    public void updateSessionStatus() {}
-
-    /////////////////////////////////////////////////////////////////////////////////////////////
-    // MediaNotificationListener implementation.
-
-    @Override
-    public void onPlay(int actionSource) {
-        mMediaPlayerWrapper.play();
-    }
-
-    @Override
-    public void onPause(int actionSource) {
-        mMediaPlayerWrapper.pause();
-    }
-
-    @Override
-    public void onStop(int actionSource) {
-        stopApplication();
-        ChromeCastSessionManager.get().onSessionStopAction();
-    }
-
-    @Override
-    public void onMediaSessionAction(int action) {}
-
-    @Override
-    public MediaController getMediaController() {
-        return mMediaPlayerWrapper;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingMediaRouteProvider.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingMediaRouteProvider.java
deleted file mode 100644
index d227fcb..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingMediaRouteProvider.java
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-package org.chromium.chrome.browser.media.router.cast.remoting;
-
-import android.support.v7.media.MediaRouter;
-
-import org.chromium.base.Log;
-import org.chromium.base.VisibleForTesting;
-import org.chromium.chrome.browser.media.router.ChromeMediaRouter;
-import org.chromium.chrome.browser.media.router.MediaController;
-import org.chromium.chrome.browser.media.router.MediaRoute;
-import org.chromium.chrome.browser.media.router.MediaRouteManager;
-import org.chromium.chrome.browser.media.router.MediaRouteProvider;
-import org.chromium.chrome.browser.media.router.cast.BaseMediaRouteProvider;
-import org.chromium.chrome.browser.media.router.cast.ChromeCastSessionManager;
-import org.chromium.chrome.browser.media.router.cast.CreateRouteRequest;
-import org.chromium.chrome.browser.media.router.cast.MediaSink;
-import org.chromium.chrome.browser.media.router.cast.MediaSource;
-
-import javax.annotation.Nullable;
-
-/**
- * A {@link MediaRouteProvider} implementation for media remote playback.
- */
-public class RemotingMediaRouteProvider extends BaseMediaRouteProvider {
-    private static final String TAG = "MediaRemoting";
-
-    /**
-     * @return Initialized {@link RemotingMediaRouteProvider} object.
-     */
-    public static RemotingMediaRouteProvider create(MediaRouteManager manager) {
-        return new RemotingMediaRouteProvider(ChromeMediaRouter.getAndroidMediaRouter(), manager);
-    }
-
-    @Override
-    protected MediaSource getSourceFromId(String sourceId) {
-        return RemotingMediaSource.from(sourceId);
-    }
-
-    @Override
-    protected ChromeCastSessionManager.CastSessionLaunchRequest createSessionLaunchRequest(
-            MediaSource source, MediaSink sink, String presentationId, String origin, int tabId,
-            boolean isIncognito, int nativeRequestId) {
-        return new CreateRouteRequest(source, sink, presentationId, origin, tabId, isIncognito,
-                nativeRequestId, this, CreateRouteRequest.RequestedCastSessionType.REMOTE, null);
-    }
-
-    @Override
-    public void joinRoute(
-            String sourceId, String presentationId, String origin, int tabId, int nativeRequestId) {
-        mManager.onRouteRequestError(
-                "Remote playback doesn't support joining routes", nativeRequestId);
-    }
-
-    @Override
-    public void closeRoute(String routeId) {
-        MediaRoute route = mRoutes.get(routeId);
-        if (route == null) return;
-
-        if (mSession == null) {
-            mRoutes.remove(routeId);
-            mManager.onRouteClosed(routeId);
-            return;
-        }
-
-        ChromeCastSessionManager.get().stopApplication();
-    }
-
-    @Override
-    public void detachRoute(String routeId) {
-        mRoutes.remove(routeId);
-    }
-
-    @Override
-    public void sendStringMessage(String routeId, String message, int nativeCallbackId) {
-        Log.e(TAG, "Remote playback does not support sending messages");
-        mManager.onMessageSentResult(false, nativeCallbackId);
-    }
-
-    @VisibleForTesting
-    RemotingMediaRouteProvider(MediaRouter androidMediaRouter, MediaRouteManager manager) {
-        super(androidMediaRouter, manager);
-    }
-
-    @Override
-    public void onSessionEnded() {
-        if (mSession == null) return;
-
-        for (String routeId : mRoutes.keySet()) mManager.onRouteClosed(routeId);
-        mRoutes.clear();
-
-        mSession = null;
-
-        if (mAndroidMediaRouter != null) {
-            mAndroidMediaRouter.selectRoute(mAndroidMediaRouter.getDefaultRoute());
-        }
-    }
-
-    @Override
-    public void onSessionStarting(ChromeCastSessionManager.CastSessionLaunchRequest launchRequest) {
-        CreateRouteRequest request = (CreateRouteRequest) launchRequest;
-        MediaSink sink = request.getSink();
-        MediaSource source = request.getSource();
-
-        MediaRoute route =
-                new MediaRoute(sink.getId(), source.getSourceId(), request.getPresentationId());
-        mRoutes.put(route.id, route);
-        mManager.onRouteCreated(route.id, route.sinkId, request.getNativeRequestId(), this, true);
-    }
-
-    @Override
-    @Nullable
-    public MediaController getMediaController(String routeId) {
-        // We cannot return a MediaController if we don't have a session.
-        if (mSession == null) return null;
-
-        // Don't return controllers for stale routes.
-        if (mRoutes.get(routeId) == null) return null;
-
-        // RemotePlayback does not support joining routes, which means we only
-        // have a single route active at a time. If we have a a valid CastSession
-        // and the route ID is current, this means that the given |mSession|
-        // corresponds to the route ID, and it is ok to return the MediaController.
-        return mSession.getMediaController();
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingMediaSource.java b/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingMediaSource.java
deleted file mode 100644
index ed428e4..0000000
--- a/app/src/main/java/org/chromium/chrome/browser/media/router/cast/remoting/RemotingMediaSource.java
+++ /dev/null
@@ -1,110 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-package org.chromium.chrome.browser.media.router.cast.remoting;
-
-import android.support.v7.media.MediaRouteSelector;
-import android.util.Base64;
-
-import com.google.android.gms.cast.CastMediaControlIntent;
-
-import org.chromium.base.Log;
-import org.chromium.chrome.browser.media.router.cast.MediaSource;
-
-import java.io.UnsupportedEncodingException;
-
-import javax.annotation.Nullable;
-
-/**
- * Abstracts parsing the Cast application id and other parameters from the source id.
- */
-public class RemotingMediaSource implements MediaSource {
-    private static final String TAG = "MediaRemoting";
-
-    // Need to be in sync with third_party/WebKit/Source/modules/remoteplayback/RemotePlayback.cpp.
-    // TODO(avayvod): Find a way to share the constants somehow.
-    private static final String SOURCE_PREFIX = "remote-playback://";
-
-    /**
-     * The original source URL that the {@link MediaSource} object was created from.
-     */
-    private final String mSourceId;
-
-    /**
-     * The Cast application id.
-     */
-    private final String mApplicationId;
-
-    /**
-     * The URL to fling to the Cast device.
-     */
-    private final String mMediaUrl;
-
-    /**
-     * Initializes the media source from the source id.
-     * @param sourceId a URL containing encoded info about the media element's source.
-     * @return an initialized media source if the id is valid, null otherwise.
-     */
-    @Nullable
-    public static RemotingMediaSource from(String sourceId) {
-        assert sourceId != null;
-
-        if (!sourceId.startsWith(SOURCE_PREFIX)) return null;
-
-        String encodedContentUrl = sourceId.substring(SOURCE_PREFIX.length());
-
-        String mediaUrl;
-        try {
-            mediaUrl = new String(Base64.decode(encodedContentUrl, Base64.URL_SAFE), "UTF-8");
-        } catch (IllegalArgumentException | UnsupportedEncodingException e) {
-            Log.e(TAG, "Couldn't parse the source id.", e);
-            return null;
-        }
-
-        // TODO(avayvod): check the content URL and override the app id if needed.
-        String applicationId = CastMediaControlIntent.DEFAULT_MEDIA_RECEIVER_APPLICATION_ID;
-        return new RemotingMediaSource(sourceId, applicationId, mediaUrl);
-    }
-
-    /**
-     * Returns a new {@link MediaRouteSelector} to use for Cast device filtering for this
-     * particular media source or null if the application id is invalid.
-     *
-     * @return an initialized route selector or null.
-     */
-    @Override
-    public MediaRouteSelector buildRouteSelector() {
-        return new MediaRouteSelector.Builder()
-                .addControlCategory(CastMediaControlIntent.categoryForCast(mApplicationId))
-                .build();
-    }
-
-    /**
-     * @return the Cast application id corresponding to the source. Can be overridden downstream.
-     */
-    @Override
-    public String getApplicationId() {
-        return mApplicationId;
-    }
-
-    /**
-     * @return the id identifying the media source
-     */
-    @Override
-    public String getSourceId() {
-        return mSourceId;
-    }
-
-    /**
-     * @return the media URL to fling to the Cast device.
-     */
-    public String getMediaUrl() {
-        return mMediaUrl;
-    }
-
-    private RemotingMediaSource(String sourceId, String applicationId, String mediaUrl) {
-        mSourceId = sourceId;
-        mApplicationId = applicationId;
-        mMediaUrl = mediaUrl;
-    }
-}
diff --git a/app/src/main/java/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java b/app/src/main/java/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
index d57de22..91afccb 100644
--- a/app/src/main/java/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
+++ b/app/src/main/java/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
@@ -7,10 +7,6 @@ package org.chromium.chrome.browser.ntp.snippets;
 import android.content.Context;
 import android.net.ConnectivityManager;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.PeriodicTask;
-import com.google.android.gms.gcm.Task;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.VisibleForTesting;
@@ -40,8 +36,6 @@ public class SnippetsLauncher {
     // If it is non-null then the browser is running.
     private static SnippetsLauncher sInstance;
 
-    private GcmNetworkManager mScheduler;
-
     private boolean mGCMEnabled = true;
 
     /**
@@ -78,7 +72,6 @@ public class SnippetsLauncher {
 
     protected SnippetsLauncher() {
         checkGCM();
-        mScheduler = GcmNetworkManager.getInstance(ContextUtils.getApplicationContext());
     }
 
     private void checkGCM() {
@@ -89,32 +82,7 @@ public class SnippetsLauncher {
         }
     }
 
-    private static PeriodicTask buildFetchTask(
-            String tag, long periodSeconds, int requiredNetwork) {
-        // Add a bit of "flex" around the target period. This achieves the following:
-        // - It makes sure the task doesn't run (significantly) before its initial period has
-        //   elapsed. In practice, the scheduler seems to behave like that anyway, but it doesn't
-        //   guarantee that, so we shouldn't rely on it.
-        // - It gives the scheduler a bit of room to optimize for battery life.
-        long effectivePeriodSeconds = (long) (periodSeconds * (1.0 + FLEX_FACTOR));
-        long flexSeconds = (long) (periodSeconds * (2.0 * FLEX_FACTOR));
-        return new PeriodicTask.Builder()
-                .setService(ChromeBackgroundService.class)
-                .setTag(tag)
-                .setPeriod(effectivePeriodSeconds)
-                .setFlex(flexSeconds)
-                .setRequiredNetwork(requiredNetwork)
-                .setPersisted(true)
-                .setUpdateCurrent(true)
-                .build();
-    }
-
     private void scheduleOrCancelFetchTask(String taskTag, long period, int requiredNetwork) {
-        if (period > 0) {
-            mScheduler.schedule(buildFetchTask(taskTag, period, requiredNetwork));
-        } else {
-            mScheduler.cancelTask(taskTag, ChromeBackgroundService.class);
-        }
     }
 
     @CalledByNative
@@ -127,23 +95,7 @@ public class SnippetsLauncher {
                 .edit()
                 .putBoolean(PREF_IS_SCHEDULED, isScheduled)
                 .apply();
-
-        // Google Play Services may not be up to date, if the application was not installed through
-        // the Play Store. In this case, scheduling the task will fail silently.
-        try {
-            scheduleOrCancelFetchTask(
-                    TASK_TAG_WIFI, periodWifiSeconds, Task.NETWORK_STATE_UNMETERED);
-            scheduleOrCancelFetchTask(
-                    TASK_TAG_FALLBACK, periodFallbackSeconds, Task.NETWORK_STATE_CONNECTED);
-        } catch (IllegalArgumentException e) {
-            // Disable GCM for the remainder of this session.
-            mGCMEnabled = false;
-
-            ContextUtils.getAppSharedPreferences().edit().remove(PREF_IS_SCHEDULED).apply();
-            // Return false so that the failure will be logged.
-            return false;
-        }
-        return true;
+        return false;
     }
 
     @CalledByNative
diff --git a/app/src/main/java/org/chromium/chrome/browser/omaha/UpdateMenuItemHelper.java b/app/src/main/java/org/chromium/chrome/browser/omaha/UpdateMenuItemHelper.java
index 2a6b690..b959346 100644
--- a/app/src/main/java/org/chromium/chrome/browser/omaha/UpdateMenuItemHelper.java
+++ b/app/src/main/java/org/chromium/chrome/browser/omaha/UpdateMenuItemHelper.java
@@ -22,8 +22,6 @@ import android.text.TextUtils;
 import android.view.View;
 import android.view.animation.LinearInterpolator;
 
-import com.google.android.gms.common.GooglePlayServicesUtil;
-
 import org.chromium.base.CommandLine;
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
@@ -161,13 +159,7 @@ public class UpdateMenuItemHelper {
     }
 
     private static boolean isGooglePlayStoreAvailable(Context context) {
-        try {
-            context.getPackageManager().getPackageInfo(
-                    GooglePlayServicesUtil.GOOGLE_PLAY_STORE_PACKAGE, 0);
-        } catch (PackageManager.NameNotFoundException e) {
-            return false;
-        }
-        return true;
+        return false;
     }
 
     /**
diff --git a/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyBackgroundSubscription.java b/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyBackgroundSubscription.java
index a145205..b78e0c4 100644
--- a/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyBackgroundSubscription.java
+++ b/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyBackgroundSubscription.java
@@ -7,10 +7,6 @@ package org.chromium.chrome.browser.physicalweb;
 import android.app.PendingIntent;
 import android.content.Intent;
 
-import com.google.android.gms.common.api.PendingResult;
-import com.google.android.gms.common.api.Status;
-import com.google.android.gms.nearby.Nearby;
-
 import org.chromium.base.ContextUtils;
 
 
@@ -43,27 +39,12 @@ class NearbyBackgroundSubscription extends NearbySubscription {
 
     @Override
     protected void onConnected() {
-        PendingResult<Status> pendingResult = null;
         String actionStr = null;
         if (mAction == SUBSCRIBE) {
-            pendingResult = Nearby.Messages.subscribe(
-                    getGoogleApiClient(), createNearbySubscribeIntent(), createSubscribeOptions());
             actionStr = "background subscribe";
         } else {
-            pendingResult = Nearby.Messages.unsubscribe(
-                    getGoogleApiClient(), createNearbySubscribeIntent());
             actionStr = "background unsubscribe";
         }
-        pendingResult.setResultCallback(new SimpleResultCallback(actionStr) {
-            @Override
-            public void onResult(final Status status) {
-                super.onResult(status);
-                disconnect();
-                if (mCallback != null) {
-                    mCallback.run();
-                }
-            }
-        });
     }
 
     void run() {
diff --git a/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyForegroundSubscription.java b/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyForegroundSubscription.java
index 99efb62..80b9962 100644
--- a/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyForegroundSubscription.java
+++ b/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyForegroundSubscription.java
@@ -6,11 +6,6 @@ package org.chromium.chrome.browser.physicalweb;
 
 import android.app.Activity;
 
-import com.google.android.gms.nearby.Nearby;
-import com.google.android.gms.nearby.messages.Distance;
-import com.google.android.gms.nearby.messages.Message;
-import com.google.android.gms.nearby.messages.MessageListener;
-
 import org.chromium.base.ThreadUtils;
 
 /**
@@ -25,24 +20,6 @@ import org.chromium.base.ThreadUtils;
  */
 class NearbyForegroundSubscription extends NearbySubscription {
     private static final String TAG = "PhysicalWeb";
-    private static final MessageListener MESSAGE_LISTENER = new MessageListener() {
-        @Override
-        public void onFound(Message message) {}
-
-        @Override
-        public void onDistanceChanged(Message message, final Distance distance) {
-            final String url = PhysicalWebBleClient.getInstance().getUrlFromMessage(message);
-            if (url == null) return;
-
-            ThreadUtils.postOnUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    UrlManager.getInstance().addUrl(
-                            new UrlInfo(url).setDistance(distance.getMeters()));
-                }
-            });
-        }
-    };
     private boolean mShouldSubscribe;
 
     NearbyForegroundSubscription(Activity activity) {
@@ -58,20 +35,10 @@ class NearbyForegroundSubscription extends NearbySubscription {
     }
 
     void subscribe() {
-        if (!getGoogleApiClient().isConnected()) {
-            mShouldSubscribe = true;
             return;
-        }
-        Nearby.Messages.subscribe(getGoogleApiClient(), MESSAGE_LISTENER, createSubscribeOptions())
-                .setResultCallback(new SimpleResultCallback("foreground subscribe"));
     }
 
     void unsubscribe() {
-        if (!getGoogleApiClient().isConnected()) {
-            mShouldSubscribe = false;
             return;
-        }
-        Nearby.Messages.unsubscribe(getGoogleApiClient(), MESSAGE_LISTENER)
-                .setResultCallback(new SimpleResultCallback("foreground unsubscribe"));
     }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyMessageIntentService.java b/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyMessageIntentService.java
index 23651ea..fb56874 100644
--- a/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyMessageIntentService.java
+++ b/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbyMessageIntentService.java
@@ -7,15 +7,10 @@ package org.chromium.chrome.browser.physicalweb;
 import android.app.IntentService;
 import android.content.Intent;
 
-import com.google.android.gms.nearby.Nearby;
-import com.google.android.gms.nearby.messages.MessageListener;
-
 /**
  * Service that handles intents from Nearby.
  */
 public class NearbyMessageIntentService extends IntentService {
-    private static final MessageListener MESSAGE_LISTENER =
-            PhysicalWebBleClient.getInstance().createBackgroundMessageListener();
 
 
     public NearbyMessageIntentService() {
@@ -25,6 +20,5 @@ public class NearbyMessageIntentService extends IntentService {
 
     @Override
     protected void onHandleIntent(Intent intent) {
-        Nearby.Messages.handleIntent(intent, MESSAGE_LISTENER);
     }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbySubscription.java b/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbySubscription.java
index f4538f7..cd26e99 100644
--- a/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbySubscription.java
+++ b/app/src/main/java/org/chromium/chrome/browser/physicalweb/NearbySubscription.java
@@ -7,19 +7,6 @@ package org.chromium.chrome.browser.physicalweb;
 import android.content.Context;
 import android.os.Bundle;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.common.api.GoogleApiClient.ConnectionCallbacks;
-import com.google.android.gms.common.api.GoogleApiClient.OnConnectionFailedListener;
-import com.google.android.gms.common.api.ResultCallback;
-import com.google.android.gms.common.api.Status;
-import com.google.android.gms.nearby.Nearby;
-import com.google.android.gms.nearby.messages.MessageFilter;
-import com.google.android.gms.nearby.messages.MessagesOptions;
-import com.google.android.gms.nearby.messages.NearbyPermissions;
-import com.google.android.gms.nearby.messages.Strategy;
-import com.google.android.gms.nearby.messages.SubscribeOptions;
-
 import org.chromium.base.Log;
 
 
@@ -27,76 +14,38 @@ import org.chromium.base.Log;
  * This class represents a connection to Google Play Services that performs subscriptions
  * and unsubscriptions to Nearby.
  */
-abstract class NearbySubscription implements ConnectionCallbacks, OnConnectionFailedListener {
+abstract class NearbySubscription {
     public static final int UNSUBSCRIBE = 0;
     public static final int SUBSCRIBE = 1;
     private static final String TAG = "PhysicalWeb";
-    private final GoogleApiClient mGoogleApiClient;
 
-    protected static class SimpleResultCallback implements ResultCallback<Status> {
+    protected static class SimpleResultCallback {
         private String mAction;
 
         SimpleResultCallback(String action) {
             mAction = action;
         }
-
-        @Override
-        public void onResult(final Status status) {
-            if (status.isSuccess()) {
-                Log.d(TAG, "Nearby " + mAction + " succeeded");
-            } else {
-                Log.d(TAG, "Nearby " + mAction + " failed: " + status.getStatusMessage());
-            }
-        }
     }
 
     NearbySubscription(Context context) {
-        mGoogleApiClient = new GoogleApiClient.Builder(context)
-                .addApi(Nearby.MESSAGES_API, new MessagesOptions.Builder()
-                        .setPermissions(NearbyPermissions.BLE)
-                        .build())
-                .addConnectionCallbacks(this)
-                .addOnConnectionFailedListener(this)
-                .build();
     }
 
     protected void connect() {
-        mGoogleApiClient.connect();
+
     }
 
     protected void disconnect() {
-        mGoogleApiClient.disconnect();
+
     }
 
     protected void onConnected() {
     }
 
-    @Override
     public void onConnected(Bundle connectionHint) {
         onConnected();
     }
 
-    @Override
     public void onConnectionSuspended(int cause) {
         Log.i(TAG, "Nearby connection suspended: " + cause);
     }
-
-    @Override
-    public void onConnectionFailed(ConnectionResult result) {
-        Log.i(TAG, "Nearby connection failed: " + result);
-    }
-
-    protected static SubscribeOptions createSubscribeOptions() {
-        MessageFilter messageFilter = PhysicalWebBleClient.getInstance().modifyMessageFilterBuilder(
-                new MessageFilter.Builder())
-                .build();
-        return new SubscribeOptions.Builder()
-                .setStrategy(Strategy.BLE_ONLY)
-                .setFilter(messageFilter)
-                .build();
-    }
-
-    protected GoogleApiClient getGoogleApiClient() {
-        return mGoogleApiClient;
-    }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/physicalweb/PhysicalWebBleClient.java b/app/src/main/java/org/chromium/chrome/browser/physicalweb/PhysicalWebBleClient.java
index 559bfdd..2844f5b 100644
--- a/app/src/main/java/org/chromium/chrome/browser/physicalweb/PhysicalWebBleClient.java
+++ b/app/src/main/java/org/chromium/chrome/browser/physicalweb/PhysicalWebBleClient.java
@@ -7,10 +7,6 @@ package org.chromium.chrome.browser.physicalweb;
 import android.os.Handler;
 import android.os.Looper;
 
-import com.google.android.gms.nearby.messages.Message;
-import com.google.android.gms.nearby.messages.MessageFilter;
-import com.google.android.gms.nearby.messages.MessageListener;
-
 import org.chromium.chrome.browser.AppHooks;
 
 /**
@@ -23,32 +19,7 @@ public class PhysicalWebBleClient {
     private static PhysicalWebBleClient sInstance;
     private static final String TAG = "PhysicalWeb";
 
-    protected static class BackgroundMessageListener extends MessageListener {
-        @Override
-        public void onFound(Message message) {
-            final String url = PhysicalWebBleClient.getInstance().getUrlFromMessage(message);
-            if (url != null) {
-                new Handler(Looper.getMainLooper()).post(new Runnable() {
-                    @Override
-                    public void run() {
-                        UrlManager.getInstance().addUrl(new UrlInfo(url));
-                    }
-                });
-            }
-        }
-
-        @Override
-        public void onLost(Message message) {
-            final String url = PhysicalWebBleClient.getInstance().getUrlFromMessage(message);
-            if (url != null) {
-                new Handler(Looper.getMainLooper()).post(new Runnable() {
-                    @Override
-                    public void run() {
-                        UrlManager.getInstance().removeUrl(new UrlInfo(url));
-                    }
-                });
-            }
-        }
+    protected static class BackgroundMessageListener {
     };
 
     /**
@@ -61,30 +32,4 @@ public class PhysicalWebBleClient {
         }
         return sInstance;
     }
-
-    /**
-     * Create a MessageListener that listens during a background scan.
-     * @return the MessageListener.
-     */
-    MessageListener createBackgroundMessageListener() {
-        return new BackgroundMessageListener();
-    }
-
-    /**
-     * Get the URLs from a device within a message.
-     * @param message The Nearby message.
-     * @return The URL contained in the message.
-     */
-    String getUrlFromMessage(Message message) {
-        return null;
-    }
-
-    /**
-     * Modify a MessageFilter.Builder as necessary for doing Physical Web scanning.
-     * @param builder The builder to be modified.
-     * @return The Builder.
-     */
-    MessageFilter.Builder modifyMessageFilterBuilder(MessageFilter.Builder builder) {
-        return builder.includeAllMyTypes();
-    }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java b/app/src/main/java/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java
index eb9b65a..7584d7d 100644
--- a/app/src/main/java/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java
+++ b/app/src/main/java/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java
@@ -9,7 +9,6 @@ import android.os.Build;
 import android.os.Bundle;
 import android.text.TextUtils;
 
-import com.google.android.gms.gcm.GcmListenerService;
 import com.google.ipc.invalidation.ticl.android2.channel.AndroidGcmController;
 
 import org.chromium.base.Log;
@@ -26,27 +25,15 @@ import org.chromium.components.gcm_driver.GCMMessage;
 /**
  * Receives Downstream messages and status of upstream messages from GCM.
  */
-public class ChromeGcmListenerService extends GcmListenerService {
+public class ChromeGcmListenerService {
     private static final String TAG = "ChromeGcmListener";
 
-    @Override
     public void onCreate() {
         ProcessInitializationHandler.getInstance().initializePreNative();
-        super.onCreate();
     }
 
-    @Override
     public void onMessageReceived(final String from, final Bundle data) {
         boolean hasCollapseKey = !TextUtils.isEmpty(data.getString("collapse_key"));
-        GcmUma.recordDataMessageReceived(getApplicationContext(), hasCollapseKey);
-
-        String invalidationSenderId = AndroidGcmController.get(this).getSenderId();
-        if (from.equals(invalidationSenderId)) {
-            AndroidGcmController.get(this).onMessageReceived(data);
-            return;
-        }
-
-        final Context applicationContext = getApplicationContext();
 
         // Dispatch the message to the GCM Driver for native features.
         ThreadUtils.runOnUiThread(new Runnable() {
@@ -59,30 +46,22 @@ public class ChromeGcmListenerService extends GcmListenerService {
                     Log.e(TAG, "Received an invalid GCM Message", e);
                     return;
                 }
-
-                scheduleOrDispatchMessageToDriver(applicationContext, message);
             }
         });
     }
 
-    @Override
     public void onMessageSent(String msgId) {
         Log.d(TAG, "Message sent successfully. Message id: " + msgId);
-        GcmUma.recordGcmUpstreamHistogram(getApplicationContext(), GcmUma.UMA_UPSTREAM_SUCCESS);
     }
 
-    @Override
     public void onSendError(String msgId, String error) {
         Log.w(TAG, "Error in sending message. Message id: " + msgId + " Error: " + error);
-        GcmUma.recordGcmUpstreamHistogram(getApplicationContext(), GcmUma.UMA_UPSTREAM_SEND_FAILED);
     }
 
-    @Override
     public void onDeletedMessages() {
         // TODO(johnme): Ask GCM to include the subtype in this event.
         Log.w(TAG, "Push messages were deleted, but we can't tell the Service Worker as we don't"
                 + "know what subtype (app ID) it occurred for.");
-        GcmUma.recordDeletedMessages(getApplicationContext());
     }
 
     /**
diff --git a/app/src/main/java/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java b/app/src/main/java/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java
index 257b716..e84da3f 100644
--- a/app/src/main/java/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java
+++ b/app/src/main/java/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java
@@ -13,7 +13,6 @@ import android.os.Parcel;
 import android.support.annotation.MainThread;
 import android.util.Log;
 
-import com.google.android.gms.gcm.GoogleCloudMessaging;
 import com.google.ipc.invalidation.ticl.android2.channel.GcmUpstreamSenderService;
 
 import org.chromium.base.ThreadUtils;
@@ -99,12 +98,6 @@ public class InvalidationGcmUpstreamSender extends GcmUpstreamSenderService {
             return;
         }
         String msgId = UUID.randomUUID().toString();
-        try {
-            GoogleCloudMessaging.getInstance(getApplicationContext()).send(to, msgId, 1, data);
-        } catch (IOException | IllegalArgumentException exception) {
-            Log.w(TAG, "Send message failed");
-            GcmUma.recordGcmUpstreamHistogram(context, GcmUma.UMA_UPSTREAM_SEND_FAILED);
-        }
     }
 
     private boolean isMessageWithinLimit(Bundle data) {
diff --git a/app/src/main/java/org/chromium/chrome/browser/signin/SigninHelper.java b/app/src/main/java/org/chromium/chrome/browser/signin/SigninHelper.java
index 772174a..449da00 100644
--- a/app/src/main/java/org/chromium/chrome/browser/signin/SigninHelper.java
+++ b/app/src/main/java/org/chromium/chrome/browser/signin/SigninHelper.java
@@ -9,10 +9,6 @@ import android.annotation.SuppressLint;
 import android.content.Context;
 import android.os.AsyncTask;
 
-import com.google.android.gms.auth.AccountChangeEvent;
-import com.google.android.gms.auth.GoogleAuthException;
-import com.google.android.gms.auth.GoogleAuthUtil;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.VisibleForTesting;
@@ -71,23 +67,6 @@ public class SigninHelper {
         @Override
         public List<String> getAccountChangeEvents(
                 Context context, int index, String accountName) {
-            try {
-                List<AccountChangeEvent> list = GoogleAuthUtil.getAccountChangeEvents(
-                        context, index, accountName);
-                List<String> result = new ArrayList<>(list.size());
-                for (AccountChangeEvent e : list) {
-                    if (e.getChangeType() == GoogleAuthUtil.CHANGE_TYPE_ACCOUNT_RENAMED_TO) {
-                        result.add(e.getChangeData());
-                    } else {
-                        result.add(null);
-                    }
-                }
-                return result;
-            } catch (IOException e) {
-                Log.w(TAG, "Failed to get change events", e);
-            } catch (GoogleAuthException e) {
-                Log.w(TAG, "Failed to get change events", e);
-            }
             return new ArrayList<>(0);
         }
     }
diff --git a/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrClassesWrapperImpl.java b/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrClassesWrapperImpl.java
index 02e2ac6..4b76b32 100644
--- a/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrClassesWrapperImpl.java
+++ b/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrClassesWrapperImpl.java
@@ -8,8 +8,6 @@ import android.app.Activity;
 import android.content.Context;
 import android.os.StrictMode;
 
-import com.google.vr.ndk.base.AndroidCompat;
-
 import org.chromium.base.Log;
 import org.chromium.base.annotations.UsedByReflection;
 import org.chromium.chrome.browser.ChromeActivity;
@@ -57,6 +55,5 @@ public class VrClassesWrapperImpl implements VrClassesWrapper {
 
     @Override
     public void setVrModeEnabled(Activity activity, boolean enabled) {
-        AndroidCompat.setVrModeEnabled(activity, enabled);
     }
 }
diff --git a/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrCoreVersionCheckerImpl.java b/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrCoreVersionCheckerImpl.java
index 973ed85..8b60aee 100644
--- a/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrCoreVersionCheckerImpl.java
+++ b/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrCoreVersionCheckerImpl.java
@@ -6,10 +6,6 @@ package org.chromium.chrome.browser.vr_shell;
 
 import android.os.Build;
 
-import com.google.vr.ndk.base.Version;
-import com.google.vr.vrcore.base.api.VrCoreNotAvailableException;
-import com.google.vr.vrcore.base.api.VrCoreUtils;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.PackageUtils;
@@ -39,34 +35,7 @@ public class VrCoreVersionCheckerImpl implements VrCoreVersionChecker {
         if (Build.VERSION.SDK_INT < minSdkVersion) {
             return new VrCoreInfo(null, VrCoreCompatibility.VR_NOT_SUPPORTED);
         }
-        try {
-            String vrCoreSdkLibraryVersionString = VrCoreUtils.getVrCoreSdkLibraryVersion(
-                    ContextUtils.getApplicationContext());
-            Version vrCoreSdkLibraryVersion = Version.parse(vrCoreSdkLibraryVersionString);
-            Version targetSdkLibraryVersion =
-                    Version.parse(com.google.vr.ndk.base.BuildConstants.VERSION);
-            GvrVersion gvrVersion = new GvrVersion(vrCoreSdkLibraryVersion.majorVersion,
-                    vrCoreSdkLibraryVersion.minorVersion, vrCoreSdkLibraryVersion.patchVersion);
-            if (!vrCoreSdkLibraryVersion.isAtLeast(targetSdkLibraryVersion)) {
-                return new VrCoreInfo(gvrVersion, VrCoreCompatibility.VR_OUT_OF_DATE);
-            }
-            return new VrCoreInfo(gvrVersion, VrCoreCompatibility.VR_READY);
-        } catch (VrCoreNotAvailableException e) {
-            Log.i(TAG, "Unable to find VrCore.");
-            // Old versions of VrCore are not integrated with the sdk library version check and will
-            // trigger this exception even though VrCore is installed.
-            // Double check package manager to make sure we are not telling user to install
-            // when it should just be an update.
-            if (PackageUtils.getPackageVersion(
-                        ContextUtils.getApplicationContext(), VR_CORE_PACKAGE_ID)
-                    != -1) {
-                return new VrCoreInfo(null, VrCoreCompatibility.VR_OUT_OF_DATE);
-            }
-            return new VrCoreInfo(null, VrCoreCompatibility.VR_NOT_AVAILABLE);
-        } catch (SecurityException e) {
-            Log.e(TAG, "Cannot query VrCore version: " + e.toString());
-            return new VrCoreInfo(null, VrCoreCompatibility.VR_NOT_AVAILABLE);
-        }
+        return new VrCoreInfo(null, VrCoreCompatibility.VR_NOT_AVAILABLE);
     }
 
     @Override
diff --git a/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrDaydreamApiImpl.java b/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrDaydreamApiImpl.java
index dbfdc05..4bada3b 100644
--- a/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrDaydreamApiImpl.java
+++ b/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrDaydreamApiImpl.java
@@ -11,10 +11,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.os.StrictMode;
 
-import com.google.vr.ndk.base.DaydreamApi;
-import com.google.vr.ndk.base.GvrApi;
-import com.google.vr.ndk.base.GvrUiLayout;
-
 import org.chromium.base.Log;
 import org.chromium.ui.base.WindowAndroid;
 
@@ -27,59 +23,40 @@ public class VrDaydreamApiImpl implements VrDaydreamApi {
     public static final String VR_BOOT_SYSTEM_PROPERTY = "ro.boot.vr";
 
     private final Context mContext;
-
-    private DaydreamApi mDaydreamApi;
     private Boolean mBootsToVr = null;
 
     public VrDaydreamApiImpl(Context context) {
         mContext = context;
     }
 
-    private DaydreamApi getDaydreamApi() {
-        if (mDaydreamApi == null) mDaydreamApi = DaydreamApi.create(mContext);
-        return mDaydreamApi;
-    }
-
     @Override
     public boolean isDaydreamReadyDevice() {
-        return DaydreamApi.isDaydreamReadyPlatform(mContext);
+        return false;
     }
 
     @Override
     public boolean registerDaydreamIntent(final PendingIntent pendingIntent) {
-        DaydreamApi daydreamApi = getDaydreamApi();
-        if (daydreamApi == null) return false;
-        daydreamApi.registerDaydreamIntent(pendingIntent);
-        return true;
+        return false;
     }
 
     @Override
     public boolean unregisterDaydreamIntent() {
-        DaydreamApi daydreamApi = getDaydreamApi();
-        if (daydreamApi == null) return false;
-        daydreamApi.unregisterDaydreamIntent();
-        return true;
+        return false;
     }
 
     @Override
     public Intent createVrIntent(final ComponentName componentName) {
-        return DaydreamApi.createVrIntent(componentName);
+        return null;
     }
 
     @Override
     public boolean launchInVr(final PendingIntent pendingIntent) {
-        DaydreamApi daydreamApi = getDaydreamApi();
-        if (daydreamApi == null) return false;
-        daydreamApi.launchInVr(pendingIntent);
-        return true;
+        return false;
     }
 
     @Override
     public boolean launchInVr(final Intent intent) {
-        DaydreamApi daydreamApi = getDaydreamApi();
-        if (daydreamApi == null) return false;
-        daydreamApi.launchInVr(intent);
-        return true;
+        return false;
     }
 
     @Override
@@ -88,34 +65,17 @@ public class VrDaydreamApiImpl implements VrDaydreamApi {
         if (activity == null) {
             throw new IllegalStateException("Activity is null");
         }
-        DaydreamApi daydreamApi = getDaydreamApi();
-        if (daydreamApi == null) return false;
-        daydreamApi.exitFromVr(activity, requestCode, intent);
-        return true;
+        return false;
     }
 
     @Override
     public Boolean isDaydreamCurrentViewer() {
-        DaydreamApi daydreamApi = getDaydreamApi();
-        if (daydreamApi == null) return false;
-        // If this is the first time any app reads the daydream config file, daydream may create its
-        // config directory... crbug.com/686104
-        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
-        int type = GvrApi.ViewerType.CARDBOARD;
-        try {
-            type = daydreamApi.getCurrentViewerType();
-        } finally {
-            StrictMode.setThreadPolicy(oldPolicy);
-        }
-        return type == GvrApi.ViewerType.DAYDREAM;
+        return false;
     }
 
     @Override
     public boolean launchVrHomescreen() {
-        DaydreamApi daydreamApi = getDaydreamApi();
-        if (daydreamApi == null) return false;
-        daydreamApi.launchVrHomescreen();
-        return true;
+        return false;
     }
 
     @Override
@@ -132,7 +92,7 @@ public class VrDaydreamApiImpl implements VrDaydreamApi {
 
     @Override
     public Intent setupVrIntent(Intent intent) {
-        return DaydreamApi.setupVrIntent(intent);
+        return null;
     }
 
     @Override
@@ -141,14 +101,11 @@ public class VrDaydreamApiImpl implements VrDaydreamApi {
         if (activity == null) {
             throw new IllegalStateException("Activity is null");
         }
-        GvrUiLayout.launchOrInstallGvrApp(activity);
     }
 
     @Override
     public void close() {
-        if (mDaydreamApi == null) return;
-        mDaydreamApi.close();
-        mDaydreamApi = null;
+        return;
     }
 
     private int getIntSystemProperty(String key, int defaultValue) {
diff --git a/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrShellImpl.java b/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrShellImpl.java
index d87bab2..7c0f8eb 100644
--- a/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrShellImpl.java
+++ b/app/src/main/java/org/chromium/chrome/browser/vr_shell/VrShellImpl.java
@@ -21,9 +21,6 @@ import android.view.ViewConfiguration;
 import android.view.ViewGroup;
 import android.widget.FrameLayout;
 
-import com.google.vr.ndk.base.AndroidCompat;
-import com.google.vr.ndk.base.GvrLayout;
-
 import org.chromium.base.ThreadUtils;
 import org.chromium.base.VisibleForTesting;
 import org.chromium.base.annotations.CalledByNative;
@@ -63,8 +60,7 @@ import org.chromium.ui.display.VirtualDisplayAndroid;
  * This view extends from GvrLayout which wraps a GLSurfaceView that renders VR shell.
  */
 @JNINamespace("vr")
-public class VrShellImpl
-        extends GvrLayout implements VrShell, SurfaceHolder.Callback,
+public class VrShellImpl implements VrShell, SurfaceHolder.Callback,
                                      VrInputMethodManagerWrapper.BrowserKeyboardInterface {
     private static final String TAG = "VrShellImpl";
     private static final float INCHES_TO_METERS = 0.0254f;
@@ -120,7 +116,6 @@ public class VrShellImpl
 
     public VrShellImpl(
             ChromeActivity activity, VrShellDelegate delegate, TabModelSelector tabModelSelector) {
-        super(activity);
         mActivity = activity;
         mDelegate = delegate;
         mTabModelSelector = tabModelSelector;
@@ -145,9 +140,6 @@ public class VrShellImpl
         // This overrides the default intent created by GVR to return to Chrome when the DON flow
         // is triggered by resuming the GvrLayout, which is the usual way Daydream apps enter VR.
         // See VrShellDelegate#getEnterVrPendingIntent for why we need to do this.
-        setReentryIntent(VrShellDelegate.getEnterVrPendingIntent(activity));
-
-        mReprojectedRendering = setAsyncReprojectionEnabled(true);
         if (mReprojectedRendering) {
             // No need render to a Surface if we're reprojected. We'll be rendering with surfaceless
             // EGL.
@@ -155,18 +147,12 @@ public class VrShellImpl
 
             // Only enable sustained performance mode when Async reprojection decouples the app
             // framerate from the display framerate.
-            AndroidCompat.setSustainedPerformanceMode(mActivity, true);
         } else {
             SurfaceView surfaceView = new SurfaceView(mActivity);
             surfaceView.getHolder().addCallback(this);
             mPresentationView = surfaceView;
         }
 
-        setPresentationView(mPresentationView);
-
-        getUiLayout().setCloseButtonListener(mDelegate.getVrCloseButtonListener());
-        getUiLayout().setSettingsButtonListener(mDelegate.getVrSettingsButtonListener());
-
         if (mVrBrowsingEnabled) injectVrHostedUiView();
 
         mTabRedirectHandler = new TabRedirectHandler(mActivity) {
@@ -284,9 +270,6 @@ public class VrShellImpl
 
         ViewGroup decor = (ViewGroup) mActivity.getWindow().getDecorView();
         mUiView = new FrameLayout(decor.getContext());
-        LayoutParams params = new FrameLayout.LayoutParams(
-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
-        decor.addView(mUiView, params);
         mVrUiViewContainer = new VrViewContainer(mActivity);
         mUiView.addView(mVrUiViewContainer);
     }
@@ -345,10 +328,6 @@ public class VrShellImpl
                 mActivity.getWindowAndroid().hasPermission(android.Manifest.permission.RECORD_AUDIO)
                 || mActivity.getWindowAndroid().canRequestPermission(
                            android.Manifest.permission.RECORD_AUDIO);
-        mNativeVrShell = nativeInit(mDelegate, forWebVr, webVrAutopresentationExpected, inCct,
-                !mVrBrowsingEnabled, hasOrCanRequestAudioPermission,
-                getGvrApi().getNativeGvrContext(), mReprojectedRendering, displayWidthMeters,
-                displayHeightMeters, dm.widthPixels, dm.heightPixels, pauseContent);
 
         swapToTab(currentTab);
         createTabList();
@@ -600,113 +579,13 @@ public class VrShellImpl
             mVrUiViewContainer.setSurface(surface);
     }
 
-    @Override
-    public boolean dispatchTouchEvent(MotionEvent event) {
-        boolean parentConsumed = super.dispatchTouchEvent(event);
-        if (mOnDispatchTouchEventForTesting != null) {
-            mOnDispatchTouchEventForTesting.onDispatchTouchEvent(parentConsumed);
-        }
-        return parentConsumed;
-    }
-
-    @Override
-    public boolean dispatchKeyEvent(KeyEvent event) {
-        if (mTab != null && mTab.getContentViewCore() != null
-                && mTab.getContentViewCore().dispatchKeyEvent(event)) {
-            return true;
-        }
-        return super.dispatchKeyEvent(event);
-    }
-
-    @Override
-    public boolean onGenericMotionEvent(MotionEvent event) {
-        if (mTab != null && mTab.getContentViewCore() != null
-                && mTab.getContentViewCore().onGenericMotionEvent(event)) {
-            return true;
-        }
-        return super.onGenericMotionEvent(event);
-    }
-
-    @Override
     public void onResume() {
-        if (mPaused != null && !mPaused) return;
-        mPaused = false;
-        super.onResume();
-        if (mNativeVrShell != 0) {
-            // Refreshing the viewer profile may accesses disk under some circumstances outside of
-            // our control.
-            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
-            try {
-                nativeOnResume(mNativeVrShell);
-            } finally {
-                StrictMode.setThreadPolicy(oldPolicy);
-            }
-        }
     }
 
-    @Override
     public void onPause() {
-        if (mPaused != null && mPaused) return;
-        mPaused = true;
-        super.onPause();
-        if (mNativeVrShell != 0) nativeOnPause(mNativeVrShell);
     }
 
-    @Override
     public void shutdown() {
-        if (mVrBrowsingEnabled) {
-            mNonVrViews.destroy();
-            if (mVrUiViewContainer != null) mVrUiViewContainer.destroy();
-            removeVrRootView();
-        }
-
-        mActivity.getFullscreenManager().setPersistentFullscreenMode(false);
-        reparentAllTabs(mActivity.getWindowAndroid());
-        if (mNativeVrShell != 0) {
-            nativeDestroy(mNativeVrShell);
-            mNativeVrShell = 0;
-        }
-        mTabModelSelector.removeObserver(mTabModelSelectorObserver);
-        mTabModelSelectorTabObserver.destroy();
-        if (mTab != null) {
-            mTab.removeObserver(mTabObserver);
-            restoreTabFromVR();
-            uninitializeImeForVr();
-            if (mTab.getContentViewCore() != null) {
-                View parent = mTab.getContentViewCore().getContainerView();
-                mTab.getWebContents().setSize(parent.getWidth(), parent.getHeight());
-            }
-            mTab.updateFullscreenEnabledState();
-        }
-
-        mContentVirtualDisplay.destroy();
-
-        mCompositorView.onExitVr(mActivity.getWindowAndroid());
-
-        if (mActivity.getToolbarManager() != null) {
-            mActivity.getToolbarManager().setProgressBarEnabled(true);
-        }
-
-        // Since VSync was paused, control heights may not have been propagated. If we request to
-        // show the controls before the old values have propagated we'll end up with the old values
-        // (ie. the controls hidden). The values will have propagated with the next frame received
-        // from the compositor, so we can tell the controls to show at that point.
-        if (mActivity.getCompositorViewHolder() != null
-                && mActivity.getCompositorViewHolder().getCompositorView() != null) {
-            mActivity.getCompositorViewHolder().getCompositorView().surfaceRedrawNeededAsync(() -> {
-                ChromeFullscreenManager manager = mActivity.getFullscreenManager();
-                manager.getBrowserVisibilityDelegate().showControlsTransient();
-            });
-        }
-
-        if (ChromeFeatureList.isEnabled(ChromeFeatureList.VR_BROWSING_NATIVE_ANDROID_UI)) {
-            mActivity.getModalDialogManager().cancelAllDialogs();
-            mActivity.setModalDialogManager(mNonVrModalDialogManager);
-        }
-
-        FrameLayout decor = (FrameLayout) mActivity.getWindow().getDecorView();
-        decor.removeView(mUiView);
-        super.shutdown();
     }
 
     @Override
@@ -816,7 +695,7 @@ public class VrShellImpl
 
     @Override
     public FrameLayout getContainer() {
-        return this;
+        return null;
     }
 
     @Override
diff --git a/app/src/main/java/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java b/app/src/main/java/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java
index b109980..845e1c2 100644
--- a/app/src/main/java/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java
+++ b/app/src/main/java/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java
@@ -6,10 +6,6 @@ package org.chromium.components.background_task_scheduler;
 
 import android.os.Build;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.GcmTaskService;
-import com.google.android.gms.gcm.TaskParams;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
@@ -19,7 +15,7 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /** Delegates calls out to various tasks that need to run in the background. */
-public class BackgroundTaskGcmTaskService extends GcmTaskService {
+public class BackgroundTaskGcmTaskService {
     private static final String TAG = "BkgrdTaskGcmTS";
 
     /** Class that waits for the processing to be done. */
@@ -81,53 +77,6 @@ public class BackgroundTaskGcmTaskService extends GcmTaskService {
         }
     }
 
-    @Override
-    public int onRunTask(TaskParams params) {
-        final BackgroundTask backgroundTask =
-                BackgroundTaskSchedulerGcmNetworkManager.getBackgroundTaskFromTaskParams(params);
-        if (backgroundTask == null) {
-            Log.w(TAG, "Failed to start task. Could not instantiate class.");
-            return GcmNetworkManager.RESULT_FAILURE;
-        }
-
-        final TaskParameters taskParams =
-                BackgroundTaskSchedulerGcmNetworkManager.getTaskParametersFromTaskParams(params);
-        final Waiter waiter = new Waiter(Waiter.MAX_TIMEOUT_SECONDS);
-
-        final AtomicBoolean taskNeedsBackgroundProcessing = new AtomicBoolean();
-        ThreadUtils.runOnUiThreadBlocking(new Runnable() {
-            @Override
-            public void run() {
-                BackgroundTaskSchedulerUma.getInstance().reportTaskStarted(taskParams.getTaskId());
-                taskNeedsBackgroundProcessing.set(
-                        backgroundTask.onStartTask(ContextUtils.getApplicationContext(), taskParams,
-                                new TaskFinishedCallbackGcmTaskService(waiter)));
-            }
-        });
-
-        if (!taskNeedsBackgroundProcessing.get()) return GcmNetworkManager.RESULT_SUCCESS;
-
-        waiter.startWaiting();
-
-        if (waiter.isRescheduleNeeded()) return GcmNetworkManager.RESULT_RESCHEDULE;
-        if (!waiter.hasTaskTimedOut()) return GcmNetworkManager.RESULT_SUCCESS;
-
-        final AtomicBoolean taskNeedsRescheduling = new AtomicBoolean();
-        ThreadUtils.runOnUiThreadBlocking(new Runnable() {
-            @Override
-            public void run() {
-                BackgroundTaskSchedulerUma.getInstance().reportTaskStopped(taskParams.getTaskId());
-                taskNeedsRescheduling.set(backgroundTask.onStopTask(
-                        ContextUtils.getApplicationContext(), taskParams));
-            }
-        });
-
-        if (taskNeedsRescheduling.get()) return GcmNetworkManager.RESULT_RESCHEDULE;
-
-        return GcmNetworkManager.RESULT_SUCCESS;
-    }
-
-    @Override
     public void onInitializeTasks() {
         // Ignore the event on OSs supporting JobScheduler.
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) return;
diff --git a/app/src/main/java/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java b/app/src/main/java/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
index 8976d13..f17971e 100644
--- a/app/src/main/java/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
+++ b/app/src/main/java/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
@@ -8,24 +8,12 @@ import android.content.Context;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.OneoffTask;
-import com.google.android.gms.gcm.PeriodicTask;
-import com.google.android.gms.gcm.Task;
-import com.google.android.gms.gcm.TaskParams;
-
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
 import org.chromium.base.VisibleForTesting;
 
 import java.util.concurrent.TimeUnit;
 
-/**
- * An implementation of {@link BackgroundTaskSchedulerDelegate} that uses the Play Services
- * {@link GcmNetworkManager} to schedule jobs.
- */
 class BackgroundTaskSchedulerGcmNetworkManager implements BackgroundTaskSchedulerDelegate {
     private static final String TAG = "BkgrdTaskSchedGcmNM";
 
@@ -34,158 +22,13 @@ class BackgroundTaskSchedulerGcmNetworkManager implements BackgroundTaskSchedule
     @VisibleForTesting
     static final String BACKGROUND_TASK_EXTRAS_KEY = "_background_task_extras";
 
-    static BackgroundTask getBackgroundTaskFromTaskParams(@NonNull TaskParams taskParams) {
-        String backgroundTaskClassName = getBackgroundTaskClassFromTaskParams(taskParams);
-        return BackgroundTaskReflection.getBackgroundTaskFromClassName(backgroundTaskClassName);
-    }
-
-    private static String getBackgroundTaskClassFromTaskParams(@NonNull TaskParams taskParams) {
-        Bundle extras = taskParams.getExtras();
-        if (extras == null) return null;
-        return extras.getString(BACKGROUND_TASK_CLASS_KEY);
-    }
-
-    /**
-     * Retrieves the {@link TaskParameters} from the {@link TaskParams}, which are passed as
-     * one of the keys. Only values valid for {@link android.os.BaseBundle} are supported, and other
-     * values are stripped at the time when the task is scheduled.
-     *
-     * @param taskParams the {@link TaskParams} to extract the {@link TaskParameters} from.
-     * @return the {@link TaskParameters} for the current job.
-     */
-    static TaskParameters getTaskParametersFromTaskParams(@NonNull TaskParams taskParams) {
-        int taskId;
-        try {
-            taskId = Integer.parseInt(taskParams.getTag());
-        } catch (NumberFormatException e) {
-            Log.e(TAG, "Cound not parse task ID from task tag: " + taskParams.getTag());
-            return null;
-        }
-
-        TaskParameters.Builder builder = TaskParameters.create(taskId);
-
-        Bundle extras = taskParams.getExtras();
-        Bundle taskExtras = extras.getBundle(BACKGROUND_TASK_EXTRAS_KEY);
-        builder.addExtras(taskExtras);
-
-        return builder.build();
-    }
-
-    @VisibleForTesting
-    static Task createTaskFromTaskInfo(@NonNull TaskInfo taskInfo) {
-        Bundle taskExtras = new Bundle();
-        taskExtras.putString(
-                BACKGROUND_TASK_CLASS_KEY, taskInfo.getBackgroundTaskClass().getName());
-        taskExtras.putBundle(BACKGROUND_TASK_EXTRAS_KEY, taskInfo.getExtras());
-
-        Task.Builder builder;
-        if (taskInfo.isPeriodic()) {
-            builder = getPeriodicTaskBuilder(taskInfo.getPeriodicInfo());
-        } else {
-            builder = getOneOffTaskBuilder(taskInfo.getOneOffInfo());
-        }
-
-        builder.setExtras(taskExtras)
-                .setPersisted(taskInfo.isPersisted())
-                .setRequiredNetwork(getGcmNetworkManagerNetworkTypeFromTypeFromTaskNetworkType(
-                        taskInfo.getRequiredNetworkType()))
-                .setRequiresCharging(taskInfo.requiresCharging())
-                .setService(BackgroundTaskGcmTaskService.class)
-                .setTag(taskIdToTaskTag(taskInfo.getTaskId()))
-                .setUpdateCurrent(taskInfo.shouldUpdateCurrent());
-
-        return builder.build();
-    }
-
-    private static Task.Builder getPeriodicTaskBuilder(TaskInfo.PeriodicInfo periodicInfo) {
-        PeriodicTask.Builder builder = new PeriodicTask.Builder();
-        builder.setPeriod(TimeUnit.MILLISECONDS.toSeconds(periodicInfo.getIntervalMs()));
-        if (periodicInfo.hasFlex()) {
-            builder.setFlex(TimeUnit.MILLISECONDS.toSeconds(periodicInfo.getFlexMs()));
-        }
-        return builder;
-    }
-
-    private static Task.Builder getOneOffTaskBuilder(TaskInfo.OneOffInfo oneOffInfo) {
-        OneoffTask.Builder builder = new OneoffTask.Builder();
-        long windowStartSeconds = oneOffInfo.hasWindowStartTimeConstraint()
-                ? TimeUnit.MILLISECONDS.toSeconds(oneOffInfo.getWindowStartTimeMs())
-                : 0;
-        builder.setExecutionWindow(windowStartSeconds,
-                TimeUnit.MILLISECONDS.toSeconds(oneOffInfo.getWindowEndTimeMs()));
-        return builder;
-    }
-
-    private static int getGcmNetworkManagerNetworkTypeFromTypeFromTaskNetworkType(
-            @TaskInfo.NetworkType int networkType) {
-        switch (networkType) {
-            // This is correct: GcmNM ANY means no network is guaranteed.
-            case TaskInfo.NETWORK_TYPE_NONE:
-                return Task.NETWORK_STATE_ANY;
-            case TaskInfo.NETWORK_TYPE_ANY:
-                return Task.NETWORK_STATE_CONNECTED;
-            case TaskInfo.NETWORK_TYPE_UNMETERED:
-                return Task.NETWORK_STATE_UNMETERED;
-            default:
-                assert false;
-        }
-        return Task.NETWORK_STATE_ANY;
-    }
-
     @Override
     public boolean schedule(Context context, @NonNull TaskInfo taskInfo) {
-        ThreadUtils.assertOnUiThread();
-        if (!BackgroundTaskReflection.hasParameterlessPublicConstructor(
-                    taskInfo.getBackgroundTaskClass())) {
-            Log.e(TAG,
-                    "BackgroundTask " + taskInfo.getBackgroundTaskClass()
-                            + " has no parameterless public constructor.");
-            return false;
-        }
-
-        GcmNetworkManager gcmNetworkManager = getGcmNetworkManager(context);
-        if (gcmNetworkManager == null) {
-            Log.e(TAG, "GcmNetworkManager is not available.");
-            return false;
-        }
-
-        try {
-            Task task = createTaskFromTaskInfo(taskInfo);
-            gcmNetworkManager.schedule(task);
-        } catch (IllegalArgumentException e) {
-            String gcmErrorMessage = e.getMessage() == null ? "null." : e.getMessage();
-            Log.e(TAG,
-                    "GcmNetworkManager failed to schedule task, gcm message: " + gcmErrorMessage);
-            return false;
-        }
-
-        return true;
+        return false;
     }
 
     @Override
     public void cancel(Context context, int taskId) {
-        ThreadUtils.assertOnUiThread();
-
-        GcmNetworkManager gcmNetworkManager = getGcmNetworkManager(context);
-        if (gcmNetworkManager == null) {
-            Log.e(TAG, "GcmNetworkManager is not available.");
-            return;
-        }
-
-        try {
-            gcmNetworkManager.cancelTask(
-                    taskIdToTaskTag(taskId), BackgroundTaskGcmTaskService.class);
-        } catch (IllegalArgumentException e) {
-            Log.e(TAG, "GcmNetworkManager failed to cancel task.");
-        }
-    }
-
-    private GcmNetworkManager getGcmNetworkManager(Context context) {
-        if (GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context)
-                == ConnectionResult.SUCCESS) {
-            return GcmNetworkManager.getInstance(context);
-        }
-        return null;
     }
 
     private static String taskIdToTaskTag(int taskId) {
diff --git a/app/src/main/java/org/chromium/components/gcm_driver/instance_id/InstanceIDWithSubtype.java b/app/src/main/java/org/chromium/components/gcm_driver/instance_id/InstanceIDWithSubtype.java
index 243a086..6d67ab2 100644
--- a/app/src/main/java/org/chromium/components/gcm_driver/instance_id/InstanceIDWithSubtype.java
+++ b/app/src/main/java/org/chromium/components/gcm_driver/instance_id/InstanceIDWithSubtype.java
@@ -8,8 +8,6 @@ import android.content.Context;
 import android.os.Bundle;
 import android.text.TextUtils;
 
-import com.google.android.gms.iid.InstanceID;
-
 import org.chromium.base.VisibleForTesting;
 
 import java.io.IOException;
@@ -24,8 +22,6 @@ public class InstanceIDWithSubtype {
     // Must match the private InstanceID.OPTION_SUBTYPE, which is guaranteed to not change.
     private static final String OPTION_SUBTYPE = "subtype";
 
-    private final InstanceID mInstanceID;
-
     /**
      * Cached instances. May be accessed from multiple threads; synchronize on sSubtypeInstancesLock
      */
@@ -37,14 +33,6 @@ public class InstanceIDWithSubtype {
     @VisibleForTesting
     protected static FakeFactory sFakeFactoryForTesting;
 
-    protected InstanceIDWithSubtype(InstanceID instanceID) {
-        mInstanceID = instanceID;
-    }
-
-    /**
-     * Returns an instance of this class. Unlike {@link InstanceID#getInstance(Context)}, it is not
-     * a singleton, but instead a different instance will be returned for each {@code subtype}.
-     */
     public static InstanceIDWithSubtype getInstance(Context context, String subtype) {
         if (TextUtils.isEmpty(subtype)) {
             throw new IllegalArgumentException("subtype must not be empty");
@@ -59,8 +47,6 @@ public class InstanceIDWithSubtype {
                 } else {
                     Bundle options = new Bundle();
                     options.putCharSequence(OPTION_SUBTYPE, subtype);
-                    InstanceID instanceID = InstanceID.getInstance(context, options);
-                    existing = new InstanceIDWithSubtype(instanceID);
                 }
                 sSubtypeInstances.put(subtype, existing);
             }
@@ -69,35 +55,32 @@ public class InstanceIDWithSubtype {
     }
 
     public String getSubtype() {
-        return mInstanceID.getSubtype();
+        return null;
     }
 
     public String getId() {
-        return mInstanceID.getId();
+        return null;
     }
 
     public long getCreationTime() {
-        return mInstanceID.getCreationTime();
+        return 1;
     }
 
     public void deleteInstanceID() throws IOException {
         synchronized (sSubtypeInstancesLock) {
-            sSubtypeInstances.remove(mInstanceID.getSubtype());
-            mInstanceID.deleteInstanceID();
         }
     }
 
     public void deleteToken(String authorizedEntity, String scope) throws IOException {
-        mInstanceID.deleteToken(authorizedEntity, scope);
     }
 
     public String getToken(String authorizedEntity, String scope) throws IOException {
-        return mInstanceID.getToken(authorizedEntity, scope);
+        return null;
     }
 
     public String getToken(String authorizedEntity, String scope, Bundle extras)
             throws IOException {
-        return mInstanceID.getToken(authorizedEntity, scope, extras);
+        return null;
     }
 
     /** Fake subclasses can set {@link #sFakeFactoryForTesting} to an implementation of this. */
diff --git a/app/src/main/java/org/chromium/components/signin/AccountIdProvider.java b/app/src/main/java/org/chromium/components/signin/AccountIdProvider.java
index 192ea31..6ca388b 100644
--- a/app/src/main/java/org/chromium/components/signin/AccountIdProvider.java
+++ b/app/src/main/java/org/chromium/components/signin/AccountIdProvider.java
@@ -4,11 +4,6 @@
 
 package org.chromium.components.signin;
 
-import com.google.android.gms.auth.GoogleAuthException;
-import com.google.android.gms.auth.GoogleAuthUtil;
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.StrictModeContext;
@@ -40,12 +35,7 @@ public class AccountIdProvider {
      * @param accountName The email address of a Google account.
      */
     public String getAccountId(String accountName) {
-        try {
-            return GoogleAuthUtil.getAccountId(ContextUtils.getApplicationContext(), accountName);
-        } catch (IOException | GoogleAuthException ex) {
-            Log.e("cr.AccountIdProvider", "AccountIdProvider.getAccountId", ex);
-            return null;
-        }
+        return null;
     }
 
     /**
@@ -54,12 +44,7 @@ public class AccountIdProvider {
      * Google Play services is available.
      */
     public boolean canBeUsed() {
-        // TODO(http://crbug.com/577190): Remove StrictMode override.
-        try (StrictModeContext unused = StrictModeContext.allowDiskWrites()) {
-            int resultCode = GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(
-                    ContextUtils.getApplicationContext());
-            return resultCode == ConnectionResult.SUCCESS;
-        }
+            return false;
     }
 
     /**
diff --git a/app/src/main/java/org/chromium/components/signin/GmsAvailabilityException.java b/app/src/main/java/org/chromium/components/signin/GmsAvailabilityException.java
index 57d82e5..aca8951 100644
--- a/app/src/main/java/org/chromium/components/signin/GmsAvailabilityException.java
+++ b/app/src/main/java/org/chromium/components/signin/GmsAvailabilityException.java
@@ -4,8 +4,6 @@
 
 package org.chromium.components.signin;
 
-import com.google.android.gms.common.GoogleApiAvailability;
-
 /**
  * This class encapsulates return code if GMSCore package is not available.
  */
@@ -27,6 +25,6 @@ public class GmsAvailabilityException extends AccountManagerDelegateException {
     }
 
     public boolean isUserResolvableError() {
-        return GoogleApiAvailability.getInstance().isUserResolvableError(mResultCode);
+        return false;
     }
 }
diff --git a/app/src/main/java/org/chromium/components/signin/SystemAccountManagerDelegate.java b/app/src/main/java/org/chromium/components/signin/SystemAccountManagerDelegate.java
index b4ddb9a..3873cec 100644
--- a/app/src/main/java/org/chromium/components/signin/SystemAccountManagerDelegate.java
+++ b/app/src/main/java/org/chromium/components/signin/SystemAccountManagerDelegate.java
@@ -23,12 +23,6 @@ import android.os.PatternMatcher;
 import android.os.Process;
 import android.os.SystemClock;
 
-import com.google.android.gms.auth.GoogleAuthException;
-import com.google.android.gms.auth.GoogleAuthUtil;
-import com.google.android.gms.auth.GooglePlayServicesAvailabilityException;
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-
 import org.chromium.base.ApiCompatibilityUtils;
 import org.chromium.base.Callback;
 import org.chromium.base.ContextUtils;
@@ -87,17 +81,6 @@ public class SystemAccountManagerDelegate implements AccountManagerDelegate {
     }
 
     protected void checkCanUseGooglePlayServices() throws AccountManagerDelegateException {
-        Context context = ContextUtils.getApplicationContext();
-        final int resultCode =
-                GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context);
-        if (resultCode == ConnectionResult.SUCCESS) {
-            return;
-        }
-
-        throw new GmsAvailabilityException(
-                String.format("Can't use Google Play Services: %s",
-                        GoogleApiAvailability.getInstance().getErrorString(resultCode)),
-                resultCode);
     }
 
     @Override
@@ -114,52 +97,16 @@ public class SystemAccountManagerDelegate implements AccountManagerDelegate {
 
     @Override
     public Account[] getAccountsSync() throws AccountManagerDelegateException {
-        // Account seeding relies on GoogleAuthUtil.getAccountId to get GAIA ids,
-        // so don't report any accounts if Google Play Services are out of date.
-        checkCanUseGooglePlayServices();
-
-        if (!hasGetAccountsPermission()) {
-            return new Account[] {};
-        }
-        long now = SystemClock.elapsedRealtime();
-        Account[] accounts = mAccountManager.getAccountsByType(GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
-        long elapsed = SystemClock.elapsedRealtime() - now;
-        recordElapsedTimeHistogram("Signin.AndroidGetAccountsTime_AccountManager", elapsed);
-        if (ThreadUtils.runningOnUiThread()) {
-            recordElapsedTimeHistogram(
-                    "Signin.AndroidGetAccountsTimeUiThread_AccountManager", elapsed);
-        }
-        return accounts;
+        return new Account[] {};
     }
 
     @Override
     public String getAuthToken(Account account, String authTokenScope) throws AuthException {
-        assert !ThreadUtils.runningOnUiThread();
-        assert AccountManagerFacade.GOOGLE_ACCOUNT_TYPE.equals(account.type);
-        try {
-            return GoogleAuthUtil.getTokenWithNotification(
-                    ContextUtils.getApplicationContext(), account, authTokenScope, null);
-        } catch (GoogleAuthException ex) {
-            // This case includes a UserRecoverableNotifiedException, but most clients will have
-            // their own retry mechanism anyway.
-            throw new AuthException(AuthException.NONTRANSIENT,
-                    "Error while getting token for scope '" + authTokenScope + "'", ex);
-        } catch (IOException ex) {
-            throw new AuthException(AuthException.TRANSIENT, ex);
-        }
+        return null;
     }
 
     @Override
     public void invalidateAuthToken(String authToken) throws AuthException {
-        try {
-            GoogleAuthUtil.clearToken(ContextUtils.getApplicationContext(), authToken);
-        } catch (GooglePlayServicesAvailabilityException ex) {
-            throw new AuthException(AuthException.NONTRANSIENT, ex);
-        } catch (GoogleAuthException ex) {
-            throw new AuthException(AuthException.NONTRANSIENT, ex);
-        } catch (IOException ex) {
-            throw new AuthException(AuthException.TRANSIENT, ex);
-        }
     }
 
     @Override
diff --git a/app/src/main/java/org/chromium/device/geolocation/LocationProviderGmsCore.java b/app/src/main/java/org/chromium/device/geolocation/LocationProviderGmsCore.java
index 9be2ee1..197be5d 100644
--- a/app/src/main/java/org/chromium/device/geolocation/LocationProviderGmsCore.java
+++ b/app/src/main/java/org/chromium/device/geolocation/LocationProviderGmsCore.java
@@ -8,16 +8,6 @@ import android.content.Context;
 import android.location.Location;
 import android.os.Bundle;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.common.api.GoogleApiClient.ConnectionCallbacks;
-import com.google.android.gms.common.api.GoogleApiClient.OnConnectionFailedListener;
-import com.google.android.gms.location.FusedLocationProviderApi;
-import com.google.android.gms.location.LocationListener;
-import com.google.android.gms.location.LocationRequest;
-import com.google.android.gms.location.LocationServices;
-
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
 
@@ -26,114 +16,47 @@ import org.chromium.base.ThreadUtils;
  *
  * https://developers.google.com/android/reference/com/google/android/gms/location/package-summary
  */
-public class LocationProviderGmsCore implements ConnectionCallbacks, OnConnectionFailedListener,
-                                                LocationListener,
-                                                LocationProviderFactory.LocationProvider {
+public class LocationProviderGmsCore implements LocationProviderFactory.LocationProvider {
     private static final String TAG = "cr_LocationProvider";
 
     // Values for the LocationRequest's setInterval for normal and high accuracy, respectively.
     private static final long UPDATE_INTERVAL_MS = 1000;
     private static final long UPDATE_INTERVAL_FAST_MS = 500;
 
-    private final GoogleApiClient mGoogleApiClient;
-    private FusedLocationProviderApi mLocationProviderApi = LocationServices.FusedLocationApi;
-
     private boolean mEnablehighAccuracy;
-    private LocationRequest mLocationRequest;
 
     public static boolean isGooglePlayServicesAvailable(Context context) {
-        return GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context)
-                == ConnectionResult.SUCCESS;
+        return false;
     }
 
     LocationProviderGmsCore(Context context) {
-        Log.i(TAG, "Google Play Services");
-        mGoogleApiClient = new GoogleApiClient.Builder(context)
-                                   .addApi(LocationServices.API)
-                                   .addConnectionCallbacks(this)
-                                   .addOnConnectionFailedListener(this)
-                                   .build();
-        assert mGoogleApiClient != null;
     }
 
-    LocationProviderGmsCore(GoogleApiClient client, FusedLocationProviderApi locationApi) {
-        mGoogleApiClient = client;
-        mLocationProviderApi = locationApi;
-    }
 
-    // ConnectionCallbacks implementation
-    @Override
     public void onConnected(Bundle connectionHint) {
         ThreadUtils.assertOnUiThread();
-
-        mLocationRequest = LocationRequest.create();
-        if (mEnablehighAccuracy) {
-            mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
-                    .setInterval(UPDATE_INTERVAL_FAST_MS);
-        } else {
-            mLocationRequest.setPriority(LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY)
-                    .setInterval(UPDATE_INTERVAL_MS);
-        }
-
-        final Location location = mLocationProviderApi.getLastLocation(mGoogleApiClient);
-        if (location != null) {
-            LocationProviderAdapter.onNewLocationAvailable(location);
-        }
-
-        try {
-            // Request updates on UI Thread replicating LocationProviderAndroid's behaviour.
-            mLocationProviderApi.requestLocationUpdates(
-                    mGoogleApiClient, mLocationRequest, this, ThreadUtils.getUiThreadLooper());
-        } catch (IllegalStateException | SecurityException e) {
-            // IllegalStateException is thrown "If this method is executed in a thread that has not
-            // called Looper.prepare()". SecurityException is thrown if there is no permission, see
-            // https://crbug.com/731271.
-            Log.e(TAG, " mLocationProviderApi.requestLocationUpdates() " + e);
-            LocationProviderAdapter.newErrorAvailable(
-                    "Failed to request location updates: " + e.toString());
-            assert false;
-        }
+        assert false;
     }
 
-    @Override
     public void onConnectionSuspended(int cause) {}
 
-    // OnConnectionFailedListener implementation
-    @Override
-    public void onConnectionFailed(ConnectionResult result) {
-        LocationProviderAdapter.newErrorAvailable(
-                "Failed to connect to Google Play Services: " + result.toString());
-    }
-
     // LocationProviderFactory.LocationProvider implementation
     @Override
     public void start(boolean enableHighAccuracy) {
-        ThreadUtils.assertOnUiThread();
-        if (mGoogleApiClient.isConnected()) mGoogleApiClient.disconnect();
-
-        mEnablehighAccuracy = enableHighAccuracy;
-        mGoogleApiClient.connect(); // Should return via onConnected().
     }
 
     @Override
     public void stop() {
         ThreadUtils.assertOnUiThread();
-        if (!mGoogleApiClient.isConnected()) return;
-
-        mLocationProviderApi.removeLocationUpdates(mGoogleApiClient, this);
-
-        mGoogleApiClient.disconnect();
+        return;
     }
 
     @Override
     public boolean isRunning() {
         assert ThreadUtils.runningOnUiThread();
-        if (mGoogleApiClient == null) return false;
-        return mGoogleApiClient.isConnecting() || mGoogleApiClient.isConnected();
+        return false;
     }
 
-    // LocationListener implementation
-    @Override
     public void onLocationChanged(Location location) {
         LocationProviderAdapter.onNewLocationAvailable(location);
     }
diff --git a/app/src/main/java/org/chromium/device/vr/NonPresentingGvrContext.java b/app/src/main/java/org/chromium/device/vr/NonPresentingGvrContext.java
index d7ba07e..11bab13 100644
--- a/app/src/main/java/org/chromium/device/vr/NonPresentingGvrContext.java
+++ b/app/src/main/java/org/chromium/device/vr/NonPresentingGvrContext.java
@@ -9,9 +9,6 @@ import android.os.StrictMode;
 import android.view.Display;
 import android.view.WindowManager;
 
-import com.google.vr.cardboard.DisplaySynchronizer;
-import com.google.vr.ndk.base.GvrApi;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.base.annotations.JNINamespace;
@@ -23,8 +20,6 @@ import org.chromium.base.annotations.JNINamespace;
  */
 @JNINamespace("device")
 public class NonPresentingGvrContext {
-    private GvrApi mGvrApi;
-    private DisplaySynchronizer mDisplaySynchronizer;
     private boolean mResumed;
 
     private long mNativeGvrDevice;
@@ -35,18 +30,10 @@ public class NonPresentingGvrContext {
         WindowManager windowManager =
                 (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
         Display display = windowManager.getDefaultDisplay();
-        mDisplaySynchronizer = new DisplaySynchronizer(context, display) {
-            @Override
-            public void onConfigurationChanged() {
-                super.onConfigurationChanged();
-                onDisplayConfigurationChanged();
-            }
-        };
 
         // Creating the GvrApi can sometimes create the Daydream config file.
         StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
         try {
-            mGvrApi = new GvrApi(context, mDisplaySynchronizer);
         } finally {
             StrictMode.setThreadPolicy(oldPolicy);
         }
@@ -64,32 +51,27 @@ public class NonPresentingGvrContext {
 
     @CalledByNative
     private long getNativeGvrContext() {
-        return mGvrApi.getNativeGvrContext();
+        return 1;
     }
 
     @CalledByNative
     private void pause() {
         if (!mResumed) return;
         mResumed = false;
-        mDisplaySynchronizer.onPause();
     }
 
     @CalledByNative
     private void resume() {
         if (mResumed) return;
         mResumed = true;
-        mDisplaySynchronizer.onResume();
     }
 
     @CalledByNative
     private void shutdown() {
-        mDisplaySynchronizer.shutdown();
-        mGvrApi.shutdown();
         mNativeGvrDevice = 0;
     }
 
     public void onDisplayConfigurationChanged() {
-        mGvrApi.refreshDisplayMetrics();
         if (mNativeGvrDevice != 0) nativeOnDisplayConfigurationChanged(mNativeGvrDevice);
     }
 
diff --git a/app/src/main/java/org/chromium/shape_detection/BarcodeDetectionImpl.java b/app/src/main/java/org/chromium/shape_detection/BarcodeDetectionImpl.java
index 8198154..88dd667 100644
--- a/app/src/main/java/org/chromium/shape_detection/BarcodeDetectionImpl.java
+++ b/app/src/main/java/org/chromium/shape_detection/BarcodeDetectionImpl.java
@@ -8,12 +8,6 @@ import android.graphics.Point;
 import android.graphics.Rect;
 import android.util.SparseArray;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-import com.google.android.gms.vision.Frame;
-import com.google.android.gms.vision.barcode.Barcode;
-import com.google.android.gms.vision.barcode.BarcodeDetector;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.gfx.mojom.PointF;
@@ -29,11 +23,7 @@ import org.chromium.shape_detection.mojom.BarcodeDetectionResult;
 public class BarcodeDetectionImpl implements BarcodeDetection {
     private static final String TAG = "BarcodeDetectionImpl";
 
-    private BarcodeDetector mBarcodeDetector;
-
     public BarcodeDetectionImpl() {
-        mBarcodeDetector =
-                new BarcodeDetector.Builder(ContextUtils.getApplicationContext()).build();
     }
 
     @Override
@@ -42,46 +32,12 @@ public class BarcodeDetectionImpl implements BarcodeDetection {
         // on the device; this happens "fast", but it might have not completed,
         // bail in this case. Also, the API was disabled between and v.9.0 and
         // v.9.2, see https://developers.google.com/android/guides/releases.
-        if (!mBarcodeDetector.isOperational()) {
-            Log.e(TAG, "BarcodeDetector is not operational");
-            callback.call(new BarcodeDetectionResult[0]);
-            return;
-        }
-
-        Frame frame = BitmapUtils.convertToFrame(bitmapData);
-        if (frame == null) {
-            Log.e(TAG, "Error converting Mojom Bitmap to Frame");
-            callback.call(new BarcodeDetectionResult[0]);
-            return;
-        }
-
-        final SparseArray<Barcode> barcodes = mBarcodeDetector.detect(frame);
-
-        BarcodeDetectionResult[] barcodeArray = new BarcodeDetectionResult[barcodes.size()];
-        for (int i = 0; i < barcodes.size(); i++) {
-            barcodeArray[i] = new BarcodeDetectionResult();
-            final Barcode barcode = barcodes.valueAt(i);
-            barcodeArray[i].rawValue = barcode.rawValue;
-            final Rect rect = barcode.getBoundingBox();
-            barcodeArray[i].boundingBox = new RectF();
-            barcodeArray[i].boundingBox.x = rect.left;
-            barcodeArray[i].boundingBox.y = rect.top;
-            barcodeArray[i].boundingBox.width = rect.width();
-            barcodeArray[i].boundingBox.height = rect.height();
-            final Point[] corners = barcode.cornerPoints;
-            barcodeArray[i].cornerPoints = new PointF[corners.length];
-            for (int j = 0; j < corners.length; j++) {
-                barcodeArray[i].cornerPoints[j] = new PointF();
-                barcodeArray[i].cornerPoints[j].x = corners[j].x;
-                barcodeArray[i].cornerPoints[j].y = corners[j].y;
-            }
-        }
-        callback.call(barcodeArray);
+        return;
     }
 
     @Override
     public void close() {
-        mBarcodeDetector.release();
+
     }
 
     @Override
@@ -97,13 +53,7 @@ public class BarcodeDetectionImpl implements BarcodeDetection {
 
         @Override
         public BarcodeDetection createImpl() {
-            if (GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(
-                        ContextUtils.getApplicationContext())
-                    != ConnectionResult.SUCCESS) {
-                Log.e(TAG, "Google Play Services not available");
-                return null;
-            }
-            return new BarcodeDetectionImpl();
+            return null;
         }
     }
 }
diff --git a/app/src/main/java/org/chromium/shape_detection/BitmapUtils.java b/app/src/main/java/org/chromium/shape_detection/BitmapUtils.java
index d9242c4..a9b44f4 100644
--- a/app/src/main/java/org/chromium/shape_detection/BitmapUtils.java
+++ b/app/src/main/java/org/chromium/shape_detection/BitmapUtils.java
@@ -6,8 +6,6 @@ package org.chromium.shape_detection;
 
 import android.graphics.Bitmap;
 
-import com.google.android.gms.vision.Frame;
-
 import org.chromium.skia.mojom.ColorType;
 
 import java.nio.ByteBuffer;
@@ -41,14 +39,4 @@ public class BitmapUtils {
 
         return bitmap;
     }
-
-    public static Frame convertToFrame(org.chromium.skia.mojom.Bitmap bitmapData) {
-        Bitmap bitmap = convertToBitmap(bitmapData);
-        if (bitmap == null) {
-            return null;
-        }
-
-        // This constructor implies a pixel format conversion to YUV.
-        return new Frame.Builder().setBitmap(bitmap).build();
-    }
 }
diff --git a/app/src/main/java/org/chromium/shape_detection/FaceDetectionImplGmsCore.java b/app/src/main/java/org/chromium/shape_detection/FaceDetectionImplGmsCore.java
index a9d47ac..587bd62 100644
--- a/app/src/main/java/org/chromium/shape_detection/FaceDetectionImplGmsCore.java
+++ b/app/src/main/java/org/chromium/shape_detection/FaceDetectionImplGmsCore.java
@@ -7,11 +7,6 @@ package org.chromium.shape_detection;
 import android.graphics.PointF;
 import android.util.SparseArray;
 
-import com.google.android.gms.vision.Frame;
-import com.google.android.gms.vision.face.Face;
-import com.google.android.gms.vision.face.FaceDetector;
-import com.google.android.gms.vision.face.Landmark;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.gfx.mojom.RectF;
@@ -34,28 +29,8 @@ public class FaceDetectionImplGmsCore implements FaceDetection {
     // Maximum rotation around the z-axis allowed when computing a tighter bounding box for the
     // detected face.
     private static final int MAX_EULER_Z = 15;
-    private final int mMaxFaces;
-    private final boolean mFastMode;
-    private final FaceDetector mFaceDetector;
 
     FaceDetectionImplGmsCore(FaceDetectorOptions options) {
-        FaceDetector.Builder builder =
-                new FaceDetector.Builder(ContextUtils.getApplicationContext());
-        mMaxFaces = Math.min(options.maxDetectedFaces, MAX_FACES);
-        mFastMode = options.fastMode;
-
-        try {
-            builder.setMode(mFastMode ? FaceDetector.FAST_MODE : FaceDetector.ACCURATE_MODE);
-            builder.setLandmarkType(FaceDetector.ALL_LANDMARKS);
-            if (mMaxFaces == 1) {
-                builder.setProminentFaceOnly(true);
-            }
-        } catch (IllegalArgumentException e) {
-            Log.e(TAG, "Unexpected exception " + e);
-            assert false;
-        }
-
-        mFaceDetector = builder.build();
     }
 
     @Override
@@ -63,99 +38,12 @@ public class FaceDetectionImplGmsCore implements FaceDetection {
         // The vision library will be downloaded the first time the API is used
         // on the device; this happens "fast", but it might have not completed,
         // bail in this case.
-        if (!mFaceDetector.isOperational()) {
-            Log.e(TAG, "FaceDetector is not operational");
-
-            // Fallback to Android's FaceDetectionImpl.
-            FaceDetectorOptions options = new FaceDetectorOptions();
-            options.fastMode = mFastMode;
-            options.maxDetectedFaces = mMaxFaces;
-            FaceDetectionImpl detector = new FaceDetectionImpl(options);
-            detector.detect(bitmapData, callback);
-            return;
-        }
-
-        Frame frame = BitmapUtils.convertToFrame(bitmapData);
-        if (frame == null) {
-            Log.e(TAG, "Error converting Mojom Bitmap to Frame");
-            callback.call(new FaceDetectionResult[0]);
-            return;
-        }
-
-        final SparseArray<Face> faces = mFaceDetector.detect(frame);
-
-        FaceDetectionResult[] faceArray = new FaceDetectionResult[faces.size()];
-        for (int i = 0; i < faces.size(); i++) {
-            faceArray[i] = new FaceDetectionResult();
-            final Face face = faces.valueAt(i);
-
-            final List<Landmark> landmarks = face.getLandmarks();
-            ArrayList<org.chromium.shape_detection.mojom.Landmark> mojoLandmarks =
-                    new ArrayList<org.chromium.shape_detection.mojom.Landmark>(landmarks.size());
-
-            int leftEyeIndex = -1;
-            int rightEyeIndex = -1;
-            int bottomMouthIndex = -1;
-            for (int j = 0; j < landmarks.size(); j++) {
-                final Landmark landmark = landmarks.get(j);
-                final int landmarkType = landmark.getType();
-                if (landmarkType == Landmark.LEFT_EYE || landmarkType == Landmark.RIGHT_EYE
-                        || landmarkType == Landmark.BOTTOM_MOUTH) {
-                    org.chromium.shape_detection.mojom.Landmark mojoLandmark =
-                            new org.chromium.shape_detection.mojom.Landmark();
-                    mojoLandmark.location = new org.chromium.gfx.mojom.PointF();
-                    mojoLandmark.location.x = landmark.getPosition().x;
-                    mojoLandmark.location.y = landmark.getPosition().y;
-                    mojoLandmark.type = landmarkType == Landmark.BOTTOM_MOUTH ? LandmarkType.MOUTH
-                                                                              : LandmarkType.EYE;
-                    mojoLandmarks.add(mojoLandmark);
-
-                    if (landmarkType == Landmark.LEFT_EYE) {
-                        leftEyeIndex = j;
-                    } else if (landmarkType == Landmark.RIGHT_EYE) {
-                        rightEyeIndex = j;
-                    } else {
-                        assert landmarkType == Landmark.BOTTOM_MOUTH;
-                        bottomMouthIndex = j;
-                    }
-                }
-            }
-            faceArray[i].landmarks = mojoLandmarks.toArray(
-                    new org.chromium.shape_detection.mojom.Landmark[mojoLandmarks.size()]);
-
-            final PointF corner = face.getPosition();
-            faceArray[i].boundingBox = new RectF();
-            if (leftEyeIndex != -1 && rightEyeIndex != -1
-                    && Math.abs(face.getEulerZ()) < MAX_EULER_Z) {
-                // Tighter calculation of the bounding box because the GMScore
-                // and Android Face APIs give different results.
-                final PointF leftEyePoint = landmarks.get(leftEyeIndex).getPosition();
-                final PointF rightEyePoint = landmarks.get(rightEyeIndex).getPosition();
-                final float eyesDistance = leftEyePoint.x - rightEyePoint.x;
-                final float eyeMouthDistance = bottomMouthIndex != -1
-                        ? landmarks.get(bottomMouthIndex).getPosition().y - leftEyePoint.y
-                        : -1;
-                final PointF midEyePoint =
-                        new PointF(corner.x + face.getWidth() / 2, leftEyePoint.y);
-                faceArray[i].boundingBox.x = 2 * rightEyePoint.x - midEyePoint.x;
-                faceArray[i].boundingBox.y = midEyePoint.y - eyesDistance;
-                faceArray[i].boundingBox.width = 2 * eyesDistance;
-                faceArray[i].boundingBox.height = eyeMouthDistance > eyesDistance
-                        ? eyeMouthDistance + eyesDistance
-                        : 2 * eyesDistance;
-            } else {
-                faceArray[i].boundingBox.x = corner.x;
-                faceArray[i].boundingBox.y = corner.y;
-                faceArray[i].boundingBox.width = face.getWidth();
-                faceArray[i].boundingBox.height = face.getHeight();
-            }
-        }
-        callback.call(faceArray);
+        return;
     }
 
     @Override
     public void close() {
-        mFaceDetector.release();
+
     }
 
     @Override
diff --git a/app/src/main/java/org/chromium/shape_detection/FaceDetectionProviderImpl.java b/app/src/main/java/org/chromium/shape_detection/FaceDetectionProviderImpl.java
index 2195fb1..0c54792 100644
--- a/app/src/main/java/org/chromium/shape_detection/FaceDetectionProviderImpl.java
+++ b/app/src/main/java/org/chromium/shape_detection/FaceDetectionProviderImpl.java
@@ -4,9 +4,6 @@
 
 package org.chromium.shape_detection;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.mojo.bindings.InterfaceRequest;
 import org.chromium.mojo.system.MojoException;
@@ -24,10 +21,7 @@ public class FaceDetectionProviderImpl implements FaceDetectionProvider {
     @Override
     public void createFaceDetection(
             InterfaceRequest<FaceDetection> request, FaceDetectorOptions options) {
-        final boolean isGmsCoreSupported =
-                GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(
-                        ContextUtils.getApplicationContext())
-                == ConnectionResult.SUCCESS;
+        final boolean isGmsCoreSupported = false;
 
         if (isGmsCoreSupported) {
             FaceDetection.MANAGER.bind(new FaceDetectionImplGmsCore(options), request);
diff --git a/app/src/main/java/org/chromium/shape_detection/TextDetectionImpl.java b/app/src/main/java/org/chromium/shape_detection/TextDetectionImpl.java
index ec20ea4..ae4ac53 100644
--- a/app/src/main/java/org/chromium/shape_detection/TextDetectionImpl.java
+++ b/app/src/main/java/org/chromium/shape_detection/TextDetectionImpl.java
@@ -8,12 +8,6 @@ import android.graphics.Point;
 import android.graphics.Rect;
 import android.util.SparseArray;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-import com.google.android.gms.vision.Frame;
-import com.google.android.gms.vision.text.TextBlock;
-import com.google.android.gms.vision.text.TextRecognizer;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.gfx.mojom.PointF;
@@ -30,10 +24,8 @@ import org.chromium.shape_detection.mojom.TextDetectionResult;
 public class TextDetectionImpl implements TextDetection {
     private static final String TAG = "TextDetectionImpl";
 
-    private TextRecognizer mTextRecognizer;
 
     public TextDetectionImpl() {
-        mTextRecognizer = new TextRecognizer.Builder(ContextUtils.getApplicationContext()).build();
     }
 
     @Override
@@ -42,46 +34,12 @@ public class TextDetectionImpl implements TextDetection {
         // on the device; this happens "fast", but it might have not completed,
         // bail in this case. Also, the API was disabled between and v.9.0 and
         // v.9.2, see https://developers.google.com/android/guides/releases.
-        if (!mTextRecognizer.isOperational()) {
-            Log.e(TAG, "TextDetector is not operational");
-            callback.call(new TextDetectionResult[0]);
-            return;
-        }
-
-        Frame frame = BitmapUtils.convertToFrame(bitmapData);
-        if (frame == null) {
-            Log.e(TAG, "Error converting Mojom Bitmap to Frame");
-            callback.call(new TextDetectionResult[0]);
-            return;
-        }
-
-        final SparseArray<TextBlock> textBlocks = mTextRecognizer.detect(frame);
-
-        TextDetectionResult[] detectedTextArray = new TextDetectionResult[textBlocks.size()];
-        for (int i = 0; i < textBlocks.size(); i++) {
-            detectedTextArray[i] = new TextDetectionResult();
-            final TextBlock textBlock = textBlocks.valueAt(i);
-            detectedTextArray[i].rawValue = textBlock.getValue();
-            final Rect rect = textBlock.getBoundingBox();
-            detectedTextArray[i].boundingBox = new RectF();
-            detectedTextArray[i].boundingBox.x = rect.left;
-            detectedTextArray[i].boundingBox.y = rect.top;
-            detectedTextArray[i].boundingBox.width = rect.width();
-            detectedTextArray[i].boundingBox.height = rect.height();
-            final Point[] corners = textBlock.getCornerPoints();
-            detectedTextArray[i].cornerPoints = new PointF[corners.length];
-            for (int j = 0; j < corners.length; j++) {
-                detectedTextArray[i].cornerPoints[j] = new PointF();
-                detectedTextArray[i].cornerPoints[j].x = corners[j].x;
-                detectedTextArray[i].cornerPoints[j].y = corners[j].y;
-            }
-        }
-        callback.call(detectedTextArray);
+        return;
     }
 
     @Override
     public void close() {
-        mTextRecognizer.release();
+
     }
 
     @Override
@@ -97,13 +55,7 @@ public class TextDetectionImpl implements TextDetection {
 
         @Override
         public TextDetection createImpl() {
-            if (GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(
-                        ContextUtils.getApplicationContext())
-                    != ConnectionResult.SUCCESS) {
-                Log.e(TAG, "Google Play Services not available");
                 return null;
-            }
-            return new TextDetectionImpl();
         }
     }
 }
-- 
2.17.1

